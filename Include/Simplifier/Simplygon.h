#ifndef _SIMPLYGON_H_
#define _SIMPLYGON_H_

#include <string.h>
#include <stdint.h>

/// The version of this header, as a macro definition, for conditional builds.
/// Use GetHeaderVersion() to get full version including 
/// build number, and use GetInterfaceVersionHash() to get the hash of the interface.
#define Simplygon_VERSION 0x0901

#ifdef SGDEPRECATED
#undef SGDEPRECATED
#endif
#ifdef _WIN32
#pragma warning( push )
#pragma warning( disable : 4996 )
#endif

#if defined(SGSDK) || defined(WITH_SIMPLYGON_DLL) || defined(SGDEPRECATED_OFF)
// internal Simplygon, Unreal Engine, or deprecation warning disabled
#define SGDEPRECATED
#else
#ifdef _WIN32 // Microsoft compiler
#if (_MSC_VER >= 1300) // 7.1
#define SGDEPRECATED __declspec(deprecated)
#else
#define SGDEPRECATED
#endif
#else
#define SGDEPRECATED
#endif
#endif
	
namespace Simplygon
{

	/// BaseTypes are ids of the base types used by data containers (arrays etc.) within Simplygon.
	enum class EBaseTypes
	{
		TYPES_ID_BOOL = 1,
		TYPES_ID_CHAR = 2,
		TYPES_ID_UCHAR = 3,
		TYPES_ID_SHORT = 4,
		TYPES_ID_USHORT = 5,
		TYPES_ID_INT = 6,
		TYPES_ID_UINT = 7,
		TYPES_ID_LONG = 8,
		TYPES_ID_ULONG = 9,
		TYPES_ID_FLOAT = 10,
		TYPES_ID_DOUBLE = 11,
		TYPES_ID_REAL = 12,
		TYPES_ID_RID = 13,
		TYPES_ID_RCHAR = 14, // note: TYPES_ID_RCHAR is deprecated and not used anymore
		TYPES_ID_RHANDLE = 15,
		TYPES_ID_STRING = 16,
		TYPES_ID_OBJECT = 17
	};

	/// Error codes that are returned on initialization/finalization of the library
	enum class EErrorCodes
	{
		/// no error
		NoError = 0,

		/// no license was found (or licence expired)
		NoLicense = -1,

		/// the SDK is not initialized, or no process object has been loaded/created
		NotInitialized = -2,

		/// the SDK is already initialized
		AlreadyInitialized = -3,

		/// the specified file was not found. This might also mean that a .dll cannot be loaded because there is a missing dependency, such as the runtime environment.
		DLLOrDependenciesNotFound = -4,

		/// an invalid parameter was passed to the method
		InvalidInputParam = -5,

		/// the reduction failed post-testing
		FailedTesting = -6,

		/// the Simplygon DLL and header file interface versions do not match
		DLLAndHeaderFileIsNotMatching = -7,

		/// the Simplygon DLL failed loading, probably because of a missing dependency
		DLLFailedToLoad = -8,

		/// the license is not made for this application of Simplygon
		LicenseNotForThisApplication = -9,

		/// the license is not made for this platform of Simplygon
		LicenseNotForThisPlatform = -10,

		/// the license is not made for this version of Simplygon
		LicenseNotForThisVersion = -11,

		/// failed to create pipeline serializer
		FailedToCreatePipelineSerializer = -12,

		/// failed to run pipeline
		FailedToRunPipeline = -13,

		/// failed to upload free license asset
		FailedToUploadFreeLicenseAsset = -50,

		/// cannot reach the licensing server, cant look up server, check DNS
		FailedToResolveLicenseServerHostName = -10001,

		/// cannot contact the licensing server, check firewall/proxy server
		FailedToConnectToLicenseServer = -10002,

		/// Failed to connect to the license server. Please check that your internet connection is working and outgoing connections to license.simplygon.com port 443 are not blocked by a firewall or proxy.
		FailedToConnectToLicenseServerAndSendData = -10003,

		/// cannot receive data from the licensing server, check firewall/proxy server
		FailedToConnectToLicenseServerAndReceiveData = -10004,

		/// data from licensing server is corrupted, try again, check connection
		DataFromLicenseServerIsCorrupt = -10005,

		/// the license has expired
		LicenseHasExpired = -10006,

		/// the license data is corrupted, please reinstall the license key
		LicenseIsInvalid = -10007,

		/// the license is not for this product, please contact licensing, and replace license key
		LicenseNotForThisProduct = -10008,

		/// no network card was found on the machine
		NoNetworkCardFound = -10009,

		/// could not decode license, it is corrupted
		LicenseDecodeFailed = -10010,

		/// the license is locked to another machine
		LicenseLockNotMatchingMachine = -10011,

		/// Connection to license server lost
		ConnectionToLicenseServerLost = -10012,

		/// could not decode license, it is corrupted
		LicenseHashDataCorrupt = -10013,

		/// the license is invalid, please contact licensing
		LicenseExpired = -10014,

		/// the license is locked to another machine
		LicenseNotLockedForThisMachine = -10020,

		/// your license requires latest Windows 10 version
		YourLicenseRequiresLatestWindows10 = -10024,

		/// Bad license request. Please reach out to SimplygonSupport[at]microsoft.com for support
		LicenseServerReturnedBadRequest = -10400,

		/// You are using an unknown license key. Please verify so you typed in the license key correctly and try again
		UnknownLicenseKey = -10404,

		/// You are using an inactive license key. Please reach out to SimplygonSales[at]microsoft.com for support
		LicenseIsNotActive = -10410,

		/// You have reached the maximum number of nodes for your license. After 48 hours of not using Simplygon on a machine the license will be released and can be installed on another machine
		MaxNodesReachForThisLicense = -10409,

		/// The license key you are using requires you to update to the latest version before you can use Simplygon
		YourLicenseRequiresLatestSimplygon = -10426,

		/// Bad license request. Please reach out to SimplygonSupport[at]microsoft.com for support
		LicenseServerReturnServerError = -10501
	};

	/// GeometryValidationCodes are used by the Geometry Validation system to report errors in a setup geometry.
	enum class EGeometryValidationCodes
	{
		/// no error
		NoError = 0x00000000,

		/// a float is not a number
		NanFloat = 0x00000001,

		/// the triangle count is illegal (probably 0)
		IllegalTriangleCount = 0x00000002,

		/// the vertex count is illegal (probably 0)
		IllegalVertexCount = 0x00000004,

		/// the vertex indices are illegal
		IllegalIndices = 0x00000008,

		/// a found triangle has illegal index setup
		IllegalTriangle = 0x00000010,

		/// a field has illegal number of items
		IllegalFieldItemCount = 0x00000020,

		/// a field has illegal number of tuples
		IllegalFieldTupleCount = 0x00000040,

		/// a field has illegal size of tuples
		IllegalFieldTupleSize = 0x00000080,

		/// a field has illegal values (probably an index out of bounds)
		IllegalFieldItemValue = 0x00000100,

		/// a found triangle has no area
		ZeroAreaTriangle = 0x00000200,

		/// the skinning field has illegal values (probably an index out of bounds)
		IllegalBoneTupleSize = 0x00000400,

		/// there is a missing object in the scene/geometry that should never be missing
		MissingObject = 0x00000800,

		/// a found bone is illegal within the scene
		IllegalBone = 0x00001000,

		/// a normal has zero length
		ZeroLengthNormal = 0x00002000,

		/// a float is too large for reliable arithmetic
		LargeFloat = 0x00004000,

		/// a float is too small and denormal
		DenormalFloat = 0x00008000,

		/// a node has an illegal GUID
		IllegalSceneNodeGuid = 0x00010000
	};

	/// StopCondition determines if the processing will stop when any or all of the set targets have been hit.
	enum class EStopCondition
	{
		/// Simplygon will stop as soon as one of the reduction targets has been fulfilled.
		Any = 0x00000000,

		/// Simplygon will continue processing until all of the reduction targets have been fulfilled.
		All = 0x00000001
	};

	/// ReductionHeuristics decides how precise calculations Simplygon will do during the optimization of the Scene.
	enum class EReductionHeuristics
	{
		/// Faster but with less precise calculations.
		Fast = 0x00000000,

		/// Slower but more accurate.
		Consistent = 0x00000001
	};

	/// DataCreationPreferences specifies how big freedom Simplygon has when it comes to altering vertex/triangle data. Allowing more altered data means it will be easier to create good looking LODs, but without altered data it will be easier to keep the memory-usage in the LOD-chain more optimized.
	enum class EDataCreationPreferences
	{
		/// Vertex and Corner data such as coordinates and normals will be completely re-used from the original Scene.
		OnlyUseOriginalData = 0x00000000,

		/// Vertex coordinates will remaining as they were in the original Scene, but corner normals might be changed if Simplygon decided it will look better.
		PreferOriginalData = 0x00000001,

		/// Both vertex coordinates and corner normals will be altered to make the optimized Scene look as good as possible.
		PreferOptimizedResult = 0x00000002
	};

	/// This is used when fetching data from the original Scene to the Remeshed scene, for data such as textures, vertex colors and skinning.
	enum class ESurfaceTransferMode
	{
		/// Faster but with less precise calculations.
		Fast = 0x00000000,

		/// Slower and more accurate.
		Accurate = 0x00000001
	};

	/// The fill mode determines what to do with the pixels that remain unfilled after both the casting and dilation has been performed.
	enum class EAtlasFillMode
	{
		/// linearly interpolate the closest samples
		Interpolate = 0x00000000,

		/// use the closest available pixel value without interpolation
		NearestNeighbor = 0x00000001,

		/// Do not fill remaining pixels
		NoFill = 0x00000002
	};

	/// DitherPatterns are used to set the dithering type to use when generating images.
	enum class EDitherPatterns
	{
		/// Use no dithering
		NoDither = 0x00000000,

		/// Use Floys-Steinberg dithering
		FloydSteinberg = 0x00000001,

		/// Use Jarvis, Judice, and Ninke dithering
		JarvisJudiceNinke = 0x00000002,

		/// Use Sierra-3 (three row) dithering
		Sierra = 0x00000003
	};

	/// This decides whether an occlusion mesh generated with the corresponding setting is larger or smaller than the input mesh.
	enum class EOcclusionMode
	{
		/// The output mesh will be an occluder, ie. always smaller than the input mesh.
		Occluder = 0x00000000,

		/// The output mesh will be an occludee, ie. always larger than the input mesh.
		Occludee = 0x00000001,

		/// The output mesh will be the same size as the input, ie. appropriate for things like off-screen shadows.
		Standard = 0x00000002
	};

	/// TangentSpaceMethod is used to specify which tangent space method is usedto generate tangent spaces when processing. Use OrthonormalLeftHandedto generate tangents that are D3D compatible (left-handed coordinate system).
	enum class ETangentSpaceMethod
	{
		/// Standard method, creates an orthonormal tangent space (right-handed)
		OrthonormalRightHanded = 0x00000000,

		/// 3dsMax compatible method, creates tangent space that is compatible with the 3dsMax renderer
		Autodesk3dsMax = 0x00000001,

		/// Creates an orthonormal tangent space (left-handed, D3D compatible)
		OrthonormalLeftHanded = 0x00000002,

		/// Creates a tangent space using the MikkTSpace tangent space generation algorithm.
		MikkTSpace = 0x00000003
	};

	/// Validation level is used to specify how often validation is done on geometries when debugging integrations.
	enum class EValidationFrequency
	{
		/// Normal level, validation will hardly be noticeable at all
		Normal = 0x00000000,

		/// Core debugging level, validation will be carried out before each processing step, and increase processing times significantly
		Core = 0x00000001,

		/// Ultra level, validation will be carried out very often, multiple times per processing step. This will increase processing times with orders of magnitudes.
		Ultra = 0x00000002
	};

	/// TextureBlendType specifies which type of blend function to use to blend textures. The blend type function will be used while casting channels during material casting.
	enum class ETextureBlendType
	{
		/// 
		Replace = 0x00000000,

		/// 
		Add = 0x00000001,

		/// 
		Subtract = 0x00000002,

		/// 
		Multiply = 0x00000003,

		/// 
		Alpha = 0x00000004,

		/// 
		PreMultipliedAlpha = 0x00000005,

		/// 
		Over = 0x00000006,

		/// 
		In = 0x00000007,

		/// 
		Out = 0x00000008,

		/// 
		AddWAlpha = 0x00000009,

		/// 
		SubtractWAlpha = 0x0000000A,

		/// 
		MultiplyWAlpha = 0x0000000B
	};

	/// TextureWrapMode specifies which wrap mode will be used for the texture sampling in a specific texture node when casting.
	enum class ETextureWrapMode
	{
		/// 
		Wrap = 0x00000000,

		/// 
		Clamp = 0x00000001,

		/// 
		Mirror = 0x00000002
	};

	/// MaterialBlendMode specifies which type of blend function to use to blend materials. The blend mode function will be used while blending layers during material casting.
	enum class EMaterialBlendMode
	{
		/// Treat the material as fully opaque. Any opacity channel will be ignored.
		Opaque = 0x00000000,

		/// Use the opacity channel as a mask. Opacity values equal or greater than the opacity cutoff will yield opaque pixels, and opactity values less than the opacity cutoff will yield fully transparent pixels.
		Mask = 0x00000001,

		/// Opacity values will be used to perform an alpha blend, final_color = (source_color * alpha) + (destination_color * (1 - alpha)).
		Blend = 0x00000002
	};

	/// EImageInputFormat specifies input image file formats
	enum class EImageInputFormat
	{
		/// and unknown or unsupported file format
		Unsupported = -1,

		/// 
		BMP = 0,

		/// 
		DDS = 1,

		/// 
		GIF = 2,

		/// 
		JPEG = 3,

		/// 
		PNG = 4,

		/// 
		TGA = 5,

		/// 
		TIFF = 6,

		/// 
		PSD = 7
	};

	/// EImageOutputFormat specifies output image file formats
	enum class EImageOutputFormat
	{
		/// 
		BMP = 0,

		/// 
		DDS = 1,

		/// 
		JPEG = 2,

		/// 
		PNG = 3,

		/// 
		TGA = 4,

		/// 
		TIFF = 5
	};

	/// DDSCompressionType specifies compression types for DDS image files
	enum class EDDSCompressionType
	{
		/// 
		NoCompression = -1,

		/// 
		BC1 = 0,

		/// 
		BC2 = 1,

		/// 
		BC3 = 2,

		/// 
		BC4 = 3,

		/// 
		BC5 = 4
	};

	/// TexcoordGeneratorType specifies which method generates the texture coords
	enum class ETexcoordGeneratorType
	{
		/// Texture coordinates are generated from scratch based on the geometry.
		Parameterizer = 0x00000000,

		/// Texture coordinates are generated based on the original texture coordinates.
		ChartAggregator = 0x00000001
	};

	/// ChartAggregatorMode specifies in which manner the output UV chart size will depend on the input.
	enum class EChartAggregatorMode
	{
		/// Aggregated UV charts will be scaled to keep their relative pixel density relative to all other UV charts. The user can still set the size of the output texture maps.
		TextureSizeProportions = 0x00000000,

		/// Aggregated UV charts will have their size set based on its actual geometrical size.
		SurfaceArea = 0x00000001,

		/// The combined atlas will be resized to fit each chart so that all charts retain the same amount of pixels as they originally had. This will override any manually set texture size.
		OriginalPixelDensity = 0x00000002,

		/// Aggregated UV charts will have their size set based on its original UV size, disregarding the size of the texture they are used in.
		UVSizeProportions = 0x00000003
	};

	/// If multiple UV charts overlap and have the same material, SurfaceAreaScale specifies which of those instances determines the the output scale. It is only valid when the ChartAggregatorMode is SurfaceArea and SeparateOverlappingCharts is false.
	enum class ESurfaceAreaScale
	{
		/// If multiple UV charts overlap and have the same material, the largest instance determines the output scale. It is only valid when the ChartAggregatorMode is SurfaceArea and SeparateOverlappingCharts is false.
		LargestInstance = 0x00000000,

		/// If multiple UV charts overlap and have the same material, the smallest instance determines the output scale. It is only valid when the ChartAggregatorMode is SurfaceArea and SeparateOverlappingCharts is false.
		SmallestInstance = 0x00000001,

		/// If multiple UV charts overlap and have the same material, the average of all the instances determine the output scale. It is only valid when the ChartAggregatorMode is SurfaceArea and SeparateOverlappingCharts is false.
		Average = 0x00000002
	};

	/// FlipFacesAndNormals specifies how faces and normals should be flipped.
	enum class EFlipFacesAndNormals
	{
		/// Don't flip.
		NoFlip = 0x00000000,

		/// Automatically detect and fix backfaces per part.
		Automatic = 0x00000001,

		/// Append inverted winded triangles with inverted normals to the geometry.
		MakeDoubleSided = 0x00000002,

		/// Invert the winding of the triangles.
		InvertFaces = 0x00000003,

		/// Invert the vertex normals.
		InvertNormals = 0x00000004,

		/// Invert winding of all triangles and vertex normals.
		InvertFacesAndNormals = 0x00000005
	};

	/// CameraType specifies the camera used when rendering/computing visibility.
	enum class ECameraType
	{
		/// Perspective cameras have a field of view.
		Perspective = 0x00000000,

		/// Orthographic cameras have a size.
		Orthographic = 0x00000001,

		/// Omnidirectional cameras view all directions.
		Omnidirectional = 0x00000002
	};

	/// ComputeVisibilityMode specifies which type of renderer to use when computing visibility.
	enum class EComputeVisibilityMode
	{
		/// Use DirectX when computing visibility.
		DirectX = 0x00000000,

		/// Use a software renderer when computing visibility.
		Software = 0x00000001
	};

	/// MaterialType specifies the type of material. Certain materials might use specialized shaders.
	enum class EMaterialType
	{
		/// Use the standard shader.
		Standard = 0x00000000,

		/// Use the flipbook shader.
		Flipbook = 0x00000001,

		/// Use the billboard cloud shader.
		BillboardCloud = 0x00000002
	};

	/// SettingValueType is used to denot which data type a setting expects.
	enum class ESettingValueType
	{
		/// Invalid settings value type.
		Invalid = 0x00000000,

		/// Bool settings type.
		Bool = 0x00000001,

		/// Int settings type.
		Int = 0x00000002,

		/// Unsigned int settings type.
		Uint = 0x00000003,

		/// Double floating point settings type.
		Double = 0x00000004,

		/// String settings type.
		String = 0x00000005,

		/// EPipelineRunMode settings type.
		EPipelineRunMode = 0x00000006,

		/// EChartAggregatorMode settings type.
		EChartAggregatorMode = 0x00000008,

		/// ETexcoordGeneratorType settings type.
		ETexcoordGeneratorType = 0x00000009,

		/// EOcclusionMode settings type.
		EOcclusionMode = 0x0000000A,

		/// EStopCondition settings type.
		EStopCondition = 0x0000000B,

		/// EDataCreationPreferences settings type.
		EDataCreationPreferences = 0x0000000C,

		/// EReductionHeuristics settings type.
		EReductionHeuristics = 0x0000000D,

		/// EWeightsFromColorMode settings type.
		EWeightsFromColorMode = 0x0000000E,

		/// ESurfaceTransferMode settings type.
		ESurfaceTransferMode = 0x0000000F,

		/// ERemeshingMode settings type.
		ERemeshingMode = 0x00000010,

		/// ETangentSpaceMethod settings type.
		ETangentSpaceMethod = 0x00000011,

		/// EGeometryDataFieldType settings type.
		EGeometryDataFieldType = 0x00000012,

		/// EAtlasFillMode settings type.
		EAtlasFillMode = 0x00000013,

		/// EDitherPatterns settings type.
		EDitherPatterns = 0x00000014,

		/// EComputeVisibilityMode settings type.
		EComputeVisibilityMode = 0x00000015,

		/// ESurfaceAreaScale settings type.
		ESurfaceAreaScale = 0x00000016,

		/// EImpostorType settings type.
		EImpostorType = 0x00000017,

		/// ESymmetryAxis settings type.
		ESymmetryAxis = 0x00000018,

		/// EPixelFormat settings type.
		EPixelFormat = 0x00000019,

		/// EColorComponent settings type.
		EColorComponent = 0x0000001A,

		/// EHoleFilling settings type.
		EHoleFilling = 0x0000001B,

		/// EImageInputFormat settings type.
		EImageInputFormat = 0x0000001C,

		/// EImageOutputFormat settings type.
		EImageOutputFormat = 0x0000001D,

		/// EDDSCompressionType settings type.
		EDDSCompressionType = 0x0000001E,

		/// EBillboardMode settings type.
		EBillboardMode = 0x0000001F,

		/// EOpacityType settings type.
		EOpacityType = 0x00000020
	};

	/// Run modes for pipelines
	enum class EPipelineRunMode
	{
		/// Run the pipeline in this process
		RunInThisProcess = 0,

		/// Run the pipeline in a new process using the batch executor tool
		RunInNewProcess = 1,

		/// Run the pipeline distributed using SimplygonGrid
		RunDistributedUsingSimplygonGrid = 2,

		/// Run the pipeline distributed using IncrediBuild
		RunDistributedUsingIncredibuild = 3,

		/// Run the pipeline distributed using Fastbuild
		RunDistributedUsingFastbuild = 4
	};

	/// Defines the field types in GeometryData, and in the GeometryDataCaster for casting fields into textures.
	enum class EGeometryDataFieldType
	{
		/// Per-vertex coordinate data, xyz values (3 items per tuple)
		Coords = 0,

		/// Per-corner texture coords data, uv values (2 items per tuple)
		TexCoords = 1,

		/// Per-corner vertex normals data, xyz values (3 items per tuple)
		Normals = 2,

		/// Per-corner vertex tangent data, xyz values (3 items per tuple)
		Tangents = 3,

		/// Per-corner vertex bitangent data, xyz values (3 items per tuple)
		Bitangents = 4,

		/// Per-corner vertex color data, rgba values (4 items per tuple)
		Colors = 5,

		/// Per-triangle triangle ids, id values, not interpolated. (1 item per tuple)
		TriangleIds = 6,

		/// Per-triangle material ids, id values, not interpolated. (1 item per tuple)
		MaterialIds = 7
	};

	/// WeightsFromColorMode defines how to map vertex colors to vertex weights
	enum class EWeightsFromColorMode
	{
		/// Maps color intensity [0-1] to vertex weight [1/Multiplier - Multiplier]
		Standard = 0,

		/// Maps color intensity [0-1] to vertex weight [1 - Multiplier]
		High = 1,

		/// Maps color intensity [0-1] to vertex weight [1/Multiplier - 1]
		Low = 2
	};

	/// RemeshingMode defines if the remeshing processor remeshes the outside or the inside of the input geometry. MergeDistance / MergeBoldness only works with the ERemeshingMode::Outside.
	enum class ERemeshingMode
	{
		/// Automatically remeshes the outside of the geometry.
		Outside = 0,

		/// Automatically remeshes the largest inside space of the geometry
		Inside = 1,

		/// User defines a position in space that will be considered as outside for the purposes of the remeshing. These position values can be set via global settings (RemeshingModeManualPositionX/Y/Z). If global settings are not set, this will fallback to ERemeshingMode::Outside.
		Manual = 2
	};

	/// HoleFilling defines how aggresively the remesher will fill holes and cavities.
	enum class EHoleFilling
	{
		/// No hole filling.
		Disabled = 0,

		/// Minor hole filling.
		Low = 1,

		/// Moderate ammounts of hole filling.
		Medium = 2,

		/// Aggresive hole filling.
		High = 3
	};

	/// ImpostorType specifies which type of impostor should be generated by the ImpostorProcessor.
	enum class EImpostorType
	{
		/// Generates a set of billboards that represents the scene.
		BillboardCloud = 0x00000000,

		/// Renders the scene from a number of views and generates an atlas with the images.
		Flipbook = 0x00000001,

		/// Generates an impostor from a single view.
		FromSingleView = 0x00000003
	};

	/// SymmetryAxis specifies axis used for symmetry calculations in the ReductionProcessor.
	enum class ESymmetryAxis
	{
		/// X axis.
		X = 0x00000000,

		/// Z axis.
		Y = 0x00000001,

		/// Z axis.
		Z = 0x00000002
	};

	/// Pixel format used for material casting.
	enum class EPixelFormat
	{
		/// RGBA color channels with 8 bit depth per color channel
		R8G8B8A8 = 0x00000000,

		/// RGB color channels with 8 bit depth per color channel
		R8G8B8 = 0x00000001,

		/// R color channel with 8 bit depth per color channel
		R8 = 0x00000002,

		/// RGBA color channels with 16 bit depth per color channel
		R16G16B16A16 = 0x00000003,

		/// RGB color channels with 16 bit depth per color channel
		R16G16B16 = 0x00000004,

		/// R color channel with 16 bit depth per color channel
		R16 = 0x00000005
	};

	/// Color component.
	enum class EColorComponent
	{
		/// Red color component
		Red = 0x00000000,

		/// Green color component
		Green = 0x00000001,

		/// Blue color component
		Blue = 0x00000002,

		/// Alpha color component
		Alpha = 0x00000003
	};

	/// Shader language used in shading network generation.
	enum class EShaderLanguage
	{
		/// HLSL 4.0
		HLSL_4_0 = 0,

		/// GLSL 4.0
		GLSL_4_0 = 1
	};

	/// 
	enum class EBillboardMode
	{
		/// Prioritize fitting the impostors to the exterior hull of the scene. Better for solid/opaque meshes like buildings/vehicles.
		OuterShell = 0x00000000,

		/// The impostors fit to the entire volume of the scene. Better for chaotic meshes that has lots of geometry within its volume, like vegetation.
		Foliage = 0x00000001
	};

	/// 
	enum class EOpacityType
	{
		/// The level of transparency is defined from 0.0->1.0, where 0.0 is fully transparent and 1.0 is fully opaque.
		Opacity = 0,

		/// The level of transparency is defined from 1.0->0.0, where 1.0 is fully transparent and 0.0 is fully opaque.
		Transparency = 1
	};

	/// The SG_MATERIAL_CHANNEL_[...] defines the default names of standard material textures in Simplygon.
	static const char * SG_MATERIAL_CHANNEL_AMBIENT = "Ambient";

	/// The SG_MATERIAL_CHANNEL_[...] defines the default names of standard material textures in Simplygon.
	static const char * SG_MATERIAL_CHANNEL_DIFFUSE = "Diffuse";

	/// The SG_MATERIAL_CHANNEL_[...] defines the default names of standard material textures in Simplygon.
	static const char * SG_MATERIAL_CHANNEL_SPECULAR = "Specular";

	/// The SG_MATERIAL_CHANNEL_[...] defines the default names of standard material textures in Simplygon.
	static const char * SG_MATERIAL_CHANNEL_SHININESS = "Shininess";

	/// The SG_MATERIAL_CHANNEL_[...] defines the default names of standard material textures in Simplygon.
	static const char * SG_MATERIAL_CHANNEL_OPACITY = "Opacity";

	/// The SG_MATERIAL_CHANNEL_[...] defines the default names of standard material textures in Simplygon.
	static const char * SG_MATERIAL_CHANNEL_EMISSIVE = "Emissive";

	/// The SG_MATERIAL_CHANNEL_[...] defines the default names of standard material textures in Simplygon.
	static const char * SG_MATERIAL_CHANNEL_NORMALS = "Normals";

	/// The SG_MATERIAL_CHANNEL_[...] defines the default names of standard material textures in Simplygon.
	static const char * SG_MATERIAL_CHANNEL_GROUPIDS = "GroupIds";

	/// The SG_MATERIAL_CHANNEL_[...] defines the default names of standard material textures in Simplygon.
	static const char * SG_MATERIAL_CHANNEL_DISPLACEMENT = "Displacement";

	/// The SG_MATERIAL_CHANNEL_[...] defines the default names of standard material textures in Simplygon.
	static const char * SG_MATERIAL_CHANNEL_BASECOLOR = "Basecolor";

	/// The SG_MATERIAL_CHANNEL_[...] defines the default names of standard material textures in Simplygon.
	static const char * SG_MATERIAL_CHANNEL_ROUGHNESS = "Roughness";

	/// The SG_MATERIAL_CHANNEL_[...] defines the default names of standard material textures in Simplygon.
	static const char * SG_MATERIAL_CHANNEL_METALNESS = "Metalness";

	/// The SG_MATERIAL_CHANNEL_[...] defines the default names of standard material textures in Simplygon.
	static const char * SG_MATERIAL_CHANNEL_OCCLUSION = "Occlusion";

	/// The SG_IMAGEDATA_FORMAT_[...] defines the default names of standard image formats in Simplygon. L is a grayscale light
	static const char * SG_IMAGEDATA_FORMAT_L = "L";

	/// The SG_IMAGEDATA_FORMAT_[...] defines the default names of standard image formats in Simplygon. RGB is 3-component red, green, blue
	static const char * SG_IMAGEDATA_FORMAT_RGB = "RGB";

	/// The SG_IMAGEDATA_FORMAT_[...] defines the default names of standard image formats in Simplygon. RGBA is 4-component red, green, blue, alpha
	static const char * SG_IMAGEDATA_FORMAT_RGBA = "RGBA";

	/// The maximum number of texture channels supported within Simplygon.
	static const unsigned int SG_NUM_SUPPORTED_TEXTURE_CHANNELS = 256;

	/// The maximum number of color channels supported within Simplygon.
	static const unsigned int SG_NUM_SUPPORTED_COLOR_CHANNELS = 256;

	/// The maximum number of bones that can be references by one vertex within Simplygon.
	static const unsigned int SG_NUM_SUPPORTED_BONES_PER_VERTEX = 16;

	/// The maximum number of mapping layers that are supported internally by Simplygon
	static const unsigned int SG_NUM_SUPPORTED_MAPPING_LAYERS = 32;

	/// The maximum number of inputs that can be connected to any custom node within Simplygon
	static const unsigned int SG_NUM_SUPPORTED_CUSTOM_NODE_INPUTS = 16;

	/// The maximum size of shader output that can be generated by a custom node within Simplygon
	static const unsigned int SG_SUPPORTED_CUSTOM_NODE_SHADER_CODE_SIZE = 2048;

	/// The maximum value allowed for any of the reduction importance multipliers/values
	static const float SG_MAXIMUM_IMPORTANCE_VALUE = (float)10;

	/// The maximum number of input materials that the mapping image caster supports
	static const unsigned int SG_MAXIMUM_MAPPING_IMAGE_INPUT_MATERIAL_COUNT = 1024;

	/// The maximum number of output materials that the mapping image caster supports
	static const unsigned int SG_MAXIMUM_MAPPING_IMAGE_OUTPUT_MATERIAL_COUNT = 1024;

	/// The maximum number of output materials that the parameterizer supports
	static const unsigned int SG_MAXIMUM_PARAMETERIZER_OUTPUT_MATERIAL_COUNT = 1024;

	/// The maximum number of output materials that the chart aggregator supports
	static const unsigned int SG_MAXIMUM_CHART_AGGREGATOR_OUTPUT_MATERIAL_COUNT = 1024;


    class IObject; // forward declaration of the interface

	/** 
	 * rhandle are used to represent opaque handles returned from and used by the API
	 */
	typedef void* rhandle;

	/** 
	 * rid represents ids within the API
	 */
	typedef int rid;

	/**
	 * real represents generic floating point values, depending on API floating point
	 * precision version, reals are either typedef:ed as floats or doubles
	 */
	typedef float real;

	const real REAL_MIN = 1.175494351e-38F;
	const real REAL_MAX = 3.402823466e+38F;

	/**
	 * The IReturnData class is used to represent data that is created by the API objects, and returned to the caller.
	 * The data arrays are created in the same address space as the caller application, and the data can be accessed directly.
	 * IReturnData is never used directly, but instead through one of the accessor templates.
	 */
	class IReturnData
	{
		public:
		virtual void AddRef() = 0;
		virtual void Release() = 0;
		virtual unsigned int _GetByteSize() const = 0;
		virtual const void *_GetRawPointer() const = 0;
	};

	/**
	 * The rdata class is used to retrieve array data from the interface. Use this rather than the
	 * IData object, as this will manage reference counting automatically.
	 */
	template<class value_type> class rdata 
	{
		public:
		/**
		 * Constructs a rdata from an IReturnData interface pointer. 
		 * @param p is a pointer to an API object, or null to make the rdata object point at nothing.
		 */
		rdata( IReturnData *p=nullptr ) : ptr(p) { addref_ptr(); }

		/**
		 * Points an rdata at content of another rdata. Adds reference count ot the IData object
		 * @param p is a CountedPointer that points at an API object.
		 */
		rdata( const rdata<value_type> &p ) : ptr(p.ptr) { addref_ptr(); }

		/**
		 * Destructs the rdata, and releases one reference to the IData object, if the rdata currently points at an object.
		 */
		virtual ~rdata() { release_ptr(); }

		/** 
		 * Tells whether the rdata points at an object, or nothing.
		 * @return true if the pointer points at nothing, or the object has no data
		 */
		bool IsNullOrEmpty() const
		{
			if( ptr == nullptr )
				return true;
			if( ptr->_GetByteSize() == 0)
				return true;
			return false;
		}

		/** 
		 * Tells whether the rdata points at an object, or nothing.
		 * @return true if the pointer points at someting, which also contains data
		 */
		bool NonEmpty() const { return !this->IsNullOrEmpty(); }

		/** 
		 * Operator that sets the rdata to point at the same rdata as the source rdata
		 */
		rdata<value_type>& operator=( const rdata<value_type> &p ) 
		{
			this->replace_ptr( p.ptr );
			return *this;
		}

		/** 
		 * Method to retrieve the const data pointer. 
		 * @return the pointer to the IReturnData object, or null if the rdata object does not point at an object.
		 */
		const value_type *Data() const
		{
			if( this->ptr == nullptr )
				return nullptr;
			return static_cast<const value_type *>(this->ptr->_GetRawPointer());
		}

		/** 
		 * Operator to retrieve a data item using an index 
		 */
		value_type operator[]( unsigned int index ) const
		{
			return (static_cast<const value_type *>(this->ptr->_GetRawPointer()))[index];
		}

		/** 
		 * Method to retrieve a data item using an index 
		 */
		value_type GetItem( unsigned int index ) const
		{
			return (static_cast<const value_type *>(this->ptr->_GetRawPointer()))[index];
		}

		/** 
		 * Operator to retrieve the data.
		 */
		operator const value_type *() const	{ return this->Data(); }

		/** 
		 * Method to retrieve the data size.
		 */
		unsigned int GetItemCount() const
		{
			if( this->IsNullOrEmpty() )
				return 0;
			return ((unsigned int) (this->ptr->_GetByteSize()) / sizeof(value_type));
		}

        protected:
		void addref_ptr() { if( this->ptr!=nullptr ) { this->ptr->AddRef(); } }
		void release_ptr() { if( this->ptr!=nullptr ) { this->ptr->Release(); this->ptr = nullptr; } }
		void replace_ptr( IReturnData *p ) { if( this->ptr != p ) { release_ptr(); this->ptr = p; addref_ptr(); } }    

		IReturnData *ptr;	
	};

	/** spBoolData is the IReturnData accessor for bool data */
	typedef rdata<bool> spBoolData;

	/** spCharData is the IReturnData accessor for char data */
	typedef rdata<char> spCharData;

	/** spUnsignedCharData is the IReturnData accessor for unsigned char data */
	typedef rdata<unsigned char> spUnsignedCharData;

	/** spShortData is the IReturnData accessor for short data */
	typedef rdata<short> spShortData;

	/** spUnsignedShortData is the IReturnData accessor for unsigned short data */
	typedef rdata<unsigned short> spUnsignedShortData;

	/** spIntData is the IReturnData accessor for int data */
	typedef rdata<int> spIntData;

	/** spUnsignedIntData is the IReturnData accessor for unsigned int data */
	typedef rdata<unsigned int> spUnsignedIntData;

	/** spLongData is the IReturnData accessor for long data */
	typedef rdata<long> spLongData;

	/** spUnsignedLongData is the IReturnData accessor for unsigned long data */
	typedef rdata<unsigned long> spUnsignedLongData;

	/** spFloatData is the IReturnData accessor for float data */
	typedef rdata<float> spFloatData;

	/** spDoubleData is the IReturnData accessor for double data */
	typedef rdata<double> spDoubleData;

	/** spRealData is the IReturnData accessor for real data */
	typedef rdata<real> spRealData;

	/** spRidData is the IReturnData accessor for rid data */
	typedef rdata<rid> spRidData;

	/** spRhandleData is the IReturnData accessor for rhandle data */
	typedef rdata<rhandle> spRhandleData;


	/** 
	 * spObject is the accessor for the IObject interface.
	 */
	class spObject
	{
		public:
		spObject( IObject *p );
		spObject( const spObject& p );
		virtual ~spObject();
		spObject& operator=( const spObject &p );
		static spObject SafeCast( spObject other );
		IObject* operator->() const;
		bool IsNull() const;
		bool NonNull() const;
		bool IsSameObjectAs( const spObject &p );
		bool operator==( const spObject &p );
		IObject* GetInterface() const;
		operator void *() const;

		protected:
		void addref_ptr();
		void release_ptr();
		void replace_ptr( IObject *p );

		IObject *ptr;
	};

	/** spString is the IReturnData accessor for strings */
    class spString 
	{
		public:
		/**
		 * Constructs a string from an IReturnData interface pointer. 
		 * @param p is a pointer to an IReturnData object, or null to make the string object point at nothing.
		 */
		spString( IReturnData *p=nullptr ) : ptr(p) { addref_ptr(); }

		/**
		 * Points a string at content of another string. Adds reference count ot the IReturnData object
		 * @param p is a string that points at an IReturnData object.
		 */
		spString( const spString &p ) : ptr(p.ptr) { addref_ptr(); }

		/**
		 * Destructs the spString, and releases one reference to the IReturnData object, if the string currently points at an object.
		 */
		virtual ~spString() { release_ptr(); }

		/** 
		 * Tells whether the string points at an object, or nothing, or points at a text which is zero lenght (empty)
		 * @return true if the pointer points at nothing, or the object is zero lenght
		 */
		bool IsNullOrEmpty() const
		{
			if( ptr == nullptr )
				return true;
			if( ptr->_GetByteSize() == 0)
				return true;
			return false;
		}

		/** 
		 * Tells whether the rdata points at an object, or nothing.
		 * @return true if the pointer points at someting, which also is not zero lenght
		 */
		bool NonEmpty() const { return !this->IsNullOrEmpty(); }
				
		/** 
		 * Operator that sets the string to point at the same string as the other string
		 */
		spString& operator=( const spString &p ) 
		{
			this->replace_ptr( p.ptr );
			return *this;
		}

		/** 
		 * Method to retrieve the const data pointer. 
		 * @return the pointer to the IReturnData object, or null if the string does not point at an object.
		 */
		const char *Data() const
		{
			if( this->ptr == nullptr )
				return nullptr;
			return static_cast<const char *>(this->ptr->_GetRawPointer());
		}

		/** 
		 * Operator to retrieve a data item using an index 
		 */
		char operator[]( unsigned int index ) const
		{
			return (static_cast<const char *>(this->ptr->_GetRawPointer()))[index];
		}

		/** 
		 * Operator to retrieve the data.
		 */
		operator const char *() const { return this->Data(); }

		/** 
		 * Method to retrieve the null-terminated string (this is an alias for Data()) 
		 */
		const char *c_str() const { return this->Data(); }

		/** 
		 * Method to retrieve the data size. This is the whole allocated size of the string, including trailing null character.
		 */
		unsigned int GetItemCount() const
		{
			if( this->ptr == nullptr )
				return 0;
			return ((unsigned int) (this->ptr->_GetByteSize()) / sizeof(char));
		}

        protected:
		void addref_ptr() { if( this->ptr!=nullptr ) { this->ptr->AddRef(); } }
		void release_ptr() { if( this->ptr!=nullptr ) { this->ptr->Release(); this->ptr = nullptr; } }
		void replace_ptr( IReturnData *p ) { if( this->ptr != p ) { release_ptr(); this->ptr = p; addref_ptr(); } }

		IReturnData *ptr;	
	};

	/** 
	 * Shading color class.
	 */
	class ShadingColor
	{
		public:

		ShadingColor( )
		{
			r = 0.0f;
			g = 0.0f;
			b = 0.0f;
			a = 0.0f;
		}

		ShadingColor( real _r, real _g, real _b, real _a )
		{
			r = _r;
			g = _g;
			b = _b;
			a = _a;
		}

		real r;
		real g;
		real b;
		real a;
	};

	/** 
	 * The Observer class is used to receive events from an interface, by override the event methods
	 * By adding an object of the class into an interface using the AddObserver method
	 * the event method will called
	 */
	class Observer
	{
		public:
		virtual ~Observer() {}

		/** 
		 * The OnProgress event is for processing progress and cancelation signaling.
		 * @param subject is the object that is sending the event
		 * @param progressPercent is progress in percent
		 * @return false to cancel the processing
		 */
		virtual bool OnProgress( spObject subject , real progressPercent ) { return true; }

		/** 
		 * The OnProcessStarted event is triggered when the processing starts.
		 * @param subject is the object that is sending the event
		 * @param name is name of the process
		 */
		virtual void OnProcessStarted( spObject subject , const char* name ) {}

		/** 
		 * The OnShadingCustomNodeEvaluate event is for evaluating custom shading nodes.
		 * @param subject is the object that is sending the event
		 * @return Color with the evaluated pixel value
		 */
		virtual ShadingColor OnShadingCustomNodeEvaluate( spObject subject ) { return ShadingColor(); }

		/** 
		 * The OnShadingCustomNodeGenerateShaderCode event is for generating shader code in the custom shading node.
		 * @param subject is the object that is sending the event
		 * @param target shader language
		 * @return true if the shader code was added to the ShadingCustomNode successfully
		 */
		virtual bool OnShadingCustomNodeGenerateShaderCode( spObject subject, EShaderLanguage shaderLanguage ) { return false; }
	};

	/**
	 * The ErrorHandler class is used to receive error messages from the interface, by creating a class that
	 * implements the HandleError method. By setting an object of the class into the main interface using 
	 * the SetErrorHandler method, the HandleError method will receive all error messages from the interface.
	 * Please note that errors may not be recoverable, and could leave objects in an intermediate state. Errors
	 * should in most cases be considered fatal, and will not occur in standard use. 
	 */
	class ErrorHandler
	{
		public:
		virtual ~ErrorHandler() {}
		/** 
		 * The HandleError method will receive all error messages from the interface.
		 * @param object is the interface object that raised the error message
		 * @param interfaceName is the name of the interface 
		 * @param methodName is the name of the method in the object that was called when the error occurred
		 * @param errorType is the type of error that has occurred
		 * @param errorText is a description of the error that has occurred
		 */
		virtual void HandleError( spObject object , const char *interfaceName , const char *methodName , rid errorType , const char *errorText ) = 0;
	};

	class IArray; // forward declaration of the interface

	/**
	 * spArray is the accessor for the IArray interface. Array is the base class for 
	 * the array objects. The object contains a dynamically allocated list of tuples 
	 * of the same length, which can be specified before the list is filled with values. 
	 */
	class spArray : public spObject
	{
		public:
		spArray(IArray* p = nullptr);
		spArray( const spArray &p );
		spArray & operator=( const spArray &p );
		static spArray SafeCast(spObject other);
		IArray* operator->() const;
	};

	class IValueArray; // forward declaration of the interface

	/**
	 * spValueArray is the accessor for the IValueArray interface. ValueArray adds 
	 * methods to arrays to generically add, set and get tuples, through real values. 
	 */
	class spValueArray : public spArray
	{
		public:
		spValueArray(IValueArray* p = nullptr);
		spValueArray( const spValueArray &p );
		spValueArray & operator=( const spValueArray &p );
		static spValueArray SafeCast(spObject other);
		IValueArray* operator->() const;
	};

	class IBoolArray; // forward declaration of the interface

	/**
	 * spBoolArray is the accessor for the IBoolArray interface. BoolArray is the bool 
	 * implementation of ValueArray. See ValueArray for a description. 
	 */
	class spBoolArray : public spValueArray
	{
		public:
		spBoolArray(IBoolArray* p = nullptr);
		spBoolArray( const spBoolArray &p );
		spBoolArray & operator=( const spBoolArray &p );
		static spBoolArray SafeCast(spObject other);
		IBoolArray* operator->() const;
	};

	class ICharArray; // forward declaration of the interface

	/**
	 * spCharArray is the accessor for the ICharArray interface. CharArray is the char 
	 * implementation of ValueArray. See ValueArray for a description. 
	 */
	class spCharArray : public spValueArray
	{
		public:
		spCharArray(ICharArray* p = nullptr);
		spCharArray( const spCharArray &p );
		spCharArray & operator=( const spCharArray &p );
		static spCharArray SafeCast(spObject other);
		ICharArray* operator->() const;
	};

	class IDoubleArray; // forward declaration of the interface

	/**
	 * spDoubleArray is the accessor for the IDoubleArray interface. DoubleArray is 
	 * the double implementation of ValueArray. See ValueArray for a description. 
	 */
	class spDoubleArray : public spValueArray
	{
		public:
		spDoubleArray(IDoubleArray* p = nullptr);
		spDoubleArray( const spDoubleArray &p );
		spDoubleArray & operator=( const spDoubleArray &p );
		static spDoubleArray SafeCast(spObject other);
		IDoubleArray* operator->() const;
	};

	class IFloatArray; // forward declaration of the interface

	/**
	 * spFloatArray is the accessor for the IFloatArray interface. FloatArray is the 
	 * float implementation of ValueArray. See ValueArray for a description. 
	 */
	class spFloatArray : public spValueArray
	{
		public:
		spFloatArray(IFloatArray* p = nullptr);
		spFloatArray( const spFloatArray &p );
		spFloatArray & operator=( const spFloatArray &p );
		static spFloatArray SafeCast(spObject other);
		IFloatArray* operator->() const;
	};

	class IIntArray; // forward declaration of the interface

	/**
	 * spIntArray is the accessor for the IIntArray interface. IntArray is the int 
	 * implementation of ValueArray. See ValueArray for a description. 
	 */
	class spIntArray : public spValueArray
	{
		public:
		spIntArray(IIntArray* p = nullptr);
		spIntArray( const spIntArray &p );
		spIntArray & operator=( const spIntArray &p );
		static spIntArray SafeCast(spObject other);
		IIntArray* operator->() const;
	};

	class ILongArray; // forward declaration of the interface

	/**
	 * spLongArray is the accessor for the ILongArray interface. LongArray is the long 
	 * implementation of ValueArray. See ValueArray for a description. 
	 */
	class spLongArray : public spValueArray
	{
		public:
		spLongArray(ILongArray* p = nullptr);
		spLongArray( const spLongArray &p );
		spLongArray & operator=( const spLongArray &p );
		static spLongArray SafeCast(spObject other);
		ILongArray* operator->() const;
	};

	class IRealArray; // forward declaration of the interface

	/**
	 * spRealArray is the accessor for the IRealArray interface. RealArray is the real 
	 * implementation of ValueArray. See ValueArray for a description. 
	 */
	class spRealArray : public spValueArray
	{
		public:
		spRealArray(IRealArray* p = nullptr);
		spRealArray( const spRealArray &p );
		spRealArray & operator=( const spRealArray &p );
		static spRealArray SafeCast(spObject other);
		IRealArray* operator->() const;
	};

	class IRidArray; // forward declaration of the interface

	/**
	 * spRidArray is the accessor for the IRidArray interface. RidArray is the rid 
	 * implementation of ValueArray. See ValueArray for a description. 
	 */
	class spRidArray : public spValueArray
	{
		public:
		spRidArray(IRidArray* p = nullptr);
		spRidArray( const spRidArray &p );
		spRidArray & operator=( const spRidArray &p );
		static spRidArray SafeCast(spObject other);
		IRidArray* operator->() const;
	};

	class IShortArray; // forward declaration of the interface

	/**
	 * spShortArray is the accessor for the IShortArray interface. ShortArray is the 
	 * short implementation of ValueArray. See ValueArray for a description. 
	 */
	class spShortArray : public spValueArray
	{
		public:
		spShortArray(IShortArray* p = nullptr);
		spShortArray( const spShortArray &p );
		spShortArray & operator=( const spShortArray &p );
		static spShortArray SafeCast(spObject other);
		IShortArray* operator->() const;
	};

	class IUnsignedCharArray; // forward declaration of the interface

	/**
	 * spUnsignedCharArray is the accessor for the IUnsignedCharArray interface. UnsignedCharArray 
	 * is the uchar implementation of ValueArray. See ValueArray for a description. 
	 */
	class spUnsignedCharArray : public spValueArray
	{
		public:
		spUnsignedCharArray(IUnsignedCharArray* p = nullptr);
		spUnsignedCharArray( const spUnsignedCharArray &p );
		spUnsignedCharArray & operator=( const spUnsignedCharArray &p );
		static spUnsignedCharArray SafeCast(spObject other);
		IUnsignedCharArray* operator->() const;
	};

	class IUnsignedIntArray; // forward declaration of the interface

	/**
	 * spUnsignedIntArray is the accessor for the IUnsignedIntArray interface. UnsignedIntArray 
	 * is the uint implementation of ValueArray. See ValueArray for a description. 
	 */
	class spUnsignedIntArray : public spValueArray
	{
		public:
		spUnsignedIntArray(IUnsignedIntArray* p = nullptr);
		spUnsignedIntArray( const spUnsignedIntArray &p );
		spUnsignedIntArray & operator=( const spUnsignedIntArray &p );
		static spUnsignedIntArray SafeCast(spObject other);
		IUnsignedIntArray* operator->() const;
	};

	class IUnsignedLongArray; // forward declaration of the interface

	/**
	 * spUnsignedLongArray is the accessor for the IUnsignedLongArray interface. UnsignedLongArray 
	 * is the ulong implementation of ValueArray. See ValueArray for a description. 
	 */
	class spUnsignedLongArray : public spValueArray
	{
		public:
		spUnsignedLongArray(IUnsignedLongArray* p = nullptr);
		spUnsignedLongArray( const spUnsignedLongArray &p );
		spUnsignedLongArray & operator=( const spUnsignedLongArray &p );
		static spUnsignedLongArray SafeCast(spObject other);
		IUnsignedLongArray* operator->() const;
	};

	class IUnsignedShortArray; // forward declaration of the interface

	/**
	 * spUnsignedShortArray is the accessor for the IUnsignedShortArray interface. 
	 * UnsignedShortArray is the ushort implementation of ValueArray. See ValueArray 
	 * for a description. 
	 */
	class spUnsignedShortArray : public spValueArray
	{
		public:
		spUnsignedShortArray(IUnsignedShortArray* p = nullptr);
		spUnsignedShortArray( const spUnsignedShortArray &p );
		spUnsignedShortArray & operator=( const spUnsignedShortArray &p );
		static spUnsignedShortArray SafeCast(spObject other);
		IUnsignedShortArray* operator->() const;
	};

	class IChunkedImageData; // forward declaration of the interface

	/**
	 * spChunkedImageData is the accessor for the IChunkedImageData interface. ChunkedImageData 
	 * holds chunks for ImageData objects. ImageData objects can be referenced, and 
	 * swapped in/out of memory, to secondary storage. This is useful for very large 
	 * images that cannot be stored in-memory. ImageData objects can be indexed in 
	 * 1-,2- or 3D, and each ImageData chunk is cloned from a source ImageData object, 
	 * at setup. Fields added to ImageData chunks after setup will only be added into 
	 * that chunk, and is not recommended. 
	 */
	class spChunkedImageData : public spObject
	{
		public:
		spChunkedImageData(IChunkedImageData* p = nullptr);
		spChunkedImageData( const spChunkedImageData &p );
		spChunkedImageData & operator=( const spChunkedImageData &p );
		static spChunkedImageData SafeCast(spObject other);
		IChunkedImageData* operator->() const;
	};

	class IDirectXRenderer; // forward declaration of the interface

	/**
	 * spDirectXRenderer is the accessor for the IDirectXRenderer interface. A Renderer 
	 * using DirectX 11 that can be used to preview a scene object containing geometry 
	 * data by rendering it from selected SceneCamera nodes within the given scene 
	 * and then storing the frames to disc. If using a Shading Node Network (having 
	 * an IShadingNode assigned to the IMaterial), then the material can be previewed 
	 * with the generated HLSL shader. 
	 */
	class spDirectXRenderer : public spObject
	{
		public:
		spDirectXRenderer(IDirectXRenderer* p = nullptr);
		spDirectXRenderer( const spDirectXRenderer &p );
		spDirectXRenderer & operator=( const spDirectXRenderer &p );
		static spDirectXRenderer SafeCast(spObject other);
		IDirectXRenderer* operator->() const;
	};

	class IFieldData; // forward declaration of the interface

	/**
	 * spFieldData is the accessor for the IFieldData interface. FieldData represents 
	 * multiple fields of data. Each field is implemented as an ValueArray object, 
	 * that has a unique name, and can have complex components (such as scalars, vectors, 
	 * quaternions, tensors or matrices). All fields are assumed to be of the same 
	 * length. IFieldData can be seen as an array with complex tuples, where the component 
	 * can be of different types. 
	 */
	class spFieldData : public spObject
	{
		public:
		spFieldData(IFieldData* p = nullptr);
		spFieldData( const spFieldData &p );
		spFieldData & operator=( const spFieldData &p );
		static spFieldData SafeCast(spObject other);
		IFieldData* operator->() const;
	};

	class IGeometryData; // forward declaration of the interface

	/**
	 * spGeometryData is the accessor for the IGeometryData interface. GeometryData 
	 * represents a geometric structure consisting of point data (Vertices) and topological 
	 * data (Triangles). GeometryData may represent a whole geometric object, but can 
	 * also be used by streaming data filters, and in this way, only represents a part 
	 * of the object. Different fields in the Vertices and Triangles fields data objects 
	 * will contain point data and topological data. The standard naming convention 
	 * used in the filters/renderers are as follows: (Case sensitive naming, other 
	 * fields may also be present) 'Coords' Positional coordinates of a vertex, expressed 
	 * with a 3-component real field (XYZ). 'TexCoords0' - 'TexCoords255' Texture coordinates 
	 * of a vertex, expressed with a 2 components real field. By convention, the existing 
	 * fields must be sequential, and must start with 'TexCoord0'. 'Normals' Normal 
	 * vector for the vertex, expressed with a 3-component real field, a normalized 
	 * (XYZ) vector. 'VertexIds' The id of the current vertex in the primitive. This 
	 * field is present even if the vertex data is directly specified in the primitive 
	 * data, to specify topology. The field is of type rid. 'MaterialIds' The material 
	 * of the primitive. The field is of type rid. The 'Coords' and 'VertexIds' fields 
	 * always exist in the object, but the other fields are optional. Also, there can 
	 * exist user fields. 
	 */
	class spGeometryData : public spObject
	{
		public:
		spGeometryData(IGeometryData* p = nullptr);
		spGeometryData( const spGeometryData &p );
		spGeometryData & operator=( const spGeometryData &p );
		static spGeometryData SafeCast(spObject other);
		IGeometryData* operator->() const;
	};

	class IPackedGeometryData; // forward declaration of the interface

	/**
	 * spPackedGeometryData is the accessor for the IPackedGeometryData interface. 
	 * PackedGeometryData keeps the same information as GeometryData, but with all 
	 * corner data fields moved into per-vertex fields. No per-corner fields exist, 
	 * apart from the VertexIds field. Please note that the number of vertices in an 
	 * PackedGeometryData is commonly higher than in an GeometryData, as vertices must 
	 * be split to accommodate for different corner data. 
	 */
	class spPackedGeometryData : public spObject
	{
		public:
		spPackedGeometryData(IPackedGeometryData* p = nullptr);
		spPackedGeometryData( const spPackedGeometryData &p );
		spPackedGeometryData & operator=( const spPackedGeometryData &p );
		static spPackedGeometryData SafeCast(spObject other);
		IPackedGeometryData* operator->() const;
	};

	class IImageData; // forward declaration of the interface

	/**
	 * spImageData is the accessor for the IImageData interface. ImageData holds unpacked 
	 * image data. The data is stored in an FieldData object as value fields. For simplicity 
	 * all images are implemented as 3D images, but has an extent of 1 in Z for 2D 
	 * images, and an extent of 1 in both Y and Z for 1D images. Cube maps are stored 
	 * as a 3D image with Z-depth of 6 (one for each side) 
	 */
	class spImageData : public spObject
	{
		public:
		spImageData(IImageData* p = nullptr);
		spImageData( const spImageData &p );
		spImageData & operator=( const spImageData &p );
		static spImageData SafeCast(spObject other);
		IImageData* operator->() const;
	};

	class ITable; // forward declaration of the interface

	/**
	 * spTable is the accessor for the ITable interface. Table is the base class for 
	 * tables objects, where items are added into an id-indexed array of objects. 
	 */
	class spTable : public spObject
	{
		public:
		spTable(ITable* p = nullptr);
		spTable( const spTable &p );
		spTable & operator=( const spTable &p );
		static spTable SafeCast(spObject other);
		ITable* operator->() const;
	};

	class IMaterial; // forward declaration of the interface

	/**
	 * spMaterial is the accessor for the IMaterial interface. Material object that 
	 * keeps material information used while rendering. 
	 */
	class spMaterial : public spObject
	{
		public:
		spMaterial(IMaterial* p = nullptr);
		spMaterial( const spMaterial &p );
		spMaterial & operator=( const spMaterial &p );
		static spMaterial SafeCast(spObject other);
		IMaterial* operator->() const;
	};

	class IMaterialTable; // forward declaration of the interface

	/**
	 * spMaterialTable is the accessor for the IMaterialTable interface. MaterialTable 
	 * keeps information on materials used while rendering. 
	 */
	class spMaterialTable : public spTable
	{
		public:
		spMaterialTable(IMaterialTable* p = nullptr);
		spMaterialTable( const spMaterialTable &p );
		spMaterialTable & operator=( const spMaterialTable &p );
		static spMaterialTable SafeCast(spObject other);
		IMaterialTable* operator->() const;
	};

	class IMatrix4x4; // forward declaration of the interface

	/**
	 * spMatrix4x4 is the accessor for the IMatrix4x4 interface. Matrix4x4 is used 
	 * to represent and manipulate 4x4 transformation matrices, which can be either 
	 * standard matrices, or homogeneous 4x4 matrices used to transform 3D homogeneous 
	 * coordinates [x y z w]. The transformations are defined in row-major order. 
	 */
	class spMatrix4x4 : public spObject
	{
		public:
		spMatrix4x4(IMatrix4x4* p = nullptr);
		spMatrix4x4( const spMatrix4x4 &p );
		spMatrix4x4 & operator=( const spMatrix4x4 &p );
		static spMatrix4x4 SafeCast(spObject other);
		IMatrix4x4* operator->() const;
	};

	class ITransform3; // forward declaration of the interface

	/**
	 * spTransform3 is the accessor for the ITransform3 interface. Transform3 handles 
	 * homogeneous 4x4 transforms, i.e. transformations which can be represented by 
	 * multiplying a 4x4 matrix with a homogeneous 3D coordinate. Transform3 can either 
	 * pre-multiply a matrix onto the transformation, which will add a transform around 
	 * the current transform, or it can post-multiply the matrix, which will add a 
	 * transform inside the current transform. Post-multiply is the default mode. 
	 */
	class spTransform3 : public spObject
	{
		public:
		spTransform3(ITransform3* p = nullptr);
		spTransform3( const spTransform3 &p );
		spTransform3 & operator=( const spTransform3 &p );
		static spTransform3 SafeCast(spObject other);
		ITransform3* operator->() const;
	};

	class IMappingImage; // forward declaration of the interface

	/**
	 * spMappingImage is the accessor for the IMappingImage interface. MappingImage 
	 * stores the mapping between a processed geometry and the source geometry it is 
	 * based on. The mapping image object also stores multisampling settings. It can 
	 * be used to cast information from the original geometry to the processed geometry, 
	 * such as surface transfer or calculating normal maps. See IMaterialCaster and 
	 * subclasses for casting uses. 
	 */
	class spMappingImage : public spObject
	{
		public:
		spMappingImage(IMappingImage* p = nullptr);
		spMappingImage( const spMappingImage &p );
		spMappingImage & operator=( const spMappingImage &p );
		static spMappingImage SafeCast(spObject other);
		IMappingImage* operator->() const;
	};

	class IProcessingObject; // forward declaration of the interface

	/**
	 * spProcessingObject is the accessor for the IProcessingObject interface. ProcessingObject 
	 * is the abstract base class for all processing objects in Simplygon. Processing 
	 * objects take parameters, exports the RunProcessing to run the main processing 
	 * and Clear to clear the internal states of the processing object. All processing 
	 * objects also export information on how far the process has moved and the possibility 
	 * to cancel long running processings. 
	 */
	class spProcessingObject : public spObject
	{
		public:
		spProcessingObject(IProcessingObject* p = nullptr);
		spProcessingObject( const spProcessingObject &p );
		spProcessingObject & operator=( const spProcessingObject &p );
		static spProcessingObject SafeCast(spObject other);
		IProcessingObject* operator->() const;
	};

	class IParameterizer; // forward declaration of the interface

	/**
	 * spParameterizer is the accessor for the IParameterizer interface. Computes texture 
	 * coordinates for arbitrary geometry. 
	 */
	class spParameterizer : public spObject
	{
		public:
		spParameterizer(IParameterizer* p = nullptr);
		spParameterizer( const spParameterizer &p );
		spParameterizer & operator=( const spParameterizer &p );
		static spParameterizer SafeCast(spObject other);
		IParameterizer* operator->() const;
	};

	class IObjectCollection; // forward declaration of the interface

	/**
	 * spObjectCollection is the accessor for the IObjectCollection interface. ObjectCollection 
	 * and its specializations handles a collection of Objects. There are methods for 
	 * adding, removing and iterating through the objects. 
	 */
	class spObjectCollection : public spObject
	{
		public:
		spObjectCollection(IObjectCollection* p = nullptr);
		spObjectCollection( const spObjectCollection &p );
		spObjectCollection & operator=( const spObjectCollection &p );
		static spObjectCollection SafeCast(spObject other);
		IObjectCollection* operator->() const;
	};

	class IGeometryDataCollection; // forward declaration of the interface

	/**
	 * spGeometryDataCollection is the accessor for the IGeometryDataCollection interface. 
	 * GeometryDataCollection holds a number of GeometryData objects. The objects can 
	 * be looked up by their names (if they have been named with a call to SetName). 
	 */
	class spGeometryDataCollection : public spObjectCollection
	{
		public:
		spGeometryDataCollection(IGeometryDataCollection* p = nullptr);
		spGeometryDataCollection( const spGeometryDataCollection &p );
		spGeometryDataCollection & operator=( const spGeometryDataCollection &p );
		static spGeometryDataCollection SafeCast(spObject other);
		IGeometryDataCollection* operator->() const;
	};

	class IGraphicsImporter; // forward declaration of the interface

	/**
	 * spGraphicsImporter is the accessor for the IGraphicsImporter interface. Base 
	 * class for graphics import classes 
	 */
	class spGraphicsImporter : public spObject
	{
		public:
		spGraphicsImporter(IGraphicsImporter* p = nullptr);
		spGraphicsImporter( const spGraphicsImporter &p );
		spGraphicsImporter & operator=( const spGraphicsImporter &p );
		static spGraphicsImporter SafeCast(spObject other);
		IGraphicsImporter* operator->() const;
	};

	class IWavefrontImporter; // forward declaration of the interface

	/**
	 * spWavefrontImporter is the accessor for the IWavefrontImporter interface. OBJ 
	 * scene importer 
	 */
	class spWavefrontImporter : public spGraphicsImporter
	{
		public:
		spWavefrontImporter(IWavefrontImporter* p = nullptr);
		spWavefrontImporter( const spWavefrontImporter &p );
		spWavefrontImporter & operator=( const spWavefrontImporter &p );
		static spWavefrontImporter SafeCast(spObject other);
		IWavefrontImporter* operator->() const;
	};

	class IGLTFImporter; // forward declaration of the interface

	/**
	 * spGLTFImporter is the accessor for the IGLTFImporter interface. glTF scene importer 
	 */
	class spGLTFImporter : public spGraphicsImporter
	{
		public:
		spGLTFImporter(IGLTFImporter* p = nullptr);
		spGLTFImporter( const spGLTFImporter &p );
		spGLTFImporter & operator=( const spGLTFImporter &p );
		static spGLTFImporter SafeCast(spObject other);
		IGLTFImporter* operator->() const;
	};

	class IFBXImporter; // forward declaration of the interface

	/**
	 * spFBXImporter is the accessor for the IFBXImporter interface. FBX scene importer 
	 */
	class spFBXImporter : public spGraphicsImporter
	{
		public:
		spFBXImporter(IFBXImporter* p = nullptr);
		spFBXImporter( const spFBXImporter &p );
		spFBXImporter & operator=( const spFBXImporter &p );
		static spFBXImporter SafeCast(spObject other);
		IFBXImporter* operator->() const;
	};

	class IGraphicsExporter; // forward declaration of the interface

	/**
	 * spGraphicsExporter is the accessor for the IGraphicsExporter interface. Base 
	 * class for graphics export classes 
	 */
	class spGraphicsExporter : public spObject
	{
		public:
		spGraphicsExporter(IGraphicsExporter* p = nullptr);
		spGraphicsExporter( const spGraphicsExporter &p );
		spGraphicsExporter & operator=( const spGraphicsExporter &p );
		static spGraphicsExporter SafeCast(spObject other);
		IGraphicsExporter* operator->() const;
	};

	class IWavefrontExporter; // forward declaration of the interface

	/**
	 * spWavefrontExporter is the accessor for the IWavefrontExporter interface. Wavefront 
	 * .obj geometry exporter. 
	 */
	class spWavefrontExporter : public spGraphicsExporter
	{
		public:
		spWavefrontExporter(IWavefrontExporter* p = nullptr);
		spWavefrontExporter( const spWavefrontExporter &p );
		spWavefrontExporter & operator=( const spWavefrontExporter &p );
		static spWavefrontExporter SafeCast(spObject other);
		IWavefrontExporter* operator->() const;
	};

	class IFBXExporter; // forward declaration of the interface

	/**
	 * spFBXExporter is the accessor for the IFBXExporter interface. FBX scene exporter. 
	 */
	class spFBXExporter : public spGraphicsExporter
	{
		public:
		spFBXExporter(IFBXExporter* p = nullptr);
		spFBXExporter( const spFBXExporter &p );
		spFBXExporter & operator=( const spFBXExporter &p );
		static spFBXExporter SafeCast(spObject other);
		IFBXExporter* operator->() const;
	};

	class IGLTFExporter; // forward declaration of the interface

	/**
	 * spGLTFExporter is the accessor for the IGLTFExporter interface. glTF geometry 
	 * exporter capable of exporting both glTF and GLB files determined by output path 
	 * extension. Textures and binary blob files for glTF export will be placed alongside 
	 * the glTF file and have names prefixed by the output file name. Note that any 
	 * normal textures for the scene must be in tangent space, as generated by a normal 
	 * caster with SetGenerateTangentSpaceNormals set to true. 
	 */
	class spGLTFExporter : public spGraphicsExporter
	{
		public:
		spGLTFExporter(IGLTFExporter* p = nullptr);
		spGLTFExporter( const spGLTFExporter &p );
		spGLTFExporter & operator=( const spGLTFExporter &p );
		static spGLTFExporter SafeCast(spObject other);
		IGLTFExporter* operator->() const;
	};

	class IBinaryImporter; // forward declaration of the interface

	/**
	 * spBinaryImporter is the accessor for the IBinaryImporter interface. BinaryImporter 
	 * loads the geometry data from a binary file, that is specific for Simplygon. 
	 * Please note that the binary file is only intended for temporary storage, and 
	 * that no compatibility between versions of Simplygon is guaranteed. 
	 */
	class spBinaryImporter : public spGraphicsImporter
	{
		public:
		spBinaryImporter(IBinaryImporter* p = nullptr);
		spBinaryImporter( const spBinaryImporter &p );
		spBinaryImporter & operator=( const spBinaryImporter &p );
		static spBinaryImporter SafeCast(spObject other);
		IBinaryImporter* operator->() const;
	};

	class IBinaryExporter; // forward declaration of the interface

	/**
	 * spBinaryExporter is the accessor for the IBinaryExporter interface. BinaryExporter 
	 * stores the geometry data into a binary file, that is specific for Simplygon. 
	 * Please note that the binary file is only intended for temporary storage, and 
	 * that no compatibility between versions of Simplygon is guaranteed. 
	 */
	class spBinaryExporter : public spGraphicsExporter
	{
		public:
		spBinaryExporter(IBinaryExporter* p = nullptr);
		spBinaryExporter( const spBinaryExporter &p );
		spBinaryExporter & operator=( const spBinaryExporter &p );
		static spBinaryExporter SafeCast(spObject other);
		IBinaryExporter* operator->() const;
	};

	class IGeometryValidator; // forward declaration of the interface

	/**
	 * spGeometryValidator is the accessor for the IGeometryValidator interface. Checks 
	 * the geometry for consistent indices, number of triangles etc. 
	 */
	class spGeometryValidator : public spObject
	{
		public:
		spGeometryValidator(IGeometryValidator* p = nullptr);
		spGeometryValidator( const spGeometryValidator &p );
		spGeometryValidator & operator=( const spGeometryValidator &p );
		static spGeometryValidator SafeCast(spObject other);
		IGeometryValidator* operator->() const;
	};

	class ISettingsObject; // forward declaration of the interface

	/**
	 * spSettingsObject is the accessor for the ISettingsObject interface. SettingsObject 
	 * is the abstract base class for all settings objects in Simplygon. Settings objects 
	 * contains parameters for processing objects to use. These settings objects will 
	 * have their data set and reached from a ProcessingObject and then used therein. 
	 */
	class spSettingsObject : public spObject
	{
		public:
		spSettingsObject(ISettingsObject* p = nullptr);
		spSettingsObject( const spSettingsObject &p );
		spSettingsObject & operator=( const spSettingsObject &p );
		static spSettingsObject SafeCast(spObject other);
		ISettingsObject* operator->() const;
	};

	class IMaterialCaster; // forward declaration of the interface

	/**
	 * spMaterialCaster is the accessor for the IMaterialCaster interface. MaterialCaster 
	 * is the base interface for material casting interfaces. The interface exports 
	 * methods for defining input geometries & mapping image, materials, output image 
	 * paths & formats 
	 */
	class spMaterialCaster : public spProcessingObject
	{
		public:
		spMaterialCaster(IMaterialCaster* p = nullptr);
		spMaterialCaster( const spMaterialCaster &p );
		spMaterialCaster & operator=( const spMaterialCaster &p );
		static spMaterialCaster SafeCast(spObject other);
		IMaterialCaster* operator->() const;
	};

	class IMaterialCasterSettings; // forward declaration of the interface

	/**
	 * spMaterialCasterSettings is the accessor for the IMaterialCasterSettings interface. 
	 * MaterialCasterSettings is the base interface for material casting settings 
	 */
	class spMaterialCasterSettings : public spSettingsObject
	{
		public:
		spMaterialCasterSettings(IMaterialCasterSettings* p = nullptr);
		spMaterialCasterSettings( const spMaterialCasterSettings &p );
		spMaterialCasterSettings & operator=( const spMaterialCasterSettings &p );
		static spMaterialCasterSettings SafeCast(spObject other);
		IMaterialCasterSettings* operator->() const;
	};

	class IColorCaster; // forward declaration of the interface

	/**
	 * spColorCaster is the accessor for the IColorCaster interface. ColorCaster is 
	 * the interface used to cast basic color values. Currently supported material 
	 * color value types are Ambient, Diffuse and Specular + Shininess. 
	 */
	class spColorCaster : public spMaterialCaster
	{
		public:
		spColorCaster(IColorCaster* p = nullptr);
		spColorCaster( const spColorCaster &p );
		spColorCaster & operator=( const spColorCaster &p );
		static spColorCaster SafeCast(spObject other);
		IColorCaster* operator->() const;
	};

	class IColorCasterSettings; // forward declaration of the interface

	/**
	 * spColorCasterSettings is the accessor for the IColorCasterSettings interface. 
	 * ColorCasterSettings is the interface for basic color caster settings. 
	 */
	class spColorCasterSettings : public spMaterialCasterSettings
	{
		public:
		spColorCasterSettings(IColorCasterSettings* p = nullptr);
		spColorCasterSettings( const spColorCasterSettings &p );
		spColorCasterSettings & operator=( const spColorCasterSettings &p );
		static spColorCasterSettings SafeCast(spObject other);
		IColorCasterSettings* operator->() const;
	};

	class IOpacityCaster; // forward declaration of the interface

	/**
	 * spOpacityCaster is the accessor for the IOpacityCaster interface. OpacityCaster 
	 * is the interface used to cast opacity values. To be used when opacity is needed 
	 * as a separate texture. IMPORTANT: Make sure to set OpacityChannel to the channel 
	 * you want to cast, since this caster bakes opacity rather than the channel set 
	 * in the MaterialChannel setting like most other casters. 
	 */
	class spOpacityCaster : public spMaterialCaster
	{
		public:
		spOpacityCaster(IOpacityCaster* p = nullptr);
		spOpacityCaster( const spOpacityCaster &p );
		spOpacityCaster & operator=( const spOpacityCaster &p );
		static spOpacityCaster SafeCast(spObject other);
		IOpacityCaster* operator->() const;
	};

	class IOpacityCasterSettings; // forward declaration of the interface

	/**
	 * spOpacityCasterSettings is the accessor for the IOpacityCasterSettings interface. 
	 * OpacityCasterSettings is the interface used to manage settings for an opacity 
	 * caster. IMPORTANT: Make sure to set the OpacityChannel setting to the channel 
	 * you want to cast, since this caster bakes opacity rather than the channel set 
	 * in the MaterialChannel setting like most other casters. 
	 */
	class spOpacityCasterSettings : public spMaterialCasterSettings
	{
		public:
		spOpacityCasterSettings(IOpacityCasterSettings* p = nullptr);
		spOpacityCasterSettings( const spOpacityCasterSettings &p );
		spOpacityCasterSettings & operator=( const spOpacityCasterSettings &p );
		static spOpacityCasterSettings SafeCast(spObject other);
		IOpacityCasterSettings* operator->() const;
	};

	class INormalCaster; // forward declaration of the interface

	/**
	 * spNormalCaster is the accessor for the INormalCaster interface. NormalCaster 
	 * is the interface used to cast normals data onto the receiving geometry. 
	 */
	class spNormalCaster : public spMaterialCaster
	{
		public:
		spNormalCaster(INormalCaster* p = nullptr);
		spNormalCaster( const spNormalCaster &p );
		spNormalCaster & operator=( const spNormalCaster &p );
		static spNormalCaster SafeCast(spObject other);
		INormalCaster* operator->() const;
	};

	class INormalCasterSettings; // forward declaration of the interface

	/**
	 * spNormalCasterSettings is the accessor for the INormalCasterSettings interface. 
	 * NormalCasterSettings is the interface used to manage settings for a normal caster 
	 */
	class spNormalCasterSettings : public spMaterialCasterSettings
	{
		public:
		spNormalCasterSettings(INormalCasterSettings* p = nullptr);
		spNormalCasterSettings( const spNormalCasterSettings &p );
		spNormalCasterSettings & operator=( const spNormalCasterSettings &p );
		static spNormalCasterSettings SafeCast(spObject other);
		INormalCasterSettings* operator->() const;
	};

	class INormalRepairer; // forward declaration of the interface

	/**
	 * spNormalRepairer is the accessor for the INormalRepairer interface. Repairs 
	 * normals on a processed geometry. 
	 */
	class spNormalRepairer : public spProcessingObject
	{
		public:
		spNormalRepairer(INormalRepairer* p = nullptr);
		spNormalRepairer( const spNormalRepairer &p );
		spNormalRepairer & operator=( const spNormalRepairer &p );
		static spNormalRepairer SafeCast(spObject other);
		INormalRepairer* operator->() const;
	};

	class IDisplacementCaster; // forward declaration of the interface

	/**
	 * spDisplacementCaster is the accessor for the IDisplacementCaster interface. 
	 * DisplacementCaster is used to store the delta-values between the original and 
	 * processed geometries. The values are divided by a scaling value, and clamped 
	 * into the -1 -> 1 range before being stored into an image. 
	 */
	class spDisplacementCaster : public spMaterialCaster
	{
		public:
		spDisplacementCaster(IDisplacementCaster* p = nullptr);
		spDisplacementCaster( const spDisplacementCaster &p );
		spDisplacementCaster & operator=( const spDisplacementCaster &p );
		static spDisplacementCaster SafeCast(spObject other);
		IDisplacementCaster* operator->() const;
	};

	class IDisplacementCasterSettings; // forward declaration of the interface

	/**
	 * spDisplacementCasterSettings is the accessor for the IDisplacementCasterSettings 
	 * interface. DisplacementCasterSettings is used to store the settings for a displacement 
	 * caster 
	 */
	class spDisplacementCasterSettings : public spMaterialCasterSettings
	{
		public:
		spDisplacementCasterSettings(IDisplacementCasterSettings* p = nullptr);
		spDisplacementCasterSettings( const spDisplacementCasterSettings &p );
		spDisplacementCasterSettings & operator=( const spDisplacementCasterSettings &p );
		static spDisplacementCasterSettings SafeCast(spObject other);
		IDisplacementCasterSettings* operator->() const;
	};

	class ITangentCalculator; // forward declaration of the interface

	/**
	 * spTangentCalculator is the accessor for the ITangentCalculator interface. TangentCalculator 
	 * calculates tangent vectors for geometry data objects. One corner field of texture 
	 * coordinates must exist, as well as normals. The tangents are placed into two 
	 * corner fields called "Tangents" and "Bitangents". If any of these fields already 
	 * exists, it is replaced by the new field. 
	 */
	class spTangentCalculator : public spObject
	{
		public:
		spTangentCalculator(ITangentCalculator* p = nullptr);
		spTangentCalculator( const spTangentCalculator &p );
		spTangentCalculator & operator=( const spTangentCalculator &p );
		static spTangentCalculator SafeCast(spObject other);
		ITangentCalculator* operator->() const;
	};

	class IRepairSettings; // forward declaration of the interface

	/**
	 * spRepairSettings is the accessor for the IRepairSettings interface. Settings 
	 * for handling unconnected parts and unwanted gaps in the geometry. It consists 
	 * of two parts, Welding and T-junction removal. Welding merges vertices that are 
	 * closer than a set distance from each other. T-junction removal finds open edges 
	 * that lies within a set distance from other open edges, but without matching 
	 * vertices. It then splits those triangles into smaller, matching triangles and 
	 * fuses them together. 
	 */
	class spRepairSettings : public spSettingsObject
	{
		public:
		spRepairSettings(IRepairSettings* p = nullptr);
		spRepairSettings( const spRepairSettings &p );
		spRepairSettings & operator=( const spRepairSettings &p );
		static spRepairSettings SafeCast(spObject other);
		IRepairSettings* operator->() const;
	};

	class IBoneSettings; // forward declaration of the interface

	/**
	 * spBoneSettings is the accessor for the IBoneSettings interface. Settings for 
	 * the Simplygon Reduction/Remeshing classes With the BoneSettings object, the 
	 * user can setup all the parameters for how the BoneLOD processor should simplify 
	 * the links between geometries and bones. Bones can be un-linked from the geometry 
	 * either with a set ratio or depending on a selected pixel size on screen. 
	 */
	class spBoneSettings : public spSettingsObject
	{
		public:
		spBoneSettings(IBoneSettings* p = nullptr);
		spBoneSettings( const spBoneSettings &p );
		spBoneSettings & operator=( const spBoneSettings &p );
		static spBoneSettings SafeCast(spObject other);
		IBoneSettings* operator->() const;
	};

	class IReductionSettings; // forward declaration of the interface

	/**
	 * spReductionSettings is the accessor for the IReductionSettings interface. Settings 
	 * for the ReductionProcessor class. Handles all the settings for Simplygons simplification 
	 * algorithms. The user can tell the reduction processor which features are important 
	 * by using the 'FeatureFlags' parameter, and also the relative importance of these 
	 * features using the Set{feature}Importance methods. Also settings for things 
	 * like symmetry are set here. 
	 */
	class spReductionSettings : public spSettingsObject
	{
		public:
		spReductionSettings(IReductionSettings* p = nullptr);
		spReductionSettings( const spReductionSettings &p );
		spReductionSettings & operator=( const spReductionSettings &p );
		static spReductionSettings SafeCast(spObject other);
		IReductionSettings* operator->() const;
	};

	class INormalCalculationSettings; // forward declaration of the interface

	/**
	 * spNormalCalculationSettings is the accessor for the INormalCalculationSettings 
	 * interface. Settings for the normal recalculation 
	 */
	class spNormalCalculationSettings : public spSettingsObject
	{
		public:
		spNormalCalculationSettings(INormalCalculationSettings* p = nullptr);
		spNormalCalculationSettings( const spNormalCalculationSettings &p );
		spNormalCalculationSettings & operator=( const spNormalCalculationSettings &p );
		static spNormalCalculationSettings SafeCast(spObject other);
		INormalCalculationSettings* operator->() const;
	};

	class IMappingImageSettings; // forward declaration of the interface

	/**
	 * spMappingImageSettings is the accessor for the IMappingImageSettings interface. 
	 * Settings for the Simplygon mapping classes These settings control the properties 
	 * of the mapping image that will be generated in the current simplification processor 
	 * (reducer/remesher etc). The mapping image will be used when casting a new texture 
	 * on the simplified geometry. In the settings object, the user is able to set 
	 * the dimensions of the image (width/height) as well as whether the LOD should 
	 * have new texture coordinates and some parameters for how they should be generated 
	 * and all other settings regarding the mapping image. 
	 */
	class spMappingImageSettings : public spSettingsObject
	{
		public:
		spMappingImageSettings(IMappingImageSettings* p = nullptr);
		spMappingImageSettings( const spMappingImageSettings &p );
		spMappingImageSettings & operator=( const spMappingImageSettings &p );
		static spMappingImageSettings SafeCast(spObject other);
		IMappingImageSettings* operator->() const;
	};

	class IMappingImageInputMaterialSettings; // forward declaration of the interface

	/**
	 * spMappingImageInputMaterialSettings is the accessor for the IMappingImageInputMaterialSettings 
	 * interface. Settings for the Simplygon mapping input. 
	 */
	class spMappingImageInputMaterialSettings : public spSettingsObject
	{
		public:
		spMappingImageInputMaterialSettings(IMappingImageInputMaterialSettings* p = nullptr);
		spMappingImageInputMaterialSettings( const spMappingImageInputMaterialSettings &p );
		spMappingImageInputMaterialSettings & operator=( const spMappingImageInputMaterialSettings &p );
		static spMappingImageInputMaterialSettings SafeCast(spObject other);
		IMappingImageInputMaterialSettings* operator->() const;
	};

	class IMappingImageOutputMaterialSettings; // forward declaration of the interface

	/**
	 * spMappingImageOutputMaterialSettings is the accessor for the IMappingImageOutputMaterialSettings 
	 * interface. Settings for the Simplygon mapping output. 
	 */
	class spMappingImageOutputMaterialSettings : public spSettingsObject
	{
		public:
		spMappingImageOutputMaterialSettings(IMappingImageOutputMaterialSettings* p = nullptr);
		spMappingImageOutputMaterialSettings( const spMappingImageOutputMaterialSettings &p );
		spMappingImageOutputMaterialSettings & operator=( const spMappingImageOutputMaterialSettings &p );
		static spMappingImageOutputMaterialSettings SafeCast(spObject other);
		IMappingImageOutputMaterialSettings* operator->() const;
	};

	class IVisibilitySettings; // forward declaration of the interface

	/**
	 * spVisibilitySettings is the accessor for the IVisibilitySettings interface. 
	 * Visibility settings contains the parameters for how to compute the visibility 
	 * of a scene and how to use it, both in the ReductionProcessor and the RemeshingProcessor. 
	 * The visibility information is computed for each part of the mesh determined 
	 * by the visibility from the selected SceneCamera objects. Cameras are selected 
	 * using the CameraSelectionSetID. The visibility can be used to guide the reducer 
	 * and/or texture coordinates generator (parameterizer) with the flags UseVisibilityWeightsInReducer 
	 * respective UseVisibilityWeightsInTexcoordGenerator. There is also an option 
	 * to completely throw away triangles that are deemed not visible, using the CullOccludedGeometry 
	 * flag. 
	 */
	class spVisibilitySettings : public spSettingsObject
	{
		public:
		spVisibilitySettings(IVisibilitySettings* p = nullptr);
		spVisibilitySettings( const spVisibilitySettings &p );
		spVisibilitySettings & operator=( const spVisibilitySettings &p );
		static spVisibilitySettings SafeCast(spObject other);
		IVisibilitySettings* operator->() const;
	};

	class IReductionProcessor; // forward declaration of the interface

	/**
	 * spReductionProcessor is the accessor for the IReductionProcessor interface. 
	 * ReductionProcessor welds, removes t-junctions, removes double-triangles and 
	 * reduces the triangle count of the Geometry. It also calculates new normals for 
	 * the reduced and optimized Geometry. 
	 */
	class spReductionProcessor : public spProcessingObject
	{
		public:
		spReductionProcessor(IReductionProcessor* p = nullptr);
		spReductionProcessor( const spReductionProcessor &p );
		spReductionProcessor & operator=( const spReductionProcessor &p );
		static spReductionProcessor SafeCast(spObject other);
		IReductionProcessor* operator->() const;
	};

	class IRemeshingLegacySettings; // forward declaration of the interface

	/**
	 * spRemeshingLegacySettings is the accessor for the IRemeshingLegacySettings interface. 
	 * Remeshing settings for the RemeshingLegacyProcessor class. The remesher creates 
	 * a completely new lightweight mesh from the input geometry, and is intended to 
	 * be viewed from the outside. Here you will set the OnScreenSize (larger numbers 
	 * means a more detailed mesh), merge distance (which fills in smaller gaps) and 
	 * a cutting plane (where all parts of the input mesh on the far side of that plane 
	 * will be culled). 
	 */
	class spRemeshingLegacySettings : public spSettingsObject
	{
		public:
		spRemeshingLegacySettings(IRemeshingLegacySettings* p = nullptr);
		spRemeshingLegacySettings( const spRemeshingLegacySettings &p );
		spRemeshingLegacySettings & operator=( const spRemeshingLegacySettings &p );
		static spRemeshingLegacySettings SafeCast(spObject other);
		IRemeshingLegacySettings* operator->() const;
	};

	class IRemeshingSettings; // forward declaration of the interface

	/**
	 * spRemeshingSettings is the accessor for the IRemeshingSettings interface. Remeshing 
	 * settings for the RemeshingProcessor class. 
	 */
	class spRemeshingSettings : public spSettingsObject
	{
		public:
		spRemeshingSettings(IRemeshingSettings* p = nullptr);
		spRemeshingSettings( const spRemeshingSettings &p );
		spRemeshingSettings & operator=( const spRemeshingSettings &p );
		static spRemeshingSettings SafeCast(spObject other);
		IRemeshingSettings* operator->() const;
	};

	class IRemeshingLegacyProcessor; // forward declaration of the interface

	/**
	 * spRemeshingLegacyProcessor is the accessor for the IRemeshingLegacyProcessor 
	 * interface. RemeshingLegacyProcessor creates a new geometry that is based on 
	 * the input geometry, but that is topologically based on the size of the input 
	 * geometry rendered at a specific screen size, and allowed pixel error. The remesher 
	 * will on demand also add texture coordinates and a mapping texture to the output 
	 * remeshed geometry. The geometry that is to be remeshed can be defined either 
	 * using an in-memory geometry data object, or using a geometry file placed on 
	 * disk, the latter being the preferred method, if the source geometry is very 
	 * large as it can be swapped in/out of memory as needed. 
	 */
	class spRemeshingLegacyProcessor : public spProcessingObject
	{
		public:
		spRemeshingLegacyProcessor(IRemeshingLegacyProcessor* p = nullptr);
		spRemeshingLegacyProcessor( const spRemeshingLegacyProcessor &p );
		spRemeshingLegacyProcessor & operator=( const spRemeshingLegacyProcessor &p );
		static spRemeshingLegacyProcessor SafeCast(spObject other);
		IRemeshingLegacyProcessor* operator->() const;
	};

	class IRemeshingProcessor; // forward declaration of the interface

	/**
	 * spRemeshingProcessor is the accessor for the IRemeshingProcessor interface. 
	 * The RemeshingProcessor takes an input scene and replaces it with a lightweight 
	 * proxy geometry that resembles the original, but does not share vertex data or 
	 * parts of the original mesh data. The remeshed object is created and optimized 
	 * for a certain on-screen pixel size - which means that holes and parts that are 
	 * close to each other will have their gaps filled if the distance is below a pixel. 
	 * At default settings, the proxy mesh is assumed to be viewed from the outside. 
	 * Any interior mesh that cannot be seen is removed. The result is a very light-weight 
	 * mesh that is highly optimized for real-time viewing, or to speed up off-line 
	 * rendering of small objects. Simplygon is capable of remeshing arbitrary geometry, 
	 * including non-manifold surfaces. 
	 */
	class spRemeshingProcessor : public spProcessingObject
	{
		public:
		spRemeshingProcessor(IRemeshingProcessor* p = nullptr);
		spRemeshingProcessor( const spRemeshingProcessor &p );
		spRemeshingProcessor & operator=( const spRemeshingProcessor &p );
		static spRemeshingProcessor SafeCast(spObject other);
		IRemeshingProcessor* operator->() const;
	};

	class IScene; // forward declaration of the interface

	/**
	 * spScene is the accessor for the IScene interface. Scene is the main keeper of 
	 * a scene and scene graph in simplygon. The scene is self-contained, with materials, 
	 * textures, etc. to describe a full scene. 
	 */
	class spScene : public spObject
	{
		public:
		spScene(IScene* p = nullptr);
		spScene( const spScene &p );
		spScene & operator=( const spScene &p );
		static spScene SafeCast(spObject other);
		IScene* operator->() const;
	};

	class ISceneNode; // forward declaration of the interface

	/**
	 * spSceneNode is the accessor for the ISceneNode interface. SceneNode is the base 
	 * class for all scene graph nodes in simplygon. It has relative transformation 
	 * to its parent, and functions to add children to the node. 
	 */
	class spSceneNode : public spObject
	{
		public:
		spSceneNode(ISceneNode* p = nullptr);
		spSceneNode( const spSceneNode &p );
		spSceneNode & operator=( const spSceneNode &p );
		static spSceneNode SafeCast(spObject other);
		ISceneNode* operator->() const;
	};

	class ISceneNodeCollection; // forward declaration of the interface

	/**
	 * spSceneNodeCollection is the accessor for the ISceneNodeCollection interface. 
	 * SceneNodeCollection holds a number of SceneNode objects. The objects can be 
	 * looked up by their names (if they have been named through SetName()). 
	 */
	class spSceneNodeCollection : public spObjectCollection
	{
		public:
		spSceneNodeCollection(ISceneNodeCollection* p = nullptr);
		spSceneNodeCollection( const spSceneNodeCollection &p );
		spSceneNodeCollection & operator=( const spSceneNodeCollection &p );
		static spSceneNodeCollection SafeCast(spObject other);
		ISceneNodeCollection* operator->() const;
	};

	class ISceneMesh; // forward declaration of the interface

	/**
	 * spSceneMesh is the accessor for the ISceneMesh interface. SceneMesh is the mesh 
	 * node in the simplygon scene graph 
	 */
	class spSceneMesh : public spSceneNode
	{
		public:
		spSceneMesh(ISceneMesh* p = nullptr);
		spSceneMesh( const spSceneMesh &p );
		spSceneMesh & operator=( const spSceneMesh &p );
		static spSceneMesh SafeCast(spObject other);
		ISceneMesh* operator->() const;
	};

	class ISceneLodGroup; // forward declaration of the interface

	/**
	 * spSceneLodGroup is the accessor for the ISceneLodGroup interface. SceneLodGroup 
	 * is a LOD grouping for the scene graph 
	 */
	class spSceneLodGroup : public spSceneNode
	{
		public:
		spSceneLodGroup(ISceneLodGroup* p = nullptr);
		spSceneLodGroup( const spSceneLodGroup &p );
		spSceneLodGroup & operator=( const spSceneLodGroup &p );
		static spSceneLodGroup SafeCast(spObject other);
		ISceneLodGroup* operator->() const;
	};

	class ISceneBone; // forward declaration of the interface

	/**
	 * spSceneBone is the accessor for the ISceneBone interface. SceneBone is the bone 
	 * node in the simplygon scene graph 
	 */
	class spSceneBone : public spSceneNode
	{
		public:
		spSceneBone(ISceneBone* p = nullptr);
		spSceneBone( const spSceneBone &p );
		spSceneBone & operator=( const spSceneBone &p );
		static spSceneBone SafeCast(spObject other);
		ISceneBone* operator->() const;
	};

	class ISceneBoneTable; // forward declaration of the interface

	/**
	 * spSceneBoneTable is the accessor for the ISceneBoneTable interface. SceneBoneTable 
	 * keeps information on bones used while rendering. 
	 */
	class spSceneBoneTable : public spTable
	{
		public:
		spSceneBoneTable(ISceneBoneTable* p = nullptr);
		spSceneBoneTable( const spSceneBoneTable &p );
		spSceneBoneTable & operator=( const spSceneBoneTable &p );
		static spSceneBoneTable SafeCast(spObject other);
		ISceneBoneTable* operator->() const;
	};

	class IScenePlane; // forward declaration of the interface

	/**
	 * spScenePlane is the accessor for the IScenePlane interface. ScenePlane is the 
	 * plane node in the simplygon scene graph that can be used in various processes, 
	 * for example as a cutting plane in the RemeshingProcessor. 
	 */
	class spScenePlane : public spSceneNode
	{
		public:
		spScenePlane(IScenePlane* p = nullptr);
		spScenePlane( const spScenePlane &p );
		spScenePlane & operator=( const spScenePlane &p );
		static spScenePlane SafeCast(spObject other);
		IScenePlane* operator->() const;
	};

	class ISceneCamera; // forward declaration of the interface

	/**
	 * spSceneCamera is the accessor for the ISceneCamera interface. SceneCamera is 
	 * the camera node in the Simplygon scene graph. SceneCamera contains settings 
	 * that specify how the camera works and it contains a number of views for that 
	 * type of camera. A view is a combination of a CameraPosition and a TargetPosition. 
	 * The SceneCamera can contain any number of views but every element in TargetPositions 
	 * has to correspond to a tuple element in CameraPosition. TargetPositions is not 
	 * needed if the camera is set to being omni directional. 
	 */
	class spSceneCamera : public spSceneNode
	{
		public:
		spSceneCamera(ISceneCamera* p = nullptr);
		spSceneCamera( const spSceneCamera &p );
		spSceneCamera & operator=( const spSceneCamera &p );
		static spSceneCamera SafeCast(spObject other);
		ISceneCamera* operator->() const;
	};

	class ISceneExporter; // forward declaration of the interface

	/**
	 * spSceneExporter is the accessor for the ISceneExporter interface. Class for 
	 * saving scene data to different file formats depending on the extension of the 
	 * set file name. 
	 */
	class spSceneExporter : public spObject
	{
		public:
		spSceneExporter(ISceneExporter* p = nullptr);
		spSceneExporter( const spSceneExporter &p );
		spSceneExporter & operator=( const spSceneExporter &p );
		static spSceneExporter SafeCast(spObject other);
		ISceneExporter* operator->() const;
	};

	class ISceneImporter; // forward declaration of the interface

	/**
	 * spSceneImporter is the accessor for the ISceneImporter interface. Class for 
	 * loading scene data from different file formats. 
	 */
	class spSceneImporter : public spObject
	{
		public:
		spSceneImporter(ISceneImporter* p = nullptr);
		spSceneImporter( const spSceneImporter &p );
		spSceneImporter & operator=( const spSceneImporter &p );
		static spSceneImporter SafeCast(spObject other);
		ISceneImporter* operator->() const;
	};

	class ISelectionSet; // forward declaration of the interface

	/**
	 * spSelectionSet is the accessor for the ISelectionSet interface. SelectionSet 
	 * is a set of scene node GUIDs referencing scene nodes in a scene. 
	 */
	class spSelectionSet : public spObject
	{
		public:
		spSelectionSet(ISelectionSet* p = nullptr);
		spSelectionSet( const spSelectionSet &p );
		spSelectionSet & operator=( const spSelectionSet &p );
		static spSelectionSet SafeCast(spObject other);
		ISelectionSet* operator->() const;
	};

	class ISelectionSetTable; // forward declaration of the interface

	/**
	 * spSelectionSetTable is the accessor for the ISelectionSetTable interface. SelectionSetTable 
	 * keeps a table of SelectionSet. 
	 */
	class spSelectionSetTable : public spTable
	{
		public:
		spSelectionSetTable(ISelectionSetTable* p = nullptr);
		spSelectionSetTable( const spSelectionSetTable &p );
		spSelectionSetTable & operator=( const spSelectionSetTable &p );
		static spSelectionSetTable SafeCast(spObject other);
		ISelectionSetTable* operator->() const;
	};

	class ITexture; // forward declaration of the interface

	/**
	 * spTexture is the accessor for the ITexture interface. Texture describes a texture 
	 * object, containing either image data or a path that is referenced by texture 
	 * nodes in materials. 
	 */
	class spTexture : public spObject
	{
		public:
		spTexture(ITexture* p = nullptr);
		spTexture( const spTexture &p );
		spTexture & operator=( const spTexture &p );
		static spTexture SafeCast(spObject other);
		ITexture* operator->() const;
	};

	class ITextureTable; // forward declaration of the interface

	/**
	 * spTextureTable is the accessor for the ITextureTable interface. TextureTable 
	 * keeps information on textures used while rendering. 
	 */
	class spTextureTable : public spTable
	{
		public:
		spTextureTable(ITextureTable* p = nullptr);
		spTextureTable( const spTextureTable &p );
		spTextureTable & operator=( const spTextureTable &p );
		static spTextureTable SafeCast(spObject other);
		ITextureTable* operator->() const;
	};

	class IGeometryCullingSettings; // forward declaration of the interface

	/**
	 * spGeometryCullingSettings is the accessor for the IGeometryCullingSettings interface. 
	 * Settings for volumetric triangle culling functionality. These settings control 
	 * the clipping planes and geometries that are used for triangle culling the output 
	 * of Simplygon scene processors. 
	 */
	class spGeometryCullingSettings : public spSettingsObject
	{
		public:
		spGeometryCullingSettings(IGeometryCullingSettings* p = nullptr);
		spGeometryCullingSettings( const spGeometryCullingSettings &p );
		spGeometryCullingSettings & operator=( const spGeometryCullingSettings &p );
		static spGeometryCullingSettings SafeCast(spObject other);
		IGeometryCullingSettings* operator->() const;
	};

	class IImageDataImporter; // forward declaration of the interface

	/**
	 * spImageDataImporter is the accessor for the IImageDataImporter interface. Class 
	 * for loading image data from different file formats. 
	 */
	class spImageDataImporter : public spObject
	{
		public:
		spImageDataImporter(IImageDataImporter* p = nullptr);
		spImageDataImporter( const spImageDataImporter &p );
		spImageDataImporter & operator=( const spImageDataImporter &p );
		static spImageDataImporter SafeCast(spObject other);
		IImageDataImporter* operator->() const;
	};

	class IMappingImageMeshData; // forward declaration of the interface

	/**
	 * spMappingImageMeshData is the accessor for the IMappingImageMeshData interface. 
	 * MappingImageMeshData stores the mapped meshes and their paths in the original 
	 * scene. This can be used to find a specific triangle on the original mesh in 
	 * the scene from the combined id in the mapping image. 
	 */
	class spMappingImageMeshData : public spObject
	{
		public:
		spMappingImageMeshData(IMappingImageMeshData* p = nullptr);
		spMappingImageMeshData( const spMappingImageMeshData &p );
		spMappingImageMeshData & operator=( const spMappingImageMeshData &p );
		static spMappingImageMeshData SafeCast(spObject other);
		IMappingImageMeshData* operator->() const;
	};

	class IShadingNode; // forward declaration of the interface

	/**
	 * spShadingNode is the accessor for the IShadingNode interface. ShadingNode is 
	 * the parent of all nodes in a shading network. 
	 */
	class spShadingNode : public spObject
	{
		public:
		spShadingNode(IShadingNode* p = nullptr);
		spShadingNode( const spShadingNode &p );
		spShadingNode & operator=( const spShadingNode &p );
		static spShadingNode SafeCast(spObject other);
		IShadingNode* operator->() const;
	};

	class IShadingFilterNode; // forward declaration of the interface

	/**
	 * spShadingFilterNode is the accessor for the IShadingFilterNode interface. FilterNode 
	 * is the parent of all non-source nodes in a shading network. 
	 */
	class spShadingFilterNode : public spShadingNode
	{
		public:
		spShadingFilterNode(IShadingFilterNode* p = nullptr);
		spShadingFilterNode( const spShadingFilterNode &p );
		spShadingFilterNode & operator=( const spShadingFilterNode &p );
		static spShadingFilterNode SafeCast(spObject other);
		IShadingFilterNode* operator->() const;
	};

	class IShadingTextureNode; // forward declaration of the interface

	/**
	 * spShadingTextureNode is the accessor for the IShadingTextureNode interface. 
	 * TextureNode describes a texture source node in a shading network. 
	 */
	class spShadingTextureNode : public spShadingNode
	{
		public:
		spShadingTextureNode(IShadingTextureNode* p = nullptr);
		spShadingTextureNode( const spShadingTextureNode &p );
		spShadingTextureNode & operator=( const spShadingTextureNode &p );
		static spShadingTextureNode SafeCast(spObject other);
		IShadingTextureNode* operator->() const;
	};

	class IShadingSwizzlingNode; // forward declaration of the interface

	/**
	 * spShadingSwizzlingNode is the accessor for the IShadingSwizzlingNode interface. 
	 * SwizzlingNode describes a node that can remap the input to the specified output. 
	 */
	class spShadingSwizzlingNode : public spShadingFilterNode
	{
		public:
		spShadingSwizzlingNode(IShadingSwizzlingNode* p = nullptr);
		spShadingSwizzlingNode( const spShadingSwizzlingNode &p );
		spShadingSwizzlingNode & operator=( const spShadingSwizzlingNode &p );
		static spShadingSwizzlingNode SafeCast(spObject other);
		IShadingSwizzlingNode* operator->() const;
	};

	class IShadingColorNode; // forward declaration of the interface

	/**
	 * spShadingColorNode is the accessor for the IShadingColorNode interface. ColorNode 
	 * describes a single color source node in a shading network 
	 */
	class spShadingColorNode : public spShadingNode
	{
		public:
		spShadingColorNode(IShadingColorNode* p = nullptr);
		spShadingColorNode( const spShadingColorNode &p );
		spShadingColorNode & operator=( const spShadingColorNode &p );
		static spShadingColorNode SafeCast(spObject other);
		IShadingColorNode* operator->() const;
	};

	class IShadingAddNode; // forward declaration of the interface

	/**
	 * spShadingAddNode is the accessor for the IShadingAddNode interface. AddNode 
	 * describes a single addition shading node in a shading network. Input 1 and 2 
	 * are added per-component to produce the output. 
	 */
	class spShadingAddNode : public spShadingFilterNode
	{
		public:
		spShadingAddNode(IShadingAddNode* p = nullptr);
		spShadingAddNode( const spShadingAddNode &p );
		spShadingAddNode & operator=( const spShadingAddNode &p );
		static spShadingAddNode SafeCast(spObject other);
		IShadingAddNode* operator->() const;
	};

	class IShadingSubtractNode; // forward declaration of the interface

	/**
	 * spShadingSubtractNode is the accessor for the IShadingSubtractNode interface. 
	 * SubtractNode describes a single subtracting shading node in a shading network. 
	 * Input 2 is subtracted from input 1 per-component. 
	 */
	class spShadingSubtractNode : public spShadingFilterNode
	{
		public:
		spShadingSubtractNode(IShadingSubtractNode* p = nullptr);
		spShadingSubtractNode( const spShadingSubtractNode &p );
		spShadingSubtractNode & operator=( const spShadingSubtractNode &p );
		static spShadingSubtractNode SafeCast(spObject other);
		IShadingSubtractNode* operator->() const;
	};

	class IShadingMultiplyNode; // forward declaration of the interface

	/**
	 * spShadingMultiplyNode is the accessor for the IShadingMultiplyNode interface. 
	 * MultiplyNode describes a single multiplying shading node in a shading network. 
	 * Input 1 and Input 2 is multiplied per-component. 
	 */
	class spShadingMultiplyNode : public spShadingFilterNode
	{
		public:
		spShadingMultiplyNode(IShadingMultiplyNode* p = nullptr);
		spShadingMultiplyNode( const spShadingMultiplyNode &p );
		spShadingMultiplyNode & operator=( const spShadingMultiplyNode &p );
		static spShadingMultiplyNode SafeCast(spObject other);
		IShadingMultiplyNode* operator->() const;
	};

	class IShadingPowNode; // forward declaration of the interface

	/**
	 * spShadingPowNode is the accessor for the IShadingPowNode interface. This node 
	 * describes an exponentiation. The output will be Input 1 to the power of Input 
	 * 2, and it is calculated per-component. 
	 */
	class spShadingPowNode : public spShadingFilterNode
	{
		public:
		spShadingPowNode(IShadingPowNode* p = nullptr);
		spShadingPowNode( const spShadingPowNode &p );
		spShadingPowNode & operator=( const spShadingPowNode &p );
		static spShadingPowNode SafeCast(spObject other);
		IShadingPowNode* operator->() const;
	};

	class IShadingDivideNode; // forward declaration of the interface

	/**
	 * spShadingDivideNode is the accessor for the IShadingDivideNode interface. DivideNode 
	 * describes a single division shading node node in a shading network. Input 1 
	 * is divided by Input 2 per-component to produce the output. 
	 */
	class spShadingDivideNode : public spShadingFilterNode
	{
		public:
		spShadingDivideNode(IShadingDivideNode* p = nullptr);
		spShadingDivideNode( const spShadingDivideNode &p );
		spShadingDivideNode & operator=( const spShadingDivideNode &p );
		static spShadingDivideNode SafeCast(spObject other);
		IShadingDivideNode* operator->() const;
	};

	class IShadingClampNode; // forward declaration of the interface

	/**
	 * spShadingClampNode is the accessor for the IShadingClampNode interface. ClampNode 
	 * describes a single clamp shading node in a shading network. Input 1 is clamped 
	 * per-component between Input 2 and 3. 
	 */
	class spShadingClampNode : public spShadingFilterNode
	{
		public:
		spShadingClampNode(IShadingClampNode* p = nullptr);
		spShadingClampNode( const spShadingClampNode &p );
		spShadingClampNode & operator=( const spShadingClampNode &p );
		static spShadingClampNode SafeCast(spObject other);
		IShadingClampNode* operator->() const;
	};

	class IShadingMaxNode; // forward declaration of the interface

	/**
	 * spShadingMaxNode is the accessor for the IShadingMaxNode interface. MaxNode 
	 * describes a single max shading node in a shading network. The output has the 
	 * per-channel max values of the two inputs. 
	 */
	class spShadingMaxNode : public spShadingFilterNode
	{
		public:
		spShadingMaxNode(IShadingMaxNode* p = nullptr);
		spShadingMaxNode( const spShadingMaxNode &p );
		spShadingMaxNode & operator=( const spShadingMaxNode &p );
		static spShadingMaxNode SafeCast(spObject other);
		IShadingMaxNode* operator->() const;
	};

	class IShadingMinNode; // forward declaration of the interface

	/**
	 * spShadingMinNode is the accessor for the IShadingMinNode interface. MinNode 
	 * describes a single min shading node in a shading network. The output has the 
	 * per-channel min values of the two inputs. 
	 */
	class spShadingMinNode : public spShadingFilterNode
	{
		public:
		spShadingMinNode(IShadingMinNode* p = nullptr);
		spShadingMinNode( const spShadingMinNode &p );
		spShadingMinNode & operator=( const spShadingMinNode &p );
		static spShadingMinNode SafeCast(spObject other);
		IShadingMinNode* operator->() const;
	};

	class IShadingStepNode; // forward declaration of the interface

	/**
	 * spShadingStepNode is the accessor for the IShadingStepNode interface. StepNode 
	 * describes a single step shading node, where the per-component output is either 
	 * 1 or 0 depending on if input0 is larger or smaller than input1. Basically, (Input0 
	 * >= Input1) ? 1 : 0 
	 */
	class spShadingStepNode : public spShadingFilterNode
	{
		public:
		spShadingStepNode(IShadingStepNode* p = nullptr);
		spShadingStepNode( const spShadingStepNode &p );
		spShadingStepNode & operator=( const spShadingStepNode &p );
		static spShadingStepNode SafeCast(spObject other);
		IShadingStepNode* operator->() const;
	};

	class IShadingEqualNode; // forward declaration of the interface

	/**
	 * spShadingEqualNode is the accessor for the IShadingEqualNode interface. ShadingEqualNode 
	 * describes an "is equal to" operator, where the per-component output is either 
	 * 1 or 0 depending on if input0 is equal to input1. Basically, (Input0 == Input1) 
	 * ? 1 : 0 
	 */
	class spShadingEqualNode : public spShadingFilterNode
	{
		public:
		spShadingEqualNode(IShadingEqualNode* p = nullptr);
		spShadingEqualNode( const spShadingEqualNode &p );
		spShadingEqualNode & operator=( const spShadingEqualNode &p );
		static spShadingEqualNode SafeCast(spObject other);
		IShadingEqualNode* operator->() const;
	};

	class IShadingNotEqualNode; // forward declaration of the interface

	/**
	 * spShadingNotEqualNode is the accessor for the IShadingNotEqualNode interface. 
	 * NotEqualNode describes the "is not equal" operator, where the per-component 
	 * output is either 1 or 0 depending on if input0 is equal to input1. Basically, 
	 * (Input0 != Input1) ? 1 : 0 
	 */
	class spShadingNotEqualNode : public spShadingFilterNode
	{
		public:
		spShadingNotEqualNode(IShadingNotEqualNode* p = nullptr);
		spShadingNotEqualNode( const spShadingNotEqualNode &p );
		spShadingNotEqualNode & operator=( const spShadingNotEqualNode &p );
		static spShadingNotEqualNode SafeCast(spObject other);
		IShadingNotEqualNode* operator->() const;
	};

	class IShadingVertexColorNode; // forward declaration of the interface

	/**
	 * spShadingVertexColorNode is the accessor for the IShadingVertexColorNode interface. 
	 * VertexColorNode describes a vertex color source node in a shading network. 
	 */
	class spShadingVertexColorNode : public spShadingNode
	{
		public:
		spShadingVertexColorNode(IShadingVertexColorNode* p = nullptr);
		spShadingVertexColorNode( const spShadingVertexColorNode &p );
		spShadingVertexColorNode & operator=( const spShadingVertexColorNode &p );
		static spShadingVertexColorNode SafeCast(spObject other);
		IShadingVertexColorNode* operator->() const;
	};

	class IShadingInterpolateNode; // forward declaration of the interface

	/**
	 * spShadingInterpolateNode is the accessor for the IShadingInterpolateNode interface. 
	 * InterpolateNode describes a single interpolating shading node node in a shading 
	 * network. Input 1 and Input 2 is interpolated per-component using Input 3. Blend 
	 * values below 0 and over 1 will be clamped. 
	 */
	class spShadingInterpolateNode : public spShadingFilterNode
	{
		public:
		spShadingInterpolateNode(IShadingInterpolateNode* p = nullptr);
		spShadingInterpolateNode( const spShadingInterpolateNode &p );
		spShadingInterpolateNode & operator=( const spShadingInterpolateNode &p );
		static spShadingInterpolateNode SafeCast(spObject other);
		IShadingInterpolateNode* operator->() const;
	};

	class IShadingCustomNode; // forward declaration of the interface

	/**
	 * spShadingCustomNode is the accessor for the IShadingCustomNode interface. CustomNode 
	 * describes a custom shading node in a shading network. The output is produced 
	 * based on customizable user specified operations. The custom node has a user 
	 * specified amount of input parameters. Use SetInputCount() to specify the number 
	 * of inputs. The user has to assign and implement event handlers (called observers) 
	 * for the custom node to be able to evaluate to colors. See CustomNodeExample 
	 * and API documentation for further explanations and code samples. 
	 */
	class spShadingCustomNode : public spShadingFilterNode
	{
		public:
		spShadingCustomNode(IShadingCustomNode* p = nullptr);
		spShadingCustomNode( const spShadingCustomNode &p );
		spShadingCustomNode & operator=( const spShadingCustomNode &p );
		static spShadingCustomNode SafeCast(spObject other);
		IShadingCustomNode* operator->() const;
	};

	class IShadingLayeredBlendNode; // forward declaration of the interface

	/**
	 * spShadingLayeredBlendNode is the accessor for the IShadingLayeredBlendNode interface. 
	 * LayeredBlendNode is a node with an arbitrary number of inputs that can be blended 
	 * differently. 
	 */
	class spShadingLayeredBlendNode : public spShadingFilterNode
	{
		public:
		spShadingLayeredBlendNode(IShadingLayeredBlendNode* p = nullptr);
		spShadingLayeredBlendNode( const spShadingLayeredBlendNode &p );
		spShadingLayeredBlendNode & operator=( const spShadingLayeredBlendNode &p );
		static spShadingLayeredBlendNode SafeCast(spObject other);
		IShadingLayeredBlendNode* operator->() const;
	};

	class IShadingNormalize3Node; // forward declaration of the interface

	/**
	 * spShadingNormalize3Node is the accessor for the IShadingNormalize3Node interface. 
	 * This node describes an normalization of the x,y,z components of the input. 
	 */
	class spShadingNormalize3Node : public spShadingFilterNode
	{
		public:
		spShadingNormalize3Node(IShadingNormalize3Node* p = nullptr);
		spShadingNormalize3Node( const spShadingNormalize3Node &p );
		spShadingNormalize3Node & operator=( const spShadingNormalize3Node &p );
		static spShadingNormalize3Node SafeCast(spObject other);
		IShadingNormalize3Node* operator->() const;
	};

	class IShadingSqrtNode; // forward declaration of the interface

	/**
	 * spShadingSqrtNode is the accessor for the IShadingSqrtNode interface. This node 
	 * describes a square root calculation. The output will be the per-component square 
	 * root of input 1 
	 */
	class spShadingSqrtNode : public spShadingFilterNode
	{
		public:
		spShadingSqrtNode(IShadingSqrtNode* p = nullptr);
		spShadingSqrtNode( const spShadingSqrtNode &p );
		spShadingSqrtNode & operator=( const spShadingSqrtNode &p );
		static spShadingSqrtNode SafeCast(spObject other);
		IShadingSqrtNode* operator->() const;
	};

	class IShadingDot3Node; // forward declaration of the interface

	/**
	 * spShadingDot3Node is the accessor for the IShadingDot3Node interface. This node 
	 * describes an dot of the x,y,z components of the inputs. 
	 */
	class spShadingDot3Node : public spShadingFilterNode
	{
		public:
		spShadingDot3Node(IShadingDot3Node* p = nullptr);
		spShadingDot3Node( const spShadingDot3Node &p );
		spShadingDot3Node & operator=( const spShadingDot3Node &p );
		static spShadingDot3Node SafeCast(spObject other);
		IShadingDot3Node* operator->() const;
	};

	class IShadingCross3Node; // forward declaration of the interface

	/**
	 * spShadingCross3Node is the accessor for the IShadingCross3Node interface. This 
	 * node describes the cross of the x,y,z components of the input. 
	 */
	class spShadingCross3Node : public spShadingFilterNode
	{
		public:
		spShadingCross3Node(IShadingCross3Node* p = nullptr);
		spShadingCross3Node( const spShadingCross3Node &p );
		spShadingCross3Node & operator=( const spShadingCross3Node &p );
		static spShadingCross3Node SafeCast(spObject other);
		IShadingCross3Node* operator->() const;
	};

	class IShadingCosNode; // forward declaration of the interface

	/**
	 * spShadingCosNode is the accessor for the IShadingCosNode interface. This node 
	 * describes cosine of the x,y,z,w components of the input. 
	 */
	class spShadingCosNode : public spShadingFilterNode
	{
		public:
		spShadingCosNode(IShadingCosNode* p = nullptr);
		spShadingCosNode( const spShadingCosNode &p );
		spShadingCosNode & operator=( const spShadingCosNode &p );
		static spShadingCosNode SafeCast(spObject other);
		IShadingCosNode* operator->() const;
	};

	class IShadingSinNode; // forward declaration of the interface

	/**
	 * spShadingSinNode is the accessor for the IShadingSinNode interface. This node 
	 * describes Sin of the x,y,z components of the input. 
	 */
	class spShadingSinNode : public spShadingFilterNode
	{
		public:
		spShadingSinNode(IShadingSinNode* p = nullptr);
		spShadingSinNode( const spShadingSinNode &p );
		spShadingSinNode & operator=( const spShadingSinNode &p );
		static spShadingSinNode SafeCast(spObject other);
		IShadingSinNode* operator->() const;
	};

	class IShadingGreaterThanNode; // forward declaration of the interface

	/**
	 * spShadingGreaterThanNode is the accessor for the IShadingGreaterThanNode interface. 
	 * GreaterThanNode describes the "is greater than" operator, where the per-component 
	 * output is either 1 or 0 depending on if input0 is greater than input1. Basically, 
	 * (Input0 > Input1) ? 1 : 0 
	 */
	class spShadingGreaterThanNode : public spShadingFilterNode
	{
		public:
		spShadingGreaterThanNode(IShadingGreaterThanNode* p = nullptr);
		spShadingGreaterThanNode( const spShadingGreaterThanNode &p );
		spShadingGreaterThanNode & operator=( const spShadingGreaterThanNode &p );
		static spShadingGreaterThanNode SafeCast(spObject other);
		IShadingGreaterThanNode* operator->() const;
	};

	class IShadingLessThanNode; // forward declaration of the interface

	/**
	 * spShadingLessThanNode is the accessor for the IShadingLessThanNode interface. 
	 * LessThanNode describes the "is less than" operator, where the per-component 
	 * output is either 1 or 0 depending on if input0 is LessThan to input1. Basically, 
	 * (Input0 < Input1) ? 1 : 0 
	 */
	class spShadingLessThanNode : public spShadingFilterNode
	{
		public:
		spShadingLessThanNode(IShadingLessThanNode* p = nullptr);
		spShadingLessThanNode( const spShadingLessThanNode &p );
		spShadingLessThanNode & operator=( const spShadingLessThanNode &p );
		static spShadingLessThanNode SafeCast(spObject other);
		IShadingLessThanNode* operator->() const;
	};

	class IShadingGeometryFieldNode; // forward declaration of the interface

	/**
	 * spShadingGeometryFieldNode is the accessor for the IShadingGeometryFieldNode 
	 * interface. Geometry field node describes a source node for geometry field data 
	 * in a shading network, such as normals and tangents. 
	 */
	class spShadingGeometryFieldNode : public spShadingNode
	{
		public:
		spShadingGeometryFieldNode(IShadingGeometryFieldNode* p = nullptr);
		spShadingGeometryFieldNode( const spShadingGeometryFieldNode &p );
		spShadingGeometryFieldNode & operator=( const spShadingGeometryFieldNode &p );
		static spShadingGeometryFieldNode SafeCast(spObject other);
		IShadingGeometryFieldNode* operator->() const;
	};

	class IShaderGenerator; // forward declaration of the interface

	/**
	 * spShaderGenerator is the accessor for the IShaderGenerator interface. Given 
	 * a material, the shader data class keeps the relevant shader data and is able 
	 * to generate a GLSL/HLSL shader. 
	 */
	class spShaderGenerator : public spObject
	{
		public:
		spShaderGenerator(IShaderGenerator* p = nullptr);
		spShaderGenerator( const spShaderGenerator &p );
		spShaderGenerator & operator=( const spShaderGenerator &p );
		static spShaderGenerator SafeCast(spObject other);
		IShaderGenerator* operator->() const;
	};

	class IAggregationProcessor; // forward declaration of the interface

	/**
	 * spAggregationProcessor is the accessor for the IAggregationProcessor interface. 
	 * AggregationProcessor combines all specified geometries in the scene into one 
	 * geometry. All materials are combined and receive a new shared texture atlas. 
	 */
	class spAggregationProcessor : public spProcessingObject
	{
		public:
		spAggregationProcessor(IAggregationProcessor* p = nullptr);
		spAggregationProcessor( const spAggregationProcessor &p );
		spAggregationProcessor & operator=( const spAggregationProcessor &p );
		static spAggregationProcessor SafeCast(spObject other);
		IAggregationProcessor* operator->() const;
	};

	class IAggregationSettings; // forward declaration of the interface

	/**
	 * spAggregationSettings is the accessor for the IAggregationSettings interface. 
	 * Settings for the AggregationSettings class. The AggregationProcessor converts 
	 * entire scenes containing multiple draw calls into a single new object with a 
	 * single texture per material channel. The user can set whether or not the AggregationProcessor 
	 * should create new UVs based on the old UVs or create a completely new UV parameterization. 
	 */
	class spAggregationSettings : public spSettingsObject
	{
		public:
		spAggregationSettings(IAggregationSettings* p = nullptr);
		spAggregationSettings( const spAggregationSettings &p );
		spAggregationSettings & operator=( const spAggregationSettings &p );
		static spAggregationSettings SafeCast(spObject other);
		IAggregationSettings* operator->() const;
	};

	class IChartAggregator; // forward declaration of the interface

	/**
	 * spChartAggregator is the accessor for the IChartAggregator interface. Computes 
	 * new texture coordinates for a geometry with overlapping UV charts. 
	 */
	class spChartAggregator : public spObject
	{
		public:
		spChartAggregator(IChartAggregator* p = nullptr);
		spChartAggregator( const spChartAggregator &p );
		spChartAggregator & operator=( const spChartAggregator &p );
		static spChartAggregator SafeCast(spObject other);
		IChartAggregator* operator->() const;
	};

	class IVertexColorCasterSettings; // forward declaration of the interface

	/**
	 * spVertexColorCasterSettings is the accessor for the IVertexColorCasterSettings 
	 * interface. VertexColorCasterSettings is the interface for basic vertex color 
	 * caster settings. 
	 */
	class spVertexColorCasterSettings : public spMaterialCasterSettings
	{
		public:
		spVertexColorCasterSettings(IVertexColorCasterSettings* p = nullptr);
		spVertexColorCasterSettings( const spVertexColorCasterSettings &p );
		spVertexColorCasterSettings & operator=( const spVertexColorCasterSettings &p );
		static spVertexColorCasterSettings SafeCast(spObject other);
		IVertexColorCasterSettings* operator->() const;
	};

	class IVertexColorCaster; // forward declaration of the interface

	/**
	 * spVertexColorCaster is the accessor for the IVertexColorCaster interface. VertexColorCaster. 
	 */
	class spVertexColorCaster : public spMaterialCaster
	{
		public:
		spVertexColorCaster(IVertexColorCaster* p = nullptr);
		spVertexColorCaster( const spVertexColorCaster &p );
		spVertexColorCaster & operator=( const spVertexColorCaster &p );
		static spVertexColorCaster SafeCast(spObject other);
		IVertexColorCaster* operator->() const;
	};

	class IImageDataExporter; // forward declaration of the interface

	/**
	 * spImageDataExporter is the accessor for the IImageDataExporter interface. Class 
	 * for saving image data to different file formats. 
	 */
	class spImageDataExporter : public spObject
	{
		public:
		spImageDataExporter(IImageDataExporter* p = nullptr);
		spImageDataExporter( const spImageDataExporter &p );
		spImageDataExporter & operator=( const spImageDataExporter &p );
		static spImageDataExporter SafeCast(spObject other);
		IImageDataExporter* operator->() const;
	};

	class IAmbientOcclusionCaster; // forward declaration of the interface

	/**
	 * spAmbientOcclusionCaster is the accessor for the IAmbientOcclusionCaster interface. 
	 * AmbientOcclusionCaster generates an ambient occlusion map based on the original 
	 * geometry, and casts it. 
	 */
	class spAmbientOcclusionCaster : public spMaterialCaster
	{
		public:
		spAmbientOcclusionCaster(IAmbientOcclusionCaster* p = nullptr);
		spAmbientOcclusionCaster( const spAmbientOcclusionCaster &p );
		spAmbientOcclusionCaster & operator=( const spAmbientOcclusionCaster &p );
		static spAmbientOcclusionCaster SafeCast(spObject other);
		IAmbientOcclusionCaster* operator->() const;
	};

	class IAmbientOcclusionCasterSettings; // forward declaration of the interface

	/**
	 * spAmbientOcclusionCasterSettings is the accessor for the IAmbientOcclusionCasterSettings 
	 * interface. AmbientOcclusionCasterSettings manages settings for an ambient occlusion 
	 * caster. 
	 */
	class spAmbientOcclusionCasterSettings : public spMaterialCasterSettings
	{
		public:
		spAmbientOcclusionCasterSettings(IAmbientOcclusionCasterSettings* p = nullptr);
		spAmbientOcclusionCasterSettings( const spAmbientOcclusionCasterSettings &p );
		spAmbientOcclusionCasterSettings & operator=( const spAmbientOcclusionCasterSettings &p );
		static spAmbientOcclusionCasterSettings SafeCast(spObject other);
		IAmbientOcclusionCasterSettings* operator->() const;
	};

	class IImpostorProcessor; // forward declaration of the interface

	/**
	 * spImpostorProcessor is the accessor for the IImpostorProcessor interface. The 
	 * ImpostorProcessor generates an impostor of one of these impostor types: BillboardCloud, 
	 * Flipbook or ImpostorFromSingleView. 
	 */
	class spImpostorProcessor : public spProcessingObject
	{
		public:
		spImpostorProcessor(IImpostorProcessor* p = nullptr);
		spImpostorProcessor( const spImpostorProcessor &p );
		spImpostorProcessor & operator=( const spImpostorProcessor &p );
		static spImpostorProcessor SafeCast(spObject other);
		IImpostorProcessor* operator->() const;
	};

	class IImpostorSettings; // forward declaration of the interface

	/**
	 * spImpostorSettings is the accessor for the IImpostorSettings interface. Settings 
	 * for the ImpostorProccessor 
	 */
	class spImpostorSettings : public spSettingsObject
	{
		public:
		spImpostorSettings(IImpostorSettings* p = nullptr);
		spImpostorSettings( const spImpostorSettings &p );
		spImpostorSettings & operator=( const spImpostorSettings &p );
		static spImpostorSettings SafeCast(spObject other);
		IImpostorSettings* operator->() const;
	};

	class ISurfaceMapper; // forward declaration of the interface

	/**
	 * spSurfaceMapper is the accessor for the ISurfaceMapper interface. ISurfaceMapper 
	 * creates a mapping image between two user-defined geometries. The mapper basically 
	 * looks for the source geometry in the inverse normal direction from the outwardly 
	 * offset destination geometry, and maps pixels accordingly. This means that you 
	 * can modify the normals of the destination geometry to adjust the search direction 
	 * to your liking. The geometries can either be set as IGeometryDatas or as the 
	 * root nodes of scenes. If both are set, the scene is used. If only a single source 
	 * or a destination is set, or if the source and destination are the same scene 
	 * or geometry, the surface mapper will map the mesh onto itself. 
	 */
	class spSurfaceMapper : public spObject
	{
		public:
		spSurfaceMapper(ISurfaceMapper* p = nullptr);
		spSurfaceMapper( const spSurfaceMapper &p );
		spSurfaceMapper & operator=( const spSurfaceMapper &p );
		static spSurfaceMapper SafeCast(spObject other);
		ISurfaceMapper* operator->() const;
	};

	class IOcclusionMeshProcessor; // forward declaration of the interface

	/**
	 * spOcclusionMeshProcessor is the accessor for the IOcclusionMeshProcessor interface. 
	 * The occlusion mesh processor creates a reconstruction of the input mesh from 
	 * its silhouette. This means concavities and internal geometry disappear. WARNING: 
	 * Experimental. Generates nice meshes, but currently very slow at high settings. 
	 * Recommended onscreens size ~100 
	 */
	class spOcclusionMeshProcessor : public spProcessingObject
	{
		public:
		spOcclusionMeshProcessor(IOcclusionMeshProcessor* p = nullptr);
		spOcclusionMeshProcessor( const spOcclusionMeshProcessor &p );
		spOcclusionMeshProcessor & operator=( const spOcclusionMeshProcessor &p );
		static spOcclusionMeshProcessor SafeCast(spObject other);
		IOcclusionMeshProcessor* operator->() const;
	};

	class IOcclusionMeshSettings; // forward declaration of the interface

	/**
	 * spOcclusionMeshSettings is the accessor for the IOcclusionMeshSettings interface. 
	 * Settings for occlusion meshes 
	 */
	class spOcclusionMeshSettings : public spSettingsObject
	{
		public:
		spOcclusionMeshSettings(IOcclusionMeshSettings* p = nullptr);
		spOcclusionMeshSettings( const spOcclusionMeshSettings &p );
		spOcclusionMeshSettings & operator=( const spOcclusionMeshSettings &p );
		static spOcclusionMeshSettings SafeCast(spObject other);
		IOcclusionMeshSettings* operator->() const;
	};

	class IImageComparer; // forward declaration of the interface

	/**
	 * spImageComparer is the accessor for the IImageComparer interface. Compares images. 
	 */
	class spImageComparer : public spObject
	{
		public:
		spImageComparer(IImageComparer* p = nullptr);
		spImageComparer( const spImageComparer &p );
		spImageComparer & operator=( const spImageComparer &p );
		static spImageComparer SafeCast(spObject other);
		IImageComparer* operator->() const;
	};

	class IRecommendedTextureSizeCalculator; // forward declaration of the interface

	/**
	 * spRecommendedTextureSizeCalculator is the accessor for the IRecommendedTextureSizeCalculator 
	 * interface. Estimates a coarse recommended UV size (width and height) for a geometry 
	 * based on only its surface area and either the distance it is allowed to deviate 
	 * or its intended on screen size. The UVs are assumed to be unique i.e. not tiled/repeated. 
	 * RecommendedWidth and RecommendedHeight will only differ from each other if ForcePower2Texture 
	 * is enabled. 
	 */
	class spRecommendedTextureSizeCalculator : public spObject
	{
		public:
		spRecommendedTextureSizeCalculator(IRecommendedTextureSizeCalculator* p = nullptr);
		spRecommendedTextureSizeCalculator( const spRecommendedTextureSizeCalculator &p );
		spRecommendedTextureSizeCalculator & operator=( const spRecommendedTextureSizeCalculator &p );
		static spRecommendedTextureSizeCalculator SafeCast(spObject other);
		IRecommendedTextureSizeCalculator* operator->() const;
	};

	class IPartRemover; // forward declaration of the interface

	/**
	 * spPartRemover is the accessor for the IPartRemover interface. The PartRemover 
	 * tool can identify unconnected sub-meshes, and remove meshes that fall below 
	 * a set size threshold. This size threshold can be set globally for the entire 
	 * geometry, or per-material to be able to remove things like decals effectively. 
	 */
	class spPartRemover : public spObject
	{
		public:
		spPartRemover(IPartRemover* p = nullptr);
		spPartRemover( const spPartRemover &p );
		spPartRemover & operator=( const spPartRemover &p );
		static spPartRemover SafeCast(spObject other);
		IPartRemover* operator->() const;
	};

	class IWelder; // forward declaration of the interface

	/**
	 * spWelder is the accessor for the IWelder interface. Welds vertices within the 
	 * geometry or scene together. 
	 */
	class spWelder : public spProcessingObject
	{
		public:
		spWelder(IWelder* p = nullptr);
		spWelder( const spWelder &p );
		spWelder & operator=( const spWelder &p );
		static spWelder SafeCast(spObject other);
		IWelder* operator->() const;
	};

	class ITJunctionEliminator; // forward declaration of the interface

	/**
	 * spTJunctionEliminator is the accessor for the ITJunctionEliminator interface. 
	 * Removes t-junctions by subdividing triangles and welding vertices 
	 */
	class spTJunctionEliminator : public spObject
	{
		public:
		spTJunctionEliminator(ITJunctionEliminator* p = nullptr);
		spTJunctionEliminator( const spTJunctionEliminator &p );
		spTJunctionEliminator & operator=( const spTJunctionEliminator &p );
		static spTJunctionEliminator SafeCast(spObject other);
		ITJunctionEliminator* operator->() const;
	};

	class IPipeline; // forward declaration of the interface

	/**
	 * spPipeline is the accessor for the IPipeline interface. Pipeline is the interface 
	 * for a processing pipeline, which applies a number of processing opearations 
	 * on an input scene to generate an output scene. The input and output scenes can 
	 * be any file format supported by Simplygon. 
	 */
	class spPipeline : public spObject
	{
		public:
		spPipeline(IPipeline* p = nullptr);
		spPipeline( const spPipeline &p );
		spPipeline & operator=( const spPipeline &p );
		static spPipeline SafeCast(spObject other);
		IPipeline* operator->() const;
	};

	class IPipelineBatch; // forward declaration of the interface

	/**
	 * spPipelineBatch is the accessor for the IPipelineBatch interface. Control object 
	 * to launch pipelines in batches, both locally and distributed 
	 */
	class spPipelineBatch : public spObject
	{
		public:
		spPipelineBatch(IPipelineBatch* p = nullptr);
		spPipelineBatch( const spPipelineBatch &p );
		spPipelineBatch & operator=( const spPipelineBatch &p );
		static spPipelineBatch SafeCast(spObject other);
		IPipelineBatch* operator->() const;
	};

	class IPipelineSerializer; // forward declaration of the interface

	/**
	 * spPipelineSerializer is the accessor for the IPipelineSerializer interface. 
	 *  
	 */
	class spPipelineSerializer : public spObject
	{
		public:
		spPipelineSerializer(IPipelineSerializer* p = nullptr);
		spPipelineSerializer( const spPipelineSerializer &p );
		spPipelineSerializer & operator=( const spPipelineSerializer &p );
		static spPipelineSerializer SafeCast(spObject other);
		IPipelineSerializer* operator->() const;
	};

	class IReductionPipeline; // forward declaration of the interface

	/**
	 * spReductionPipeline is the accessor for the IReductionPipeline interface. ReductionPipeline 
	 * provides a pipeline for a single reduction processor to be applied on the input 
	 * scene. 
	 */
	class spReductionPipeline : public spPipeline
	{
		public:
		spReductionPipeline(IReductionPipeline* p = nullptr);
		spReductionPipeline( const spReductionPipeline &p );
		spReductionPipeline & operator=( const spReductionPipeline &p );
		static spReductionPipeline SafeCast(spObject other);
		IReductionPipeline* operator->() const;
	};

	class IRemeshingLegacyPipeline; // forward declaration of the interface

	/**
	 * spRemeshingLegacyPipeline is the accessor for the IRemeshingLegacyPipeline interface. 
	 * RemeshingLegacyPipeline provides a pipeline for a single remeshing legacy processor 
	 * to be applied on the input scene. 
	 */
	class spRemeshingLegacyPipeline : public spPipeline
	{
		public:
		spRemeshingLegacyPipeline(IRemeshingLegacyPipeline* p = nullptr);
		spRemeshingLegacyPipeline( const spRemeshingLegacyPipeline &p );
		spRemeshingLegacyPipeline & operator=( const spRemeshingLegacyPipeline &p );
		static spRemeshingLegacyPipeline SafeCast(spObject other);
		IRemeshingLegacyPipeline* operator->() const;
	};

	class IAggregationPipeline; // forward declaration of the interface

	/**
	 * spAggregationPipeline is the accessor for the IAggregationPipeline interface. 
	 * AggregationPipeline provides a pipeline for a single aggregation processor to 
	 * be applied on the input scene. 
	 */
	class spAggregationPipeline : public spPipeline
	{
		public:
		spAggregationPipeline(IAggregationPipeline* p = nullptr);
		spAggregationPipeline( const spAggregationPipeline &p );
		spAggregationPipeline & operator=( const spAggregationPipeline &p );
		static spAggregationPipeline SafeCast(spObject other);
		IAggregationPipeline* operator->() const;
	};

	class IPipelineSettings; // forward declaration of the interface

	/**
	 * spPipelineSettings is the accessor for the IPipelineSettings interface. PipelineSettings 
	 * is the interface used to manage settings for a pipeline 
	 */
	class spPipelineSettings : public spSettingsObject
	{
		public:
		spPipelineSettings(IPipelineSettings* p = nullptr);
		spPipelineSettings( const spPipelineSettings &p );
		spPipelineSettings & operator=( const spPipelineSettings &p );
		static spPipelineSettings SafeCast(spObject other);
		IPipelineSettings* operator->() const;
	};

	class IRemeshingPipeline; // forward declaration of the interface

	/**
	 * spRemeshingPipeline is the accessor for the IRemeshingPipeline interface. RemeshingPipeline 
	 * provides a pipeline for a single remeshing processor to be applied on the input 
	 * scene. 
	 */
	class spRemeshingPipeline : public spPipeline
	{
		public:
		spRemeshingPipeline(IRemeshingPipeline* p = nullptr);
		spRemeshingPipeline( const spRemeshingPipeline &p );
		spRemeshingPipeline & operator=( const spRemeshingPipeline &p );
		static spRemeshingPipeline SafeCast(spObject other);
		IRemeshingPipeline* operator->() const;
	};

	class IPassthroughPipeline; // forward declaration of the interface

	/**
	 * spPassthroughPipeline is the accessor for the IPassthroughPipeline interface. 
	 * PassthroughPipeline provides an empty pipeline for creating a cascading pipeline 
	 * using a single dummy root node. It does not process the input scene in any way. 
	 */
	class spPassthroughPipeline : public spPipeline
	{
		public:
		spPassthroughPipeline(IPassthroughPipeline* p = nullptr);
		spPassthroughPipeline( const spPassthroughPipeline &p );
		spPassthroughPipeline & operator=( const spPassthroughPipeline &p );
		static spPassthroughPipeline SafeCast(spObject other);
		IPassthroughPipeline* operator->() const;
	};

	class IGeometryDataCaster; // forward declaration of the interface

	/**
	 * spGeometryDataCaster is the accessor for the IGeometryDataCaster interface. 
	 * GeometryDataCaster is used to cast original GeometryData information to an image 
	 * using mapping image 
	 */
	class spGeometryDataCaster : public spMaterialCaster
	{
		public:
		spGeometryDataCaster(IGeometryDataCaster* p = nullptr);
		spGeometryDataCaster( const spGeometryDataCaster &p );
		spGeometryDataCaster & operator=( const spGeometryDataCaster &p );
		static spGeometryDataCaster SafeCast(spObject other);
		IGeometryDataCaster* operator->() const;
	};

	class IGeometryDataCasterSettings; // forward declaration of the interface

	/**
	 * spGeometryDataCasterSettings is the accessor for the IGeometryDataCasterSettings 
	 * interface. GeometryDataCasterSettings is the interface used to manage settings 
	 * for GeometryDataCaster 
	 */
	class spGeometryDataCasterSettings : public spMaterialCasterSettings
	{
		public:
		spGeometryDataCasterSettings(IGeometryDataCasterSettings* p = nullptr);
		spGeometryDataCasterSettings( const spGeometryDataCasterSettings &p );
		spGeometryDataCasterSettings & operator=( const spGeometryDataCasterSettings &p );
		static spGeometryDataCasterSettings SafeCast(spObject other);
		IGeometryDataCasterSettings* operator->() const;
	};

	class IVertexWeightSettings; // forward declaration of the interface

	/**
	 * spVertexWeightSettings is the accessor for the IVertexWeightSettings interface. 
	 * This settings object contains all settings related to how the user-set weighting 
	 * field "VertexWeights" is setup and used in different contexts. The values in 
	 * the field can be considered an "importance" factor. Generally, weights set to 
	 * 1.0 are handled normally, values >1.0 are given greater importance, and values 
	 * <1.0 are given less. These weights can either be manually set in the input geometry 
	 * data or converted from vertex color sets using the WeightsFromColor settings. 
	 * See the documentation of the WeightsFromColorMode property to see the details 
	 * of how color intensity is mapped to vertex weight. Vertex weights can be used 
	 * to reduce more or less aggressively on different parts of the mesh, or used 
	 * to scale UV allocation in the parameterizers to give more or less texture area 
	 * to different areas. 
	 */
	class spVertexWeightSettings : public spSettingsObject
	{
		public:
		spVertexWeightSettings(IVertexWeightSettings* p = nullptr);
		spVertexWeightSettings( const spVertexWeightSettings &p );
		spVertexWeightSettings & operator=( const spVertexWeightSettings &p );
		static spVertexWeightSettings SafeCast(spObject other);
		IVertexWeightSettings* operator->() const;
	};

	class IGenerateLightmapTexCoordSettings; // forward declaration of the interface

	/**
	 * spGenerateLightmapTexCoordSettings is the accessor for the IGenerateLightmapTexCoordSettings 
	 * interface. GenerateLightmapTexCoordSettings is the interface used to manage 
	 * light map uv generation. 
	 */
	class spGenerateLightmapTexCoordSettings : public spSettingsObject
	{
		public:
		spGenerateLightmapTexCoordSettings(IGenerateLightmapTexCoordSettings* p = nullptr);
		spGenerateLightmapTexCoordSettings( const spGenerateLightmapTexCoordSettings &p );
		spGenerateLightmapTexCoordSettings & operator=( const spGenerateLightmapTexCoordSettings &p );
		static spGenerateLightmapTexCoordSettings SafeCast(spObject other);
		IGenerateLightmapTexCoordSettings* operator->() const;
	};

	class IChartAggregatorSettings; // forward declaration of the interface

	/**
	 * spChartAggregatorSettings is the accessor for the IChartAggregatorSettings interface. 
	 * Settings for the chart aggregator. 
	 */
	class spChartAggregatorSettings : public spSettingsObject
	{
		public:
		spChartAggregatorSettings(IChartAggregatorSettings* p = nullptr);
		spChartAggregatorSettings( const spChartAggregatorSettings &p );
		spChartAggregatorSettings & operator=( const spChartAggregatorSettings &p );
		static spChartAggregatorSettings SafeCast(spObject other);
		IChartAggregatorSettings* operator->() const;
	};

	class IParameterizerSettings; // forward declaration of the interface

	/**
	 * spParameterizerSettings is the accessor for the IParameterizerSettings interface. 
	 * Settings for the parameterizer. 
	 */
	class spParameterizerSettings : public spSettingsObject
	{
		public:
		spParameterizerSettings(IParameterizerSettings* p = nullptr);
		spParameterizerSettings( const spParameterizerSettings &p );
		spParameterizerSettings & operator=( const spParameterizerSettings &p );
		static spParameterizerSettings SafeCast(spObject other);
		IParameterizerSettings* operator->() const;
	};

	class IBillboardCloudSettings; // forward declaration of the interface

	/**
	 * spBillboardCloudSettings is the accessor for the IBillboardCloudSettings interface. 
	 * Settings for the ImpostorType: BillboardCloud 
	 */
	class spBillboardCloudSettings : public spSettingsObject
	{
		public:
		spBillboardCloudSettings(IBillboardCloudSettings* p = nullptr);
		spBillboardCloudSettings( const spBillboardCloudSettings &p );
		spBillboardCloudSettings & operator=( const spBillboardCloudSettings &p );
		static spBillboardCloudSettings SafeCast(spObject other);
		IBillboardCloudSettings* operator->() const;
	};

	class IFlipbookSettings; // forward declaration of the interface

	/**
	 * spFlipbookSettings is the accessor for the IFlipbookSettings interface. Settings 
	 * for the ImpostorType: FlipBook 
	 */
	class spFlipbookSettings : public spSettingsObject
	{
		public:
		spFlipbookSettings(IFlipbookSettings* p = nullptr);
		spFlipbookSettings( const spFlipbookSettings &p );
		spFlipbookSettings & operator=( const spFlipbookSettings &p );
		static spFlipbookSettings SafeCast(spObject other);
		IFlipbookSettings* operator->() const;
	};

	class IImpostorFromSingleViewSettings; // forward declaration of the interface

	/**
	 * spImpostorFromSingleViewSettings is the accessor for the IImpostorFromSingleViewSettings 
	 * interface. Settings for the ImpostorType: ImpostorFromSingleView. 
	 */
	class spImpostorFromSingleViewSettings : public spSettingsObject
	{
		public:
		spImpostorFromSingleViewSettings(IImpostorFromSingleViewSettings* p = nullptr);
		spImpostorFromSingleViewSettings( const spImpostorFromSingleViewSettings &p );
		spImpostorFromSingleViewSettings & operator=( const spImpostorFromSingleViewSettings &p );
		static spImpostorFromSingleViewSettings SafeCast(spObject other);
		IImpostorFromSingleViewSettings* operator->() const;
	};

	class IImpostorFromSingleViewPipeline; // forward declaration of the interface

	/**
	 * spImpostorFromSingleViewPipeline is the accessor for the IImpostorFromSingleViewPipeline 
	 * interface. ImpostorFromSingleViewPipeline provides a pipeline for a impostor 
	 * from single view impostor processor to be applied on the input scene. 
	 */
	class spImpostorFromSingleViewPipeline : public spPipeline
	{
		public:
		spImpostorFromSingleViewPipeline(IImpostorFromSingleViewPipeline* p = nullptr);
		spImpostorFromSingleViewPipeline( const spImpostorFromSingleViewPipeline &p );
		spImpostorFromSingleViewPipeline & operator=( const spImpostorFromSingleViewPipeline &p );
		static spImpostorFromSingleViewPipeline SafeCast(spObject other);
		IImpostorFromSingleViewPipeline* operator->() const;
	};

	class IBillboardCloudPipeline; // forward declaration of the interface

	/**
	 * spBillboardCloudPipeline is the accessor for the IBillboardCloudPipeline interface. 
	 * BillboardCloudPipeline provides a pipeline for a billboard cloud impostor processor 
	 * to be applied on the input scene. 
	 */
	class spBillboardCloudPipeline : public spPipeline
	{
		public:
		spBillboardCloudPipeline(IBillboardCloudPipeline* p = nullptr);
		spBillboardCloudPipeline( const spBillboardCloudPipeline &p );
		spBillboardCloudPipeline & operator=( const spBillboardCloudPipeline &p );
		static spBillboardCloudPipeline SafeCast(spObject other);
		IBillboardCloudPipeline* operator->() const;
	};

	class IBillboardCloudVegetationPipeline; // forward declaration of the interface

	/**
	 * spBillboardCloudVegetationPipeline is the accessor for the IBillboardCloudVegetationPipeline 
	 * interface. BillboardCloudPipeline provides a pipeline for a billboard cloud 
	 * vegetation impostor processor to be applied on the input scene. 
	 */
	class spBillboardCloudVegetationPipeline : public spPipeline
	{
		public:
		spBillboardCloudVegetationPipeline(IBillboardCloudVegetationPipeline* p = nullptr);
		spBillboardCloudVegetationPipeline( const spBillboardCloudVegetationPipeline &p );
		spBillboardCloudVegetationPipeline & operator=( const spBillboardCloudVegetationPipeline &p );
		static spBillboardCloudVegetationPipeline SafeCast(spObject other);
		IBillboardCloudVegetationPipeline* operator->() const;
	};

	class IFlipbookPipeline; // forward declaration of the interface

	/**
	 * spFlipbookPipeline is the accessor for the IFlipbookPipeline interface. FlipbookPipeline 
	 * provides a pipeline for a flipbook impostor processor to be applied on the input 
	 * scene. 
	 */
	class spFlipbookPipeline : public spPipeline
	{
		public:
		spFlipbookPipeline(IFlipbookPipeline* p = nullptr);
		spFlipbookPipeline( const spFlipbookPipeline &p );
		spFlipbookPipeline & operator=( const spFlipbookPipeline &p );
		static spFlipbookPipeline SafeCast(spObject other);
		IFlipbookPipeline* operator->() const;
	};

	class IFoliageSettings; // forward declaration of the interface

	/**
	 * spFoliageSettings is the accessor for the IFoliageSettings interface. Settings 
	 * for the BillboardMode: Foliage 
	 */
	class spFoliageSettings : public spSettingsObject
	{
		public:
		spFoliageSettings(IFoliageSettings* p = nullptr);
		spFoliageSettings( const spFoliageSettings &p );
		spFoliageSettings & operator=( const spFoliageSettings &p );
		static spFoliageSettings SafeCast(spObject other);
		IFoliageSettings* operator->() const;
	};

	class IStringArray; // forward declaration of the interface

	/**
	 * spStringArray is the accessor for the IStringArray interface. StringArray is 
	 * the string implementation of ValueArray. See ValueArray for a description. 
	 */
	class spStringArray : public spValueArray
	{
		public:
		spStringArray(IStringArray* p = nullptr);
		spStringArray( const spStringArray &p );
		spStringArray & operator=( const spStringArray &p );
		static spStringArray SafeCast(spObject other);
		IStringArray* operator->() const;
	};

	class IOcclusionMeshPipeline; // forward declaration of the interface

	/**
	 * spOcclusionMeshPipeline is the accessor for the IOcclusionMeshPipeline interface. 
	 * OcclusionMeshPipeline provides a pipeline for a single occlusion mesh processor 
	 * to be applied on the input scene. 
	 */
	class spOcclusionMeshPipeline : public spPipeline
	{
		public:
		spOcclusionMeshPipeline(IOcclusionMeshPipeline* p = nullptr);
		spOcclusionMeshPipeline( const spOcclusionMeshPipeline &p );
		spOcclusionMeshPipeline & operator=( const spOcclusionMeshPipeline &p );
		static spOcclusionMeshPipeline SafeCast(spObject other);
		IOcclusionMeshPipeline* operator->() const;
	};


	/**
	 * IObject is the base interface for all API interfaces defined within the API. The interfaces adds safe casting into any API object, reference counting support
	 * (best used with the CountedPointer reference counted pointer class), basic names for all objects, and event handling, using observers (using objects
	 * derived from Observer)
	 */
	class IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a spString
		 */
		virtual spString GetClass();
		
		/** 
		 * The IsA function returns true if the object is a or is a descendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a descendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const char *type ) const;
		
		/**
		 * The IsClassA function returns true if the class is a or is a descendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a descendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const char *type )
		{
			if( type && (strcmp("IObject",type)==0) )
				return true;
			return false;
		}

		/** 
		* SafeCast makes sure the pointer is of a class that can be cast into IObject, and if this is the case, returns the pointer cast into an IObject 
		* @param ptr is the pointer to be cast into a pointer to an object of type IObject
		* @return a pointer to IObject, if the cast can be made
		*/
		static IObject *SafeCast( IObject *ptr ) { return ptr; }

		/**
		 * PrintInfo prints the contents/info of the object to the log
		 */
		virtual void PrintInfo() = 0;

		/**
		 * Adds one reference to the object.
		 */
		virtual void AddRef() = 0;

		/**
		 * Releases one reference to the object. When all references have been removed, the object is removed from memory.
		 */
		virtual void Release() = 0;

		/** 
		 * Sets the name of the object.
		 * @param Name is the new name of the object
		 */
		virtual void SetName( const char *Name ) = 0;

		/** 
		 * Gets the name of the object.
		 * @return The name of the object
		 */
		virtual spString GetName() = 0;

		/** 
		 * Adds a user-defined observer object to the interface, that will receive events from the interface.
		 * @param observer is the object that will receive events
		 * @return the id of the observer within the API object
		 */
		virtual rid AddObserver( Simplygon::Observer *observer ) = 0;

		/** 
		 * Removes a previously added observer object
		 * @param observerId the id returned by AddObserver when the observer was added
		 */
		virtual void RemoveObserver( rid observerId ) = 0;

		virtual void *GetUserComponentArea( rid userid ) = 0;

		virtual void SetUserData( const char* name, const void* data, unsigned int size );
		virtual spUnsignedCharData GetUserData( const char* name );
	};

	class IRidArray;

	/**
	 * Array is the base class for the array objects. The object contains a dynamically 
	 * allocated list of tuples of the same length, which can be specified before the 
	 * list is filled with values. 
	 */
	class IArray : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IArray is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IArray",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IArray 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IArray pointer 
		 * @return a pointer to the IArray object, if the cast can be made, and a NULL 
		 * pointer otherwise 
		 */

		static IArray *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IArray") )
				return static_cast<IArray*>(ptr);
			return nullptr;
		}
		/**
		 * Creates a new array with the same underlying data type, size and tuple settings 
		 * as this array. To also copy the actual data, set copy_data to true. 
		 * @param copy_data If set, duplicate all the data. If cleared, return an empty 
		 * array of the same type. 
		 */
		virtual	spArray NewCopy( bool copy_data ) = 0;

		/**
		 * Like NewCopy, NewPackedCopy creates an array with the same underlying data 
		 * and tuple settings as the source array. However, NewPackedCopy only copies 
		 * unique tuples, and if the index_array parameter is set, this index array will 
		 * contain the same number of tuples as the source array, and with the ids of 
		 * a specific tuples within the new copy of the array. 
		 * @param index_array The optional array that will receive the indices of the 
		 * remapped tuples. 
		 */
		virtual	spArray NewPackedCopy( spRidArray index_array ) = 0;

		/**
		 * Copies data from another array. The arrays must have the same underlying data 
		 * types. 
		 * @param source The source array to copy from. Value cannot be equal to null. 
		 *  
		 */
		virtual	void DeepCopy( spArray source ) = 0;

		/**
		 * Copies tuples from a source array through an id table. The id table dictates 
		 * the order in which the tuples are to be copied to this array. E.g. If the first 
		 * item in the id table has the value 14, then the tuple with id 14 in the source 
		 * array will be copied to the first tuple in this array. Note: All ids in the 
		 * id table must be valid ids of tuples in the source array. The id table is assumed 
		 * to have a tuple size of 1. The source array and this array must have the same 
		 * underlying data type, and have the same tuple size. The array must be large 
		 * enough to hold the copied data. 
		 * @param source The array from which to copy tuples. Value cannot be equal to 
		 * null. 
		 * @param idtable The array with the tuple indices to copy. Value cannot be equal 
		 * to null. 
		 * @param startId The first tuple that will receive the copied values. 
		 */
		virtual	void IndexedCopy( spArray source , spRidArray idtable , rid startId ) = 0;

		/**
		 * The tuple size, meaning how many items of the underlying data type is in a 
		 * tuple. The tuple size must be set before the array is populated. 
		 * @param value The desired tuple size. Value cannot be less than 1. Value cannot 
		 * be greater than 1024. 
		 */
		virtual	void SetTupleSize( unsigned int value ) = 0;

		/**
		 * The tuple size, meaning how many items of the underlying data type is in a 
		 * tuple. The tuple size must be set before the array is populated. 
		 */
		virtual	unsigned int GetTupleSize(  ) = 0;

		/**
		 * The number of individual items in the array. Warning! Do not confuse this count 
		 * with the count of tuples, they are only the same if TupleSize is equal to 1, 
		 * i.e. when the tuples are exactly one component each. Also note that the item 
		 * count should be a multiple of TupleSize. Note that the total number of items 
		 * cannotexceed INT_MAX. 
		 * @param value The desired item count. Value cannot be less than 1. Value cannot 
		 * be greater than INT_MAX. 
		 */
		virtual	void SetItemCount( unsigned int value ) = 0;

		/**
		 * The number of individual items in the array. Warning! Do not confuse this count 
		 * with the count of tuples, they are only the same if TupleSize is equal to 1, 
		 * i.e. when the tuples are exactly one component each. Also note that the item 
		 * count should be a multiple of TupleSize. Note that the total number of items 
		 * cannotexceed INT_MAX. 
		 */
		virtual	unsigned int GetItemCount(  ) = 0;

		/**
		 * Returns the id of the last item that is in the array. The id returned is equal 
		 * to (ItemCount - 1). Warning! Do not confuse this id with the id of a tuple, 
		 * they are only the same if TupleSize is equal to one, i.e. when the tuples are 
		 * exactly one component each. 
		 */
		virtual	rid GetMaxItemId(  ) = 0;

		/**
		 * Clears the array and sets the tuple count to 0. Tuple size and name remains 
		 * the same though. 
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Returns true if the list is empty. 
		 */
		virtual	bool IsEmpty(  ) = 0;

		/**
		 * The tuple count, meaning how many tuples are in the array. If resized to larger 
		 * array, the new tuples will not be set to anything. 
		 * @param value The desired tuple count. Value cannot be less than 1. Value cannot 
		 * be greater than INT_MAX. 
		 */
		virtual	void SetTupleCount( unsigned int value ) = 0;

		/**
		 * The tuple count, meaning how many tuples are in the array. If resized to larger 
		 * array, the new tuples will not be set to anything. 
		 */
		virtual	unsigned int GetTupleCount(  ) = 0;

		/**
		 * Returns the id of the tuple last in the list. If the array is empty, the value 
		 * is unspecified. Note: GetMaxTupleId() always returns (GetTupleCount()-1) as 
		 * a signed id. 
		 */
		virtual	rid GetMaxTupleId(  ) = 0;

		/**
		 * Returns the id of the basic type that the array is based on The ids are listed 
		 * in the BaseTypes enumeration. 
		 */
		virtual	Simplygon::EBaseTypes GetBaseType(  ) = 0;

		/**
		 * Appends an array to this array. The array must be a descendant of ValueArray. 
		 * For best performance, append arrays of the same basic type. 
		 * @param source The array to append to this array. Value cannot be equal to null. 
		 *  
		 */
		virtual	void AppendArray( spArray source ) = 0;

		/**
		 * Extracts tuples from the array. Note that the destination array must have the 
		 * same classtype and have the same tuple size as the source array. (If both arrays 
		 * are decendants of ValueArray, they can be of different types, but the conversion 
		 * is slow). 
		 * @param dest The array that will store the extracted tuples. Value cannot be 
		 * equal to null. 
		 * @param start This array tuple index where the extraction starts. Value cannot 
		 * be less than 0. Value cannot be greater than the value returned by GetMaxTupleId(). 
		 *  
		 * @param count The number of tuples to extract. Value cannot be greater than 
		 * INT_MAX. 
		 */
		virtual	void ExtractTuples( spArray dest , rid start , unsigned int count ) = 0;

		/**
		 * CopyTuple copies one tuple in a source array to a tuple in this array. Both 
		 * the dest_id and the source_id must exist in the arrays. This array can be used 
		 * as the source array to copy within the array. 
		 * @param sourceArray The source array to copy from. Value cannot be equal to 
		 * null. 
		 * @param dest_id The tuple index in this array to copy into. Value cannot be 
		 * less than 0. Value cannot be greater than the value returned by GetMaxTupleId(). 
		 *  
		 * @param src_id The tuple index in the source array to copy from. Value cannot 
		 * be less than 0. 
		 */
		virtual	void CopyTuple( spArray sourceArray , rid dest_id , rid src_id ) = 0;

		/**
		 * CompareTuples compares a tuple in this array with a tuple in another array. 
		 * Returns 0 if the tuples are identical, 1 if an element in this array tuple 
		 * in ascending order is larger and -1 if smaller. 
		 * @param otherArray The other array to compare with. Value cannot be equal to 
		 * null. 
		 * @param tuple_id The tuple from this array to use for comparison. Value cannot 
		 * be less than 0. Value cannot be greater than the value returned by GetMaxTupleId(). 
		 *  
		 * @param other_tuple_id The tuple from the other array to use for comparison. 
		 * Value cannot be less than 0. 
		 */
		virtual	int CompareTuples( spArray otherArray , rid tuple_id , rid other_tuple_id ) = 0;

		/**
		 * CopyRange copies a range of tuples from a source array into this array. The 
		 * arrays must have the same tuple size and base type. This array must be resized 
		 * to hold the tuples before copying. The basetypes are listed in EBaseTypes. 
		 * @param source_array The source array to copy from. 
		 * @param start_dest_id The first destination tuple id. 
		 * @param start_src_id The first source tuple id. 
		 * @param count The number of tuples to copy. 
		 */
		virtual	void CopyRange( spArray source_array , rid start_dest_id , rid start_src_id , unsigned int count ) = 0;

		/**
		 * A string that can be used to identify the array in collections. 
		 * @param value The new alternative name. 
		 */
		virtual	void SetAlternativeName( const char * value ) = 0;

		/**
		 * A string that can be used to identify the array in collections. 
		 */
		virtual	spString GetAlternativeName(  ) = 0;

	};

	/**
	 * ValueArray adds methods to arrays to generically add, set and get tuples, through 
	 * real values. 
	 */
	class IValueArray : public IArray
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IValueArray is a or is a descendant of 
		 * the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IValueArray",type)==0 )
				return true;
			return IArray::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IValueArray 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IValueArray pointer 
		 * @return a pointer to the IValueArray object, if the cast can be made, and a 
		 * NULL pointer otherwise 
		 */

		static IValueArray *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IValueArray") )
				return static_cast<IValueArray*>(ptr);
			return nullptr;
		}
		/**
		 * SetRealItem() sets the item at position id. The id is the id of the item, not 
		 * the tuple the item belongs to. SetRealItem() converts the value from real to 
		 * the actual underlying data type. 
		 * @param id The item to set. Value cannot be less than 0. Value cannot be greater 
		 * than the value returned by GetMaxItemId(). 
		 * @param value The real value to set the item to. 
		 */
		virtual	void SetRealItem( rid id , real value ) = 0;

		/**
		 * GetRealItem() retrieves the item at position id. The id is the id of the item, 
		 * not the tuple the item belongs to. GetRealItem() converts the value from the 
		 * actual underlying data type to a real. 
		 * @param id The item to get. Value cannot be less than 0. Value cannot be greater 
		 * than the value returned by GetMaxItemId(). 
		 * @return the converted real value of the item. 
		 */
		virtual	real GetRealItem( rid id ) = 0;

	};

	/**
	 * BoolArray is the bool implementation of ValueArray. See ValueArray for a description. 
	 */
	class IBoolArray : public IValueArray
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IBoolArray is a or is a descendant of 
		 * the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IBoolArray",type)==0 )
				return true;
			return IValueArray::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IBoolArray 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IBoolArray pointer 
		 * @return a pointer to the IBoolArray object, if the cast can be made, and a 
		 * NULL pointer otherwise 
		 */

		static IBoolArray *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IBoolArray") )
				return static_cast<IBoolArray*>(ptr);
			return nullptr;
		}
		/**
		 * Adds an item to the list, allocates memory as needed to enlarge the list. If 
		 * many items are being put into the list, use Resize to set the size of the new 
		 * list (only one reallocation needed) and then use SetItem() / SetTuple() to 
		 * set the items directly. 
		 * @param value The value of the item. 
		 */
		virtual	void AddItem( bool value ) = 0;

		/**
		 * Sets an item in the list. The id of the item is the exact location of the item 
		 * (TupleId * TupleSize + Index of item in tuple) Warning! No range checking is 
		 * done. 
		 * @param id The id of the item. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxItemId(). 
		 * @param value The new value of the item. 
		 */
		virtual	void SetItem( rid id , bool value ) = 0;

		/**
		 * Gets the value of an item in the list. The id of the item is the exact location 
		 * of the item (TupleId * TupleSize + Index of item in tuple) Warning! No range 
		 * checking is done. 
		 * @param id The id of the item. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxItemId(). 
		 */
		virtual	bool GetItem( rid id ) = 0;

		/**
		 * Adds a tuple to the list. Reallocates the list if needed. If many items are 
		 * being put into the list, use Resize to set the size of the new list (only one 
		 * reallocation needed) and then use SetItem() / SetRealTuple() to set the items 
		 * directly. 
		 * @param tuple_boolInputDataPtr The value(s) of the tuple. 
		 */
		virtual	void AddTuple( const bool *tuple_boolInputDataPtr ) = 0;

		/**
		 * Sets a tuple in the list. The id is the id of the tuple that is being updated. 
		 * Warning! No range checking is done. 
		 * @param id The id of the tuple. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxTupleId(). 
		 * @param tuple_boolInputDataPtr The new value(s) of the tuple. 
		 */
		virtual	void SetTuple( rid id , const bool *tuple_boolInputDataPtr ) = 0;

		/**
		 * Gets a tuple in the list. The id is the id of the tuple that is being fetched. 
		 * Warning! No range checking is done. 
		 * @param id The id of the tuple. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxTupleId(). 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spBoolData GetTuple( rid id ) = 0;

		/**
		 * Returns all tuples in the array as a single item array. 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spBoolData GetData(  ) = 0;

		/**
		 * Returns a range of tuples in the array. 
		 * @param start_tuple_id The first id in the range. Value cannot be less than 
		 * 0. Value cannot be greater than the value returned by GetMaxTupleId(). 
		 * @param tuple_count The number of tuples in the range. 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spBoolData GetDataRange( rid start_tuple_id , unsigned int tuple_count ) = 0;

		/**
		 * Set the array from a range of data values. Note that the array will be resized 
		 * to the size of the items. Note that the source_item_count is the number of 
		 * items to set, NOT the number of tuples. 
		 * @param source_items_boolInputDataPtr The array to copy from. Value cannot be 
		 * equal to null. 
		 * @param source_item_count The number of items in the array. 
		 */
		virtual	void SetData( const bool *source_items_boolInputDataPtr , unsigned int source_item_count ) = 0;

		/**
		 * Set a part of the array from a range of data values. Note that the array will 
		 * be resized to contain the size of the items. Note that the source_item_count 
		 * is the number of items to set, NOT the number of tuples, but start_tuple_id 
		 * IS the first tuple index to update. 
		 * @param start_tuple_id where to start copy to in this array. Value cannot be 
		 * less than 0. Value cannot be greater than the value returned by GetMaxTupleId(). 
		 *  
		 * @param source_items_boolInputDataPtr The array to copy from. Value cannot be 
		 * equal to null. 
		 * @param source_item_count The number of items in the array. 
		 */
		virtual	void SetDataRange( rid start_tuple_id , const bool *source_items_boolInputDataPtr , unsigned int source_item_count ) = 0;

		/**
		 * Set the array from a range of data values in a raw memory block. The array 
		 * will be resized to the size of the tuples. Please set the tuple sizebefore 
		 * calling this method. Note! that the source_tuple_count is the number of TUPLES 
		 * to set, not the number of items. Note! This method is intended for advanced 
		 * users who want to get maximum performance. No range checking is done in this 
		 * method, and your code will crash if your read area is not large enough. 
		 * @param mem_area_voidInputDataPtr The array to copy from Value cannot be equal 
		 * to null. 
		 * @param source_tuple_count The number of items in the array 
		 * @param item_stride The number of bytes between the address of an item to the 
		 * address of the next. If items are consecutive in memory, this stride should 
		 * be the size of on item. 
		 * @param tuple_stride The number of bytes between the address of the first item 
		 * in one tuple to the address of the first item in the next tuple. E.g, if the 
		 * items are copied from an array of structs, this stride should be the size of 
		 * one of the struct objects in the array. 
		 */
		virtual	void SetDataFromMemoryPtr( void *mem_area_voidInputDataPtr , unsigned int source_tuple_count , unsigned int item_stride , unsigned int tuple_stride ) = 0;

	};

	/**
	 * CharArray is the char implementation of ValueArray. See ValueArray for a description. 
	 */
	class ICharArray : public IValueArray
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if ICharArray is a or is a descendant of 
		 * the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("ICharArray",type)==0 )
				return true;
			return IValueArray::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a ICharArray 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ICharArray pointer 
		 * @return a pointer to the ICharArray object, if the cast can be made, and a 
		 * NULL pointer otherwise 
		 */

		static ICharArray *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("ICharArray") )
				return static_cast<ICharArray*>(ptr);
			return nullptr;
		}
		/**
		 * Adds an item to the list, allocates memory as needed to enlarge the list. If 
		 * many items are being put into the list, use Resize to set the size of the new 
		 * list (only one reallocation needed) and then use SetItem() / SetTuple() to 
		 * set the items directly. 
		 * @param value The value of the item. 
		 */
		virtual	void AddItem( char value ) = 0;

		/**
		 * Sets an item in the list. The id of the item is the exact location of the item 
		 * (TupleId * TupleSize + Index of item in tuple) Warning! No range checking is 
		 * done. 
		 * @param id The id of the item. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxItemId(). 
		 * @param value The new value of the item. 
		 */
		virtual	void SetItem( rid id , char value ) = 0;

		/**
		 * Gets the value of an item in the list. The id of the item is the exact location 
		 * of the item (TupleId * TupleSize + Index of item in tuple) Warning! No range 
		 * checking is done. 
		 * @param id The id of the item. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxItemId(). 
		 */
		virtual	char GetItem( rid id ) = 0;

		/**
		 * Adds a tuple to the list. Reallocates the list if needed. If many items are 
		 * being put into the list, use Resize to set the size of the new list (only one 
		 * reallocation needed) and then use SetItem() / SetRealTuple() to set the items 
		 * directly. 
		 * @param tuple_charInputDataPtr The value(s) of the tuple. 
		 */
		virtual	void AddTuple( const char *tuple_charInputDataPtr ) = 0;

		/**
		 * Sets a tuple in the list. The id is the id of the tuple that is being updated. 
		 * Warning! No range checking is done. 
		 * @param id The id of the tuple. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxTupleId(). 
		 * @param tuple_charInputDataPtr The new value(s) of the tuple. 
		 */
		virtual	void SetTuple( rid id , const char *tuple_charInputDataPtr ) = 0;

		/**
		 * Gets a tuple in the list. The id is the id of the tuple that is being fetched. 
		 * Warning! No range checking is done. 
		 * @param id The id of the tuple. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxTupleId(). 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spCharData GetTuple( rid id ) = 0;

		/**
		 * Returns all tuples in the array as a single item array. 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spCharData GetData(  ) = 0;

		/**
		 * Returns a range of tuples in the array. 
		 * @param start_tuple_id The first id in the range. Value cannot be less than 
		 * 0. Value cannot be greater than the value returned by GetMaxTupleId(). 
		 * @param tuple_count The number of tuples in the range. 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spCharData GetDataRange( rid start_tuple_id , unsigned int tuple_count ) = 0;

		/**
		 * Set the array from a range of data values. Note that the array will be resized 
		 * to the size of the items. Note that the source_item_count is the number of 
		 * items to set, NOT the number of tuples. 
		 * @param source_items_charInputDataPtr The array to copy from. Value cannot be 
		 * equal to null. 
		 * @param source_item_count The number of items in the array. 
		 */
		virtual	void SetData( const char *source_items_charInputDataPtr , unsigned int source_item_count ) = 0;

		/**
		 * Set a part of the array from a range of data values. Note that the array will 
		 * be resized to contain the size of the items. Note that the source_item_count 
		 * is the number of items to set, NOT the number of tuples, but start_tuple_id 
		 * IS the first tuple index to update. 
		 * @param start_tuple_id where to start copy to in this array. Value cannot be 
		 * less than 0. Value cannot be greater than the value returned by GetMaxTupleId(). 
		 *  
		 * @param source_items_charInputDataPtr The array to copy from. Value cannot be 
		 * equal to null. 
		 * @param source_item_count The number of items in the array. 
		 */
		virtual	void SetDataRange( rid start_tuple_id , const char *source_items_charInputDataPtr , unsigned int source_item_count ) = 0;

		/**
		 * Set the array from a range of data values in a raw memory block. The array 
		 * will be resized to the size of the tuples. Please set the tuple sizebefore 
		 * calling this method. Note! that the source_tuple_count is the number of TUPLES 
		 * to set, not the number of items. Note! This method is intended for advanced 
		 * users who want to get maximum performance. No range checking is done in this 
		 * method, and your code will crash if your read area is not large enough. 
		 * @param mem_area_voidInputDataPtr The array to copy from Value cannot be equal 
		 * to null. 
		 * @param source_tuple_count The number of items in the array 
		 * @param item_stride The number of bytes between the address of an item to the 
		 * address of the next. If items are consecutive in memory, this stride should 
		 * be the size of on item. 
		 * @param tuple_stride The number of bytes between the address of the first item 
		 * in one tuple to the address of the first item in the next tuple. E.g, if the 
		 * items are copied from an array of structs, this stride should be the size of 
		 * one of the struct objects in the array. 
		 */
		virtual	void SetDataFromMemoryPtr( void *mem_area_voidInputDataPtr , unsigned int source_tuple_count , unsigned int item_stride , unsigned int tuple_stride ) = 0;

	};

	/**
	 * DoubleArray is the double implementation of ValueArray. See ValueArray for a 
	 * description. 
	 */
	class IDoubleArray : public IValueArray
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IDoubleArray is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IDoubleArray",type)==0 )
				return true;
			return IValueArray::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IDoubleArray 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IDoubleArray pointer 
		 * @return a pointer to the IDoubleArray object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static IDoubleArray *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IDoubleArray") )
				return static_cast<IDoubleArray*>(ptr);
			return nullptr;
		}
		/**
		 * Adds an item to the list, allocates memory as needed to enlarge the list. If 
		 * many items are being put into the list, use Resize to set the size of the new 
		 * list (only one reallocation needed) and then use SetItem() / SetTuple() to 
		 * set the items directly. 
		 * @param value The value of the item. 
		 */
		virtual	void AddItem( double value ) = 0;

		/**
		 * Sets an item in the list. The id of the item is the exact location of the item 
		 * (TupleId * TupleSize + Index of item in tuple) Warning! No range checking is 
		 * done. 
		 * @param id The id of the item. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxItemId(). 
		 * @param value The new value of the item. 
		 */
		virtual	void SetItem( rid id , double value ) = 0;

		/**
		 * Gets the value of an item in the list. The id of the item is the exact location 
		 * of the item (TupleId * TupleSize + Index of item in tuple) Warning! No range 
		 * checking is done. 
		 * @param id The id of the item. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxItemId(). 
		 */
		virtual	double GetItem( rid id ) = 0;

		/**
		 * Adds a tuple to the list. Reallocates the list if needed. If many items are 
		 * being put into the list, use Resize to set the size of the new list (only one 
		 * reallocation needed) and then use SetItem() / SetRealTuple() to set the items 
		 * directly. 
		 * @param tuple_doubleInputDataPtr The value(s) of the tuple. 
		 */
		virtual	void AddTuple( const double *tuple_doubleInputDataPtr ) = 0;

		/**
		 * Sets a tuple in the list. The id is the id of the tuple that is being updated. 
		 * Warning! No range checking is done. 
		 * @param id The id of the tuple. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxTupleId(). 
		 * @param tuple_doubleInputDataPtr The new value(s) of the tuple. 
		 */
		virtual	void SetTuple( rid id , const double *tuple_doubleInputDataPtr ) = 0;

		/**
		 * Gets a tuple in the list. The id is the id of the tuple that is being fetched. 
		 * Warning! No range checking is done. 
		 * @param id The id of the tuple. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxTupleId(). 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spDoubleData GetTuple( rid id ) = 0;

		/**
		 * Returns all tuples in the array as a single item array. 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spDoubleData GetData(  ) = 0;

		/**
		 * Returns a range of tuples in the array. 
		 * @param start_tuple_id The first id in the range. Value cannot be less than 
		 * 0. Value cannot be greater than the value returned by GetMaxTupleId(). 
		 * @param tuple_count The number of tuples in the range. 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spDoubleData GetDataRange( rid start_tuple_id , unsigned int tuple_count ) = 0;

		/**
		 * Set the array from a range of data values. Note that the array will be resized 
		 * to the size of the items. Note that the source_item_count is the number of 
		 * items to set, NOT the number of tuples. 
		 * @param source_items_doubleInputDataPtr The array to copy from. Value cannot 
		 * be equal to null. 
		 * @param source_item_count The number of items in the array. 
		 */
		virtual	void SetData( const double *source_items_doubleInputDataPtr , unsigned int source_item_count ) = 0;

		/**
		 * Set a part of the array from a range of data values. Note that the array will 
		 * be resized to contain the size of the items. Note that the source_item_count 
		 * is the number of items to set, NOT the number of tuples, but start_tuple_id 
		 * IS the first tuple index to update. 
		 * @param start_tuple_id where to start copy to in this array. Value cannot be 
		 * less than 0. Value cannot be greater than the value returned by GetMaxTupleId(). 
		 *  
		 * @param source_items_doubleInputDataPtr The array to copy from. Value cannot 
		 * be equal to null. 
		 * @param source_item_count The number of items in the array. 
		 */
		virtual	void SetDataRange( rid start_tuple_id , const double *source_items_doubleInputDataPtr , unsigned int source_item_count ) = 0;

		/**
		 * Set the array from a range of data values in a raw memory block. The array 
		 * will be resized to the size of the tuples. Please set the tuple sizebefore 
		 * calling this method. Note! that the source_tuple_count is the number of TUPLES 
		 * to set, not the number of items. Note! This method is intended for advanced 
		 * users who want to get maximum performance. No range checking is done in this 
		 * method, and your code will crash if your read area is not large enough. 
		 * @param mem_area_voidInputDataPtr The array to copy from Value cannot be equal 
		 * to null. 
		 * @param source_tuple_count The number of items in the array 
		 * @param item_stride The number of bytes between the address of an item to the 
		 * address of the next. If items are consecutive in memory, this stride should 
		 * be the size of on item. 
		 * @param tuple_stride The number of bytes between the address of the first item 
		 * in one tuple to the address of the first item in the next tuple. E.g, if the 
		 * items are copied from an array of structs, this stride should be the size of 
		 * one of the struct objects in the array. 
		 */
		virtual	void SetDataFromMemoryPtr( void *mem_area_voidInputDataPtr , unsigned int source_tuple_count , unsigned int item_stride , unsigned int tuple_stride ) = 0;

	};

	/**
	 * FloatArray is the float implementation of ValueArray. See ValueArray for a description. 
	 */
	class IFloatArray : public IValueArray
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IFloatArray is a or is a descendant of 
		 * the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IFloatArray",type)==0 )
				return true;
			return IValueArray::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IFloatArray 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IFloatArray pointer 
		 * @return a pointer to the IFloatArray object, if the cast can be made, and a 
		 * NULL pointer otherwise 
		 */

		static IFloatArray *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IFloatArray") )
				return static_cast<IFloatArray*>(ptr);
			return nullptr;
		}
		/**
		 * Adds an item to the list, allocates memory as needed to enlarge the list. If 
		 * many items are being put into the list, use Resize to set the size of the new 
		 * list (only one reallocation needed) and then use SetItem() / SetTuple() to 
		 * set the items directly. 
		 * @param value The value of the item. 
		 */
		virtual	void AddItem( float value ) = 0;

		/**
		 * Sets an item in the list. The id of the item is the exact location of the item 
		 * (TupleId * TupleSize + Index of item in tuple) Warning! No range checking is 
		 * done. 
		 * @param id The id of the item. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxItemId(). 
		 * @param value The new value of the item. 
		 */
		virtual	void SetItem( rid id , float value ) = 0;

		/**
		 * Gets the value of an item in the list. The id of the item is the exact location 
		 * of the item (TupleId * TupleSize + Index of item in tuple) Warning! No range 
		 * checking is done. 
		 * @param id The id of the item. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxItemId(). 
		 */
		virtual	float GetItem( rid id ) = 0;

		/**
		 * Adds a tuple to the list. Reallocates the list if needed. If many items are 
		 * being put into the list, use Resize to set the size of the new list (only one 
		 * reallocation needed) and then use SetItem() / SetRealTuple() to set the items 
		 * directly. 
		 * @param tuple_floatInputDataPtr The value(s) of the tuple. 
		 */
		virtual	void AddTuple( const float *tuple_floatInputDataPtr ) = 0;

		/**
		 * Sets a tuple in the list. The id is the id of the tuple that is being updated. 
		 * Warning! No range checking is done. 
		 * @param id The id of the tuple. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxTupleId(). 
		 * @param tuple_floatInputDataPtr The new value(s) of the tuple. 
		 */
		virtual	void SetTuple( rid id , const float *tuple_floatInputDataPtr ) = 0;

		/**
		 * Gets a tuple in the list. The id is the id of the tuple that is being fetched. 
		 * Warning! No range checking is done. 
		 * @param id The id of the tuple. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxTupleId(). 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spFloatData GetTuple( rid id ) = 0;

		/**
		 * Returns all tuples in the array as a single item array. 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spFloatData GetData(  ) = 0;

		/**
		 * Returns a range of tuples in the array. 
		 * @param start_tuple_id The first id in the range. Value cannot be less than 
		 * 0. Value cannot be greater than the value returned by GetMaxTupleId(). 
		 * @param tuple_count The number of tuples in the range. 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spFloatData GetDataRange( rid start_tuple_id , unsigned int tuple_count ) = 0;

		/**
		 * Set the array from a range of data values. Note that the array will be resized 
		 * to the size of the items. Note that the source_item_count is the number of 
		 * items to set, NOT the number of tuples. 
		 * @param source_items_floatInputDataPtr The array to copy from. Value cannot 
		 * be equal to null. 
		 * @param source_item_count The number of items in the array. 
		 */
		virtual	void SetData( const float *source_items_floatInputDataPtr , unsigned int source_item_count ) = 0;

		/**
		 * Set a part of the array from a range of data values. Note that the array will 
		 * be resized to contain the size of the items. Note that the source_item_count 
		 * is the number of items to set, NOT the number of tuples, but start_tuple_id 
		 * IS the first tuple index to update. 
		 * @param start_tuple_id where to start copy to in this array. Value cannot be 
		 * less than 0. Value cannot be greater than the value returned by GetMaxTupleId(). 
		 *  
		 * @param source_items_floatInputDataPtr The array to copy from. Value cannot 
		 * be equal to null. 
		 * @param source_item_count The number of items in the array. 
		 */
		virtual	void SetDataRange( rid start_tuple_id , const float *source_items_floatInputDataPtr , unsigned int source_item_count ) = 0;

		/**
		 * Set the array from a range of data values in a raw memory block. The array 
		 * will be resized to the size of the tuples. Please set the tuple sizebefore 
		 * calling this method. Note! that the source_tuple_count is the number of TUPLES 
		 * to set, not the number of items. Note! This method is intended for advanced 
		 * users who want to get maximum performance. No range checking is done in this 
		 * method, and your code will crash if your read area is not large enough. 
		 * @param mem_area_voidInputDataPtr The array to copy from Value cannot be equal 
		 * to null. 
		 * @param source_tuple_count The number of items in the array 
		 * @param item_stride The number of bytes between the address of an item to the 
		 * address of the next. If items are consecutive in memory, this stride should 
		 * be the size of on item. 
		 * @param tuple_stride The number of bytes between the address of the first item 
		 * in one tuple to the address of the first item in the next tuple. E.g, if the 
		 * items are copied from an array of structs, this stride should be the size of 
		 * one of the struct objects in the array. 
		 */
		virtual	void SetDataFromMemoryPtr( void *mem_area_voidInputDataPtr , unsigned int source_tuple_count , unsigned int item_stride , unsigned int tuple_stride ) = 0;

	};

	/**
	 * IntArray is the int implementation of ValueArray. See ValueArray for a description. 
	 */
	class IIntArray : public IValueArray
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IIntArray is a or is a descendant of 
		 * the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IIntArray",type)==0 )
				return true;
			return IValueArray::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IIntArray 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IIntArray pointer 
		 * @return a pointer to the IIntArray object, if the cast can be made, and a NULL 
		 * pointer otherwise 
		 */

		static IIntArray *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IIntArray") )
				return static_cast<IIntArray*>(ptr);
			return nullptr;
		}
		/**
		 * Adds an item to the list, allocates memory as needed to enlarge the list. If 
		 * many items are being put into the list, use Resize to set the size of the new 
		 * list (only one reallocation needed) and then use SetItem() / SetTuple() to 
		 * set the items directly. 
		 * @param value The value of the item. 
		 */
		virtual	void AddItem( int value ) = 0;

		/**
		 * Sets an item in the list. The id of the item is the exact location of the item 
		 * (TupleId * TupleSize + Index of item in tuple) Warning! No range checking is 
		 * done. 
		 * @param id The id of the item. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxItemId(). 
		 * @param value The new value of the item. 
		 */
		virtual	void SetItem( rid id , int value ) = 0;

		/**
		 * Gets the value of an item in the list. The id of the item is the exact location 
		 * of the item (TupleId * TupleSize + Index of item in tuple) Warning! No range 
		 * checking is done. 
		 * @param id The id of the item. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxItemId(). 
		 */
		virtual	int GetItem( rid id ) = 0;

		/**
		 * Adds a tuple to the list. Reallocates the list if needed. If many items are 
		 * being put into the list, use Resize to set the size of the new list (only one 
		 * reallocation needed) and then use SetItem() / SetRealTuple() to set the items 
		 * directly. 
		 * @param tuple_intInputDataPtr The value(s) of the tuple. 
		 */
		virtual	void AddTuple( const int *tuple_intInputDataPtr ) = 0;

		/**
		 * Sets a tuple in the list. The id is the id of the tuple that is being updated. 
		 * Warning! No range checking is done. 
		 * @param id The id of the tuple. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxTupleId(). 
		 * @param tuple_intInputDataPtr The new value(s) of the tuple. 
		 */
		virtual	void SetTuple( rid id , const int *tuple_intInputDataPtr ) = 0;

		/**
		 * Gets a tuple in the list. The id is the id of the tuple that is being fetched. 
		 * Warning! No range checking is done. 
		 * @param id The id of the tuple. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxTupleId(). 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spIntData GetTuple( rid id ) = 0;

		/**
		 * Returns all tuples in the array as a single item array. 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spIntData GetData(  ) = 0;

		/**
		 * Returns a range of tuples in the array. 
		 * @param start_tuple_id The first id in the range. Value cannot be less than 
		 * 0. Value cannot be greater than the value returned by GetMaxTupleId(). 
		 * @param tuple_count The number of tuples in the range. 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spIntData GetDataRange( rid start_tuple_id , unsigned int tuple_count ) = 0;

		/**
		 * Set the array from a range of data values. Note that the array will be resized 
		 * to the size of the items. Note that the source_item_count is the number of 
		 * items to set, NOT the number of tuples. 
		 * @param source_items_intInputDataPtr The array to copy from. Value cannot be 
		 * equal to null. 
		 * @param source_item_count The number of items in the array. 
		 */
		virtual	void SetData( const int *source_items_intInputDataPtr , unsigned int source_item_count ) = 0;

		/**
		 * Set a part of the array from a range of data values. Note that the array will 
		 * be resized to contain the size of the items. Note that the source_item_count 
		 * is the number of items to set, NOT the number of tuples, but start_tuple_id 
		 * IS the first tuple index to update. 
		 * @param start_tuple_id where to start copy to in this array. Value cannot be 
		 * less than 0. Value cannot be greater than the value returned by GetMaxTupleId(). 
		 *  
		 * @param source_items_intInputDataPtr The array to copy from. Value cannot be 
		 * equal to null. 
		 * @param source_item_count The number of items in the array. 
		 */
		virtual	void SetDataRange( rid start_tuple_id , const int *source_items_intInputDataPtr , unsigned int source_item_count ) = 0;

		/**
		 * Set the array from a range of data values in a raw memory block. The array 
		 * will be resized to the size of the tuples. Please set the tuple sizebefore 
		 * calling this method. Note! that the source_tuple_count is the number of TUPLES 
		 * to set, not the number of items. Note! This method is intended for advanced 
		 * users who want to get maximum performance. No range checking is done in this 
		 * method, and your code will crash if your read area is not large enough. 
		 * @param mem_area_voidInputDataPtr The array to copy from Value cannot be equal 
		 * to null. 
		 * @param source_tuple_count The number of items in the array 
		 * @param item_stride The number of bytes between the address of an item to the 
		 * address of the next. If items are consecutive in memory, this stride should 
		 * be the size of on item. 
		 * @param tuple_stride The number of bytes between the address of the first item 
		 * in one tuple to the address of the first item in the next tuple. E.g, if the 
		 * items are copied from an array of structs, this stride should be the size of 
		 * one of the struct objects in the array. 
		 */
		virtual	void SetDataFromMemoryPtr( void *mem_area_voidInputDataPtr , unsigned int source_tuple_count , unsigned int item_stride , unsigned int tuple_stride ) = 0;

	};

	/**
	 * LongArray is the long implementation of ValueArray. See ValueArray for a description. 
	 */
	class ILongArray : public IValueArray
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if ILongArray is a or is a descendant of 
		 * the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("ILongArray",type)==0 )
				return true;
			return IValueArray::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a ILongArray 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ILongArray pointer 
		 * @return a pointer to the ILongArray object, if the cast can be made, and a 
		 * NULL pointer otherwise 
		 */

		static ILongArray *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("ILongArray") )
				return static_cast<ILongArray*>(ptr);
			return nullptr;
		}
		/**
		 * Adds an item to the list, allocates memory as needed to enlarge the list. If 
		 * many items are being put into the list, use Resize to set the size of the new 
		 * list (only one reallocation needed) and then use SetItem() / SetTuple() to 
		 * set the items directly. 
		 * @param value The value of the item. 
		 */
		virtual	void AddItem( long value ) = 0;

		/**
		 * Sets an item in the list. The id of the item is the exact location of the item 
		 * (TupleId * TupleSize + Index of item in tuple) Warning! No range checking is 
		 * done. 
		 * @param id The id of the item. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxItemId(). 
		 * @param value The new value of the item. 
		 */
		virtual	void SetItem( rid id , long value ) = 0;

		/**
		 * Gets the value of an item in the list. The id of the item is the exact location 
		 * of the item (TupleId * TupleSize + Index of item in tuple) Warning! No range 
		 * checking is done. 
		 * @param id The id of the item. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxItemId(). 
		 */
		virtual	long GetItem( rid id ) = 0;

		/**
		 * Adds a tuple to the list. Reallocates the list if needed. If many items are 
		 * being put into the list, use Resize to set the size of the new list (only one 
		 * reallocation needed) and then use SetItem() / SetRealTuple() to set the items 
		 * directly. 
		 * @param tuple_longInputDataPtr The value(s) of the tuple. 
		 */
		virtual	void AddTuple( const long *tuple_longInputDataPtr ) = 0;

		/**
		 * Sets a tuple in the list. The id is the id of the tuple that is being updated. 
		 * Warning! No range checking is done. 
		 * @param id The id of the tuple. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxTupleId(). 
		 * @param tuple_longInputDataPtr The new value(s) of the tuple. 
		 */
		virtual	void SetTuple( rid id , const long *tuple_longInputDataPtr ) = 0;

		/**
		 * Gets a tuple in the list. The id is the id of the tuple that is being fetched. 
		 * Warning! No range checking is done. 
		 * @param id The id of the tuple. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxTupleId(). 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spLongData GetTuple( rid id ) = 0;

		/**
		 * Returns all tuples in the array as a single item array. 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spLongData GetData(  ) = 0;

		/**
		 * Returns a range of tuples in the array. 
		 * @param start_tuple_id The first id in the range. Value cannot be less than 
		 * 0. Value cannot be greater than the value returned by GetMaxTupleId(). 
		 * @param tuple_count The number of tuples in the range. 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spLongData GetDataRange( rid start_tuple_id , unsigned int tuple_count ) = 0;

		/**
		 * Set the array from a range of data values. Note that the array will be resized 
		 * to the size of the items. Note that the source_item_count is the number of 
		 * items to set, NOT the number of tuples. 
		 * @param source_items_longInputDataPtr The array to copy from. Value cannot be 
		 * equal to null. 
		 * @param source_item_count The number of items in the array. 
		 */
		virtual	void SetData( const long *source_items_longInputDataPtr , unsigned int source_item_count ) = 0;

		/**
		 * Set a part of the array from a range of data values. Note that the array will 
		 * be resized to contain the size of the items. Note that the source_item_count 
		 * is the number of items to set, NOT the number of tuples, but start_tuple_id 
		 * IS the first tuple index to update. 
		 * @param start_tuple_id where to start copy to in this array. Value cannot be 
		 * less than 0. Value cannot be greater than the value returned by GetMaxTupleId(). 
		 *  
		 * @param source_items_longInputDataPtr The array to copy from. Value cannot be 
		 * equal to null. 
		 * @param source_item_count The number of items in the array. 
		 */
		virtual	void SetDataRange( rid start_tuple_id , const long *source_items_longInputDataPtr , unsigned int source_item_count ) = 0;

		/**
		 * Set the array from a range of data values in a raw memory block. The array 
		 * will be resized to the size of the tuples. Please set the tuple sizebefore 
		 * calling this method. Note! that the source_tuple_count is the number of TUPLES 
		 * to set, not the number of items. Note! This method is intended for advanced 
		 * users who want to get maximum performance. No range checking is done in this 
		 * method, and your code will crash if your read area is not large enough. 
		 * @param mem_area_voidInputDataPtr The array to copy from Value cannot be equal 
		 * to null. 
		 * @param source_tuple_count The number of items in the array 
		 * @param item_stride The number of bytes between the address of an item to the 
		 * address of the next. If items are consecutive in memory, this stride should 
		 * be the size of on item. 
		 * @param tuple_stride The number of bytes between the address of the first item 
		 * in one tuple to the address of the first item in the next tuple. E.g, if the 
		 * items are copied from an array of structs, this stride should be the size of 
		 * one of the struct objects in the array. 
		 */
		virtual	void SetDataFromMemoryPtr( void *mem_area_voidInputDataPtr , unsigned int source_tuple_count , unsigned int item_stride , unsigned int tuple_stride ) = 0;

	};

	/**
	 * RealArray is the real implementation of ValueArray. See ValueArray for a description. 
	 */
	class IRealArray : public IValueArray
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IRealArray is a or is a descendant of 
		 * the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IRealArray",type)==0 )
				return true;
			return IValueArray::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IRealArray 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IRealArray pointer 
		 * @return a pointer to the IRealArray object, if the cast can be made, and a 
		 * NULL pointer otherwise 
		 */

		static IRealArray *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IRealArray") )
				return static_cast<IRealArray*>(ptr);
			return nullptr;
		}
		/**
		 * Adds an item to the list, allocates memory as needed to enlarge the list. If 
		 * many items are being put into the list, use Resize to set the size of the new 
		 * list (only one reallocation needed) and then use SetItem() / SetTuple() to 
		 * set the items directly. 
		 * @param value The value of the item. 
		 */
		virtual	void AddItem( real value ) = 0;

		/**
		 * Sets an item in the list. The id of the item is the exact location of the item 
		 * (TupleId * TupleSize + Index of item in tuple) Warning! No range checking is 
		 * done. 
		 * @param id The id of the item. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxItemId(). 
		 * @param value The new value of the item. 
		 */
		virtual	void SetItem( rid id , real value ) = 0;

		/**
		 * Gets the value of an item in the list. The id of the item is the exact location 
		 * of the item (TupleId * TupleSize + Index of item in tuple) Warning! No range 
		 * checking is done. 
		 * @param id The id of the item. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxItemId(). 
		 */
		virtual	real GetItem( rid id ) = 0;

		/**
		 * Adds a tuple to the list. Reallocates the list if needed. If many items are 
		 * being put into the list, use Resize to set the size of the new list (only one 
		 * reallocation needed) and then use SetItem() / SetRealTuple() to set the items 
		 * directly. 
		 * @param tuple_realInputDataPtr The value(s) of the tuple. 
		 */
		virtual	void AddTuple( const real *tuple_realInputDataPtr ) = 0;

		/**
		 * Sets a tuple in the list. The id is the id of the tuple that is being updated. 
		 * Warning! No range checking is done. 
		 * @param id The id of the tuple. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxTupleId(). 
		 * @param tuple_realInputDataPtr The new value(s) of the tuple. 
		 */
		virtual	void SetTuple( rid id , const real *tuple_realInputDataPtr ) = 0;

		/**
		 * Gets a tuple in the list. The id is the id of the tuple that is being fetched. 
		 * Warning! No range checking is done. 
		 * @param id The id of the tuple. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxTupleId(). 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spRealData GetTuple( rid id ) = 0;

		/**
		 * Returns all tuples in the array as a single item array. 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spRealData GetData(  ) = 0;

		/**
		 * Returns a range of tuples in the array. 
		 * @param start_tuple_id The first id in the range. Value cannot be less than 
		 * 0. Value cannot be greater than the value returned by GetMaxTupleId(). 
		 * @param tuple_count The number of tuples in the range. 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spRealData GetDataRange( rid start_tuple_id , unsigned int tuple_count ) = 0;

		/**
		 * Set the array from a range of data values. Note that the array will be resized 
		 * to the size of the items. Note that the source_item_count is the number of 
		 * items to set, NOT the number of tuples. 
		 * @param source_items_realInputDataPtr The array to copy from. Value cannot be 
		 * equal to null. 
		 * @param source_item_count The number of items in the array. 
		 */
		virtual	void SetData( const real *source_items_realInputDataPtr , unsigned int source_item_count ) = 0;

		/**
		 * Set a part of the array from a range of data values. Note that the array will 
		 * be resized to contain the size of the items. Note that the source_item_count 
		 * is the number of items to set, NOT the number of tuples, but start_tuple_id 
		 * IS the first tuple index to update. 
		 * @param start_tuple_id where to start copy to in this array. Value cannot be 
		 * less than 0. Value cannot be greater than the value returned by GetMaxTupleId(). 
		 *  
		 * @param source_items_realInputDataPtr The array to copy from. Value cannot be 
		 * equal to null. 
		 * @param source_item_count The number of items in the array. 
		 */
		virtual	void SetDataRange( rid start_tuple_id , const real *source_items_realInputDataPtr , unsigned int source_item_count ) = 0;

		/**
		 * Set the array from a range of data values in a raw memory block. The array 
		 * will be resized to the size of the tuples. Please set the tuple sizebefore 
		 * calling this method. Note! that the source_tuple_count is the number of TUPLES 
		 * to set, not the number of items. Note! This method is intended for advanced 
		 * users who want to get maximum performance. No range checking is done in this 
		 * method, and your code will crash if your read area is not large enough. 
		 * @param mem_area_voidInputDataPtr The array to copy from Value cannot be equal 
		 * to null. 
		 * @param source_tuple_count The number of items in the array 
		 * @param item_stride The number of bytes between the address of an item to the 
		 * address of the next. If items are consecutive in memory, this stride should 
		 * be the size of on item. 
		 * @param tuple_stride The number of bytes between the address of the first item 
		 * in one tuple to the address of the first item in the next tuple. E.g, if the 
		 * items are copied from an array of structs, this stride should be the size of 
		 * one of the struct objects in the array. 
		 */
		virtual	void SetDataFromMemoryPtr( void *mem_area_voidInputDataPtr , unsigned int source_tuple_count , unsigned int item_stride , unsigned int tuple_stride ) = 0;

	};

	/**
	 * RidArray is the rid implementation of ValueArray. See ValueArray for a description. 
	 */
	class IRidArray : public IValueArray
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IRidArray is a or is a descendant of 
		 * the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IRidArray",type)==0 )
				return true;
			return IValueArray::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IRidArray 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IRidArray pointer 
		 * @return a pointer to the IRidArray object, if the cast can be made, and a NULL 
		 * pointer otherwise 
		 */

		static IRidArray *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IRidArray") )
				return static_cast<IRidArray*>(ptr);
			return nullptr;
		}
		/**
		 * Adds an item to the list, allocates memory as needed to enlarge the list. If 
		 * many items are being put into the list, use Resize to set the size of the new 
		 * list (only one reallocation needed) and then use SetItem() / SetTuple() to 
		 * set the items directly. 
		 * @param value The value of the item. 
		 */
		virtual	void AddItem( rid value ) = 0;

		/**
		 * Sets an item in the list. The id of the item is the exact location of the item 
		 * (TupleId * TupleSize + Index of item in tuple) Warning! No range checking is 
		 * done. 
		 * @param id The id of the item. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxItemId(). 
		 * @param value The new value of the item. 
		 */
		virtual	void SetItem( rid id , rid value ) = 0;

		/**
		 * Gets the value of an item in the list. The id of the item is the exact location 
		 * of the item (TupleId * TupleSize + Index of item in tuple) Warning! No range 
		 * checking is done. 
		 * @param id The id of the item. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxItemId(). 
		 */
		virtual	rid GetItem( rid id ) = 0;

		/**
		 * Adds a tuple to the list. Reallocates the list if needed. If many items are 
		 * being put into the list, use Resize to set the size of the new list (only one 
		 * reallocation needed) and then use SetItem() / SetRealTuple() to set the items 
		 * directly. 
		 * @param tuple_ridInputDataPtr The value(s) of the tuple. 
		 */
		virtual	void AddTuple( const rid *tuple_ridInputDataPtr ) = 0;

		/**
		 * Sets a tuple in the list. The id is the id of the tuple that is being updated. 
		 * Warning! No range checking is done. 
		 * @param id The id of the tuple. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxTupleId(). 
		 * @param tuple_ridInputDataPtr The new value(s) of the tuple. 
		 */
		virtual	void SetTuple( rid id , const rid *tuple_ridInputDataPtr ) = 0;

		/**
		 * Gets a tuple in the list. The id is the id of the tuple that is being fetched. 
		 * Warning! No range checking is done. 
		 * @param id The id of the tuple. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxTupleId(). 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spRidData GetTuple( rid id ) = 0;

		/**
		 * Returns all tuples in the array as a single item array. 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spRidData GetData(  ) = 0;

		/**
		 * Returns a range of tuples in the array. 
		 * @param start_tuple_id The first id in the range. Value cannot be less than 
		 * 0. Value cannot be greater than the value returned by GetMaxTupleId(). 
		 * @param tuple_count The number of tuples in the range. 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spRidData GetDataRange( rid start_tuple_id , unsigned int tuple_count ) = 0;

		/**
		 * Set the array from a range of data values. Note that the array will be resized 
		 * to the size of the items. Note that the source_item_count is the number of 
		 * items to set, NOT the number of tuples. 
		 * @param source_items_ridInputDataPtr The array to copy from. Value cannot be 
		 * equal to null. 
		 * @param source_item_count The number of items in the array. 
		 */
		virtual	void SetData( const rid *source_items_ridInputDataPtr , unsigned int source_item_count ) = 0;

		/**
		 * Set a part of the array from a range of data values. Note that the array will 
		 * be resized to contain the size of the items. Note that the source_item_count 
		 * is the number of items to set, NOT the number of tuples, but start_tuple_id 
		 * IS the first tuple index to update. 
		 * @param start_tuple_id where to start copy to in this array. Value cannot be 
		 * less than 0. Value cannot be greater than the value returned by GetMaxTupleId(). 
		 *  
		 * @param source_items_ridInputDataPtr The array to copy from. Value cannot be 
		 * equal to null. 
		 * @param source_item_count The number of items in the array. 
		 */
		virtual	void SetDataRange( rid start_tuple_id , const rid *source_items_ridInputDataPtr , unsigned int source_item_count ) = 0;

		/**
		 * Set the array from a range of data values in a raw memory block. The array 
		 * will be resized to the size of the tuples. Please set the tuple sizebefore 
		 * calling this method. Note! that the source_tuple_count is the number of TUPLES 
		 * to set, not the number of items. Note! This method is intended for advanced 
		 * users who want to get maximum performance. No range checking is done in this 
		 * method, and your code will crash if your read area is not large enough. 
		 * @param mem_area_voidInputDataPtr The array to copy from Value cannot be equal 
		 * to null. 
		 * @param source_tuple_count The number of items in the array 
		 * @param item_stride The number of bytes between the address of an item to the 
		 * address of the next. If items are consecutive in memory, this stride should 
		 * be the size of on item. 
		 * @param tuple_stride The number of bytes between the address of the first item 
		 * in one tuple to the address of the first item in the next tuple. E.g, if the 
		 * items are copied from an array of structs, this stride should be the size of 
		 * one of the struct objects in the array. 
		 */
		virtual	void SetDataFromMemoryPtr( void *mem_area_voidInputDataPtr , unsigned int source_tuple_count , unsigned int item_stride , unsigned int tuple_stride ) = 0;

	};

	/**
	 * ShortArray is the short implementation of ValueArray. See ValueArray for a description. 
	 */
	class IShortArray : public IValueArray
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShortArray is a or is a descendant of 
		 * the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShortArray",type)==0 )
				return true;
			return IValueArray::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShortArray 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShortArray pointer 
		 * @return a pointer to the IShortArray object, if the cast can be made, and a 
		 * NULL pointer otherwise 
		 */

		static IShortArray *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShortArray") )
				return static_cast<IShortArray*>(ptr);
			return nullptr;
		}
		/**
		 * Adds an item to the list, allocates memory as needed to enlarge the list. If 
		 * many items are being put into the list, use Resize to set the size of the new 
		 * list (only one reallocation needed) and then use SetItem() / SetTuple() to 
		 * set the items directly. 
		 * @param value The value of the item. 
		 */
		virtual	void AddItem( short value ) = 0;

		/**
		 * Sets an item in the list. The id of the item is the exact location of the item 
		 * (TupleId * TupleSize + Index of item in tuple) Warning! No range checking is 
		 * done. 
		 * @param id The id of the item. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxItemId(). 
		 * @param value The new value of the item. 
		 */
		virtual	void SetItem( rid id , short value ) = 0;

		/**
		 * Gets the value of an item in the list. The id of the item is the exact location 
		 * of the item (TupleId * TupleSize + Index of item in tuple) Warning! No range 
		 * checking is done. 
		 * @param id The id of the item. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxItemId(). 
		 */
		virtual	short GetItem( rid id ) = 0;

		/**
		 * Adds a tuple to the list. Reallocates the list if needed. If many items are 
		 * being put into the list, use Resize to set the size of the new list (only one 
		 * reallocation needed) and then use SetItem() / SetRealTuple() to set the items 
		 * directly. 
		 * @param tuple_shortInputDataPtr The value(s) of the tuple. 
		 */
		virtual	void AddTuple( const short *tuple_shortInputDataPtr ) = 0;

		/**
		 * Sets a tuple in the list. The id is the id of the tuple that is being updated. 
		 * Warning! No range checking is done. 
		 * @param id The id of the tuple. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxTupleId(). 
		 * @param tuple_shortInputDataPtr The new value(s) of the tuple. 
		 */
		virtual	void SetTuple( rid id , const short *tuple_shortInputDataPtr ) = 0;

		/**
		 * Gets a tuple in the list. The id is the id of the tuple that is being fetched. 
		 * Warning! No range checking is done. 
		 * @param id The id of the tuple. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxTupleId(). 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spShortData GetTuple( rid id ) = 0;

		/**
		 * Returns all tuples in the array as a single item array. 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spShortData GetData(  ) = 0;

		/**
		 * Returns a range of tuples in the array. 
		 * @param start_tuple_id The first id in the range. Value cannot be less than 
		 * 0. Value cannot be greater than the value returned by GetMaxTupleId(). 
		 * @param tuple_count The number of tuples in the range. 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spShortData GetDataRange( rid start_tuple_id , unsigned int tuple_count ) = 0;

		/**
		 * Set the array from a range of data values. Note that the array will be resized 
		 * to the size of the items. Note that the source_item_count is the number of 
		 * items to set, NOT the number of tuples. 
		 * @param source_items_shortInputDataPtr The array to copy from. Value cannot 
		 * be equal to null. 
		 * @param source_item_count The number of items in the array. 
		 */
		virtual	void SetData( const short *source_items_shortInputDataPtr , unsigned int source_item_count ) = 0;

		/**
		 * Set a part of the array from a range of data values. Note that the array will 
		 * be resized to contain the size of the items. Note that the source_item_count 
		 * is the number of items to set, NOT the number of tuples, but start_tuple_id 
		 * IS the first tuple index to update. 
		 * @param start_tuple_id where to start copy to in this array. Value cannot be 
		 * less than 0. Value cannot be greater than the value returned by GetMaxTupleId(). 
		 *  
		 * @param source_items_shortInputDataPtr The array to copy from. Value cannot 
		 * be equal to null. 
		 * @param source_item_count The number of items in the array. 
		 */
		virtual	void SetDataRange( rid start_tuple_id , const short *source_items_shortInputDataPtr , unsigned int source_item_count ) = 0;

		/**
		 * Set the array from a range of data values in a raw memory block. The array 
		 * will be resized to the size of the tuples. Please set the tuple sizebefore 
		 * calling this method. Note! that the source_tuple_count is the number of TUPLES 
		 * to set, not the number of items. Note! This method is intended for advanced 
		 * users who want to get maximum performance. No range checking is done in this 
		 * method, and your code will crash if your read area is not large enough. 
		 * @param mem_area_voidInputDataPtr The array to copy from Value cannot be equal 
		 * to null. 
		 * @param source_tuple_count The number of items in the array 
		 * @param item_stride The number of bytes between the address of an item to the 
		 * address of the next. If items are consecutive in memory, this stride should 
		 * be the size of on item. 
		 * @param tuple_stride The number of bytes between the address of the first item 
		 * in one tuple to the address of the first item in the next tuple. E.g, if the 
		 * items are copied from an array of structs, this stride should be the size of 
		 * one of the struct objects in the array. 
		 */
		virtual	void SetDataFromMemoryPtr( void *mem_area_voidInputDataPtr , unsigned int source_tuple_count , unsigned int item_stride , unsigned int tuple_stride ) = 0;

	};

	/**
	 * UnsignedCharArray is the uchar implementation of ValueArray. See ValueArray 
	 * for a description. 
	 */
	class IUnsignedCharArray : public IValueArray
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IUnsignedCharArray is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IUnsignedCharArray",type)==0 )
				return true;
			return IValueArray::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IUnsignedCharArray 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IUnsignedCharArray pointer 
		 * @return a pointer to the IUnsignedCharArray object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IUnsignedCharArray *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IUnsignedCharArray") )
				return static_cast<IUnsignedCharArray*>(ptr);
			return nullptr;
		}
		/**
		 * Adds an item to the list, allocates memory as needed to enlarge the list. If 
		 * many items are being put into the list, use Resize to set the size of the new 
		 * list (only one reallocation needed) and then use SetItem() / SetTuple() to 
		 * set the items directly. 
		 * @param value The value of the item. 
		 */
		virtual	void AddItem( unsigned char value ) = 0;

		/**
		 * Sets an item in the list. The id of the item is the exact location of the item 
		 * (TupleId * TupleSize + Index of item in tuple) Warning! No range checking is 
		 * done. 
		 * @param id The id of the item. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxItemId(). 
		 * @param value The new value of the item. 
		 */
		virtual	void SetItem( rid id , unsigned char value ) = 0;

		/**
		 * Gets the value of an item in the list. The id of the item is the exact location 
		 * of the item (TupleId * TupleSize + Index of item in tuple) Warning! No range 
		 * checking is done. 
		 * @param id The id of the item. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxItemId(). 
		 */
		virtual	unsigned char GetItem( rid id ) = 0;

		/**
		 * Adds a tuple to the list. Reallocates the list if needed. If many items are 
		 * being put into the list, use Resize to set the size of the new list (only one 
		 * reallocation needed) and then use SetItem() / SetRealTuple() to set the items 
		 * directly. 
		 * @param tuple_ucharInputDataPtr The value(s) of the tuple. 
		 */
		virtual	void AddTuple( const unsigned char *tuple_ucharInputDataPtr ) = 0;

		/**
		 * Sets a tuple in the list. The id is the id of the tuple that is being updated. 
		 * Warning! No range checking is done. 
		 * @param id The id of the tuple. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxTupleId(). 
		 * @param tuple_ucharInputDataPtr The new value(s) of the tuple. 
		 */
		virtual	void SetTuple( rid id , const unsigned char *tuple_ucharInputDataPtr ) = 0;

		/**
		 * Gets a tuple in the list. The id is the id of the tuple that is being fetched. 
		 * Warning! No range checking is done. 
		 * @param id The id of the tuple. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxTupleId(). 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spUnsignedCharData GetTuple( rid id ) = 0;

		/**
		 * Returns all tuples in the array as a single item array. 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spUnsignedCharData GetData(  ) = 0;

		/**
		 * Returns a range of tuples in the array. 
		 * @param start_tuple_id The first id in the range. Value cannot be less than 
		 * 0. Value cannot be greater than the value returned by GetMaxTupleId(). 
		 * @param tuple_count The number of tuples in the range. 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spUnsignedCharData GetDataRange( rid start_tuple_id , unsigned int tuple_count ) = 0;

		/**
		 * Set the array from a range of data values. Note that the array will be resized 
		 * to the size of the items. Note that the source_item_count is the number of 
		 * items to set, NOT the number of tuples. 
		 * @param source_items_ucharInputDataPtr The array to copy from. Value cannot 
		 * be equal to null. 
		 * @param source_item_count The number of items in the array. 
		 */
		virtual	void SetData( const unsigned char *source_items_ucharInputDataPtr , unsigned int source_item_count ) = 0;

		/**
		 * Set a part of the array from a range of data values. Note that the array will 
		 * be resized to contain the size of the items. Note that the source_item_count 
		 * is the number of items to set, NOT the number of tuples, but start_tuple_id 
		 * IS the first tuple index to update. 
		 * @param start_tuple_id where to start copy to in this array. Value cannot be 
		 * less than 0. Value cannot be greater than the value returned by GetMaxTupleId(). 
		 *  
		 * @param source_items_ucharInputDataPtr The array to copy from. Value cannot 
		 * be equal to null. 
		 * @param source_item_count The number of items in the array. 
		 */
		virtual	void SetDataRange( rid start_tuple_id , const unsigned char *source_items_ucharInputDataPtr , unsigned int source_item_count ) = 0;

		/**
		 * Set the array from a range of data values in a raw memory block. The array 
		 * will be resized to the size of the tuples. Please set the tuple sizebefore 
		 * calling this method. Note! that the source_tuple_count is the number of TUPLES 
		 * to set, not the number of items. Note! This method is intended for advanced 
		 * users who want to get maximum performance. No range checking is done in this 
		 * method, and your code will crash if your read area is not large enough. 
		 * @param mem_area_voidInputDataPtr The array to copy from Value cannot be equal 
		 * to null. 
		 * @param source_tuple_count The number of items in the array 
		 * @param item_stride The number of bytes between the address of an item to the 
		 * address of the next. If items are consecutive in memory, this stride should 
		 * be the size of on item. 
		 * @param tuple_stride The number of bytes between the address of the first item 
		 * in one tuple to the address of the first item in the next tuple. E.g, if the 
		 * items are copied from an array of structs, this stride should be the size of 
		 * one of the struct objects in the array. 
		 */
		virtual	void SetDataFromMemoryPtr( void *mem_area_voidInputDataPtr , unsigned int source_tuple_count , unsigned int item_stride , unsigned int tuple_stride ) = 0;

	};

	/**
	 * UnsignedIntArray is the uint implementation of ValueArray. See ValueArray for 
	 * a description. 
	 */
	class IUnsignedIntArray : public IValueArray
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IUnsignedIntArray is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IUnsignedIntArray",type)==0 )
				return true;
			return IValueArray::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IUnsignedIntArray 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IUnsignedIntArray pointer 
		 * @return a pointer to the IUnsignedIntArray object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IUnsignedIntArray *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IUnsignedIntArray") )
				return static_cast<IUnsignedIntArray*>(ptr);
			return nullptr;
		}
		/**
		 * Adds an item to the list, allocates memory as needed to enlarge the list. If 
		 * many items are being put into the list, use Resize to set the size of the new 
		 * list (only one reallocation needed) and then use SetItem() / SetTuple() to 
		 * set the items directly. 
		 * @param value The value of the item. 
		 */
		virtual	void AddItem( unsigned int value ) = 0;

		/**
		 * Sets an item in the list. The id of the item is the exact location of the item 
		 * (TupleId * TupleSize + Index of item in tuple) Warning! No range checking is 
		 * done. 
		 * @param id The id of the item. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxItemId(). 
		 * @param value The new value of the item. 
		 */
		virtual	void SetItem( rid id , unsigned int value ) = 0;

		/**
		 * Gets the value of an item in the list. The id of the item is the exact location 
		 * of the item (TupleId * TupleSize + Index of item in tuple) Warning! No range 
		 * checking is done. 
		 * @param id The id of the item. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxItemId(). 
		 */
		virtual	unsigned int GetItem( rid id ) = 0;

		/**
		 * Adds a tuple to the list. Reallocates the list if needed. If many items are 
		 * being put into the list, use Resize to set the size of the new list (only one 
		 * reallocation needed) and then use SetItem() / SetRealTuple() to set the items 
		 * directly. 
		 * @param tuple_uintInputDataPtr The value(s) of the tuple. 
		 */
		virtual	void AddTuple( const unsigned int *tuple_uintInputDataPtr ) = 0;

		/**
		 * Sets a tuple in the list. The id is the id of the tuple that is being updated. 
		 * Warning! No range checking is done. 
		 * @param id The id of the tuple. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxTupleId(). 
		 * @param tuple_uintInputDataPtr The new value(s) of the tuple. 
		 */
		virtual	void SetTuple( rid id , const unsigned int *tuple_uintInputDataPtr ) = 0;

		/**
		 * Gets a tuple in the list. The id is the id of the tuple that is being fetched. 
		 * Warning! No range checking is done. 
		 * @param id The id of the tuple. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxTupleId(). 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spUnsignedIntData GetTuple( rid id ) = 0;

		/**
		 * Returns all tuples in the array as a single item array. 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spUnsignedIntData GetData(  ) = 0;

		/**
		 * Returns a range of tuples in the array. 
		 * @param start_tuple_id The first id in the range. Value cannot be less than 
		 * 0. Value cannot be greater than the value returned by GetMaxTupleId(). 
		 * @param tuple_count The number of tuples in the range. 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spUnsignedIntData GetDataRange( rid start_tuple_id , unsigned int tuple_count ) = 0;

		/**
		 * Set the array from a range of data values. Note that the array will be resized 
		 * to the size of the items. Note that the source_item_count is the number of 
		 * items to set, NOT the number of tuples. 
		 * @param source_items_uintInputDataPtr The array to copy from. Value cannot be 
		 * equal to null. 
		 * @param source_item_count The number of items in the array. 
		 */
		virtual	void SetData( const unsigned int *source_items_uintInputDataPtr , unsigned int source_item_count ) = 0;

		/**
		 * Set a part of the array from a range of data values. Note that the array will 
		 * be resized to contain the size of the items. Note that the source_item_count 
		 * is the number of items to set, NOT the number of tuples, but start_tuple_id 
		 * IS the first tuple index to update. 
		 * @param start_tuple_id where to start copy to in this array. Value cannot be 
		 * less than 0. Value cannot be greater than the value returned by GetMaxTupleId(). 
		 *  
		 * @param source_items_uintInputDataPtr The array to copy from. Value cannot be 
		 * equal to null. 
		 * @param source_item_count The number of items in the array. 
		 */
		virtual	void SetDataRange( rid start_tuple_id , const unsigned int *source_items_uintInputDataPtr , unsigned int source_item_count ) = 0;

		/**
		 * Set the array from a range of data values in a raw memory block. The array 
		 * will be resized to the size of the tuples. Please set the tuple sizebefore 
		 * calling this method. Note! that the source_tuple_count is the number of TUPLES 
		 * to set, not the number of items. Note! This method is intended for advanced 
		 * users who want to get maximum performance. No range checking is done in this 
		 * method, and your code will crash if your read area is not large enough. 
		 * @param mem_area_voidInputDataPtr The array to copy from Value cannot be equal 
		 * to null. 
		 * @param source_tuple_count The number of items in the array 
		 * @param item_stride The number of bytes between the address of an item to the 
		 * address of the next. If items are consecutive in memory, this stride should 
		 * be the size of on item. 
		 * @param tuple_stride The number of bytes between the address of the first item 
		 * in one tuple to the address of the first item in the next tuple. E.g, if the 
		 * items are copied from an array of structs, this stride should be the size of 
		 * one of the struct objects in the array. 
		 */
		virtual	void SetDataFromMemoryPtr( void *mem_area_voidInputDataPtr , unsigned int source_tuple_count , unsigned int item_stride , unsigned int tuple_stride ) = 0;

	};

	/**
	 * UnsignedLongArray is the ulong implementation of ValueArray. See ValueArray 
	 * for a description. 
	 */
	class IUnsignedLongArray : public IValueArray
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IUnsignedLongArray is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IUnsignedLongArray",type)==0 )
				return true;
			return IValueArray::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IUnsignedLongArray 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IUnsignedLongArray pointer 
		 * @return a pointer to the IUnsignedLongArray object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IUnsignedLongArray *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IUnsignedLongArray") )
				return static_cast<IUnsignedLongArray*>(ptr);
			return nullptr;
		}
		/**
		 * Adds an item to the list, allocates memory as needed to enlarge the list. If 
		 * many items are being put into the list, use Resize to set the size of the new 
		 * list (only one reallocation needed) and then use SetItem() / SetTuple() to 
		 * set the items directly. 
		 * @param value The value of the item. 
		 */
		virtual	void AddItem( unsigned long value ) = 0;

		/**
		 * Sets an item in the list. The id of the item is the exact location of the item 
		 * (TupleId * TupleSize + Index of item in tuple) Warning! No range checking is 
		 * done. 
		 * @param id The id of the item. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxItemId(). 
		 * @param value The new value of the item. 
		 */
		virtual	void SetItem( rid id , unsigned long value ) = 0;

		/**
		 * Gets the value of an item in the list. The id of the item is the exact location 
		 * of the item (TupleId * TupleSize + Index of item in tuple) Warning! No range 
		 * checking is done. 
		 * @param id The id of the item. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxItemId(). 
		 */
		virtual	unsigned long GetItem( rid id ) = 0;

		/**
		 * Adds a tuple to the list. Reallocates the list if needed. If many items are 
		 * being put into the list, use Resize to set the size of the new list (only one 
		 * reallocation needed) and then use SetItem() / SetRealTuple() to set the items 
		 * directly. 
		 * @param tuple_ulongInputDataPtr The value(s) of the tuple. 
		 */
		virtual	void AddTuple( const unsigned long *tuple_ulongInputDataPtr ) = 0;

		/**
		 * Sets a tuple in the list. The id is the id of the tuple that is being updated. 
		 * Warning! No range checking is done. 
		 * @param id The id of the tuple. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxTupleId(). 
		 * @param tuple_ulongInputDataPtr The new value(s) of the tuple. 
		 */
		virtual	void SetTuple( rid id , const unsigned long *tuple_ulongInputDataPtr ) = 0;

		/**
		 * Gets a tuple in the list. The id is the id of the tuple that is being fetched. 
		 * Warning! No range checking is done. 
		 * @param id The id of the tuple. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxTupleId(). 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spUnsignedLongData GetTuple( rid id ) = 0;

		/**
		 * Returns all tuples in the array as a single item array. 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spUnsignedLongData GetData(  ) = 0;

		/**
		 * Returns a range of tuples in the array. 
		 * @param start_tuple_id The first id in the range. Value cannot be less than 
		 * 0. Value cannot be greater than the value returned by GetMaxTupleId(). 
		 * @param tuple_count The number of tuples in the range. 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spUnsignedLongData GetDataRange( rid start_tuple_id , unsigned int tuple_count ) = 0;

		/**
		 * Set the array from a range of data values. Note that the array will be resized 
		 * to the size of the items. Note that the source_item_count is the number of 
		 * items to set, NOT the number of tuples. 
		 * @param source_items_ulongInputDataPtr The array to copy from. Value cannot 
		 * be equal to null. 
		 * @param source_item_count The number of items in the array. 
		 */
		virtual	void SetData( const unsigned long *source_items_ulongInputDataPtr , unsigned int source_item_count ) = 0;

		/**
		 * Set a part of the array from a range of data values. Note that the array will 
		 * be resized to contain the size of the items. Note that the source_item_count 
		 * is the number of items to set, NOT the number of tuples, but start_tuple_id 
		 * IS the first tuple index to update. 
		 * @param start_tuple_id where to start copy to in this array. Value cannot be 
		 * less than 0. Value cannot be greater than the value returned by GetMaxTupleId(). 
		 *  
		 * @param source_items_ulongInputDataPtr The array to copy from. Value cannot 
		 * be equal to null. 
		 * @param source_item_count The number of items in the array. 
		 */
		virtual	void SetDataRange( rid start_tuple_id , const unsigned long *source_items_ulongInputDataPtr , unsigned int source_item_count ) = 0;

		/**
		 * Set the array from a range of data values in a raw memory block. The array 
		 * will be resized to the size of the tuples. Please set the tuple sizebefore 
		 * calling this method. Note! that the source_tuple_count is the number of TUPLES 
		 * to set, not the number of items. Note! This method is intended for advanced 
		 * users who want to get maximum performance. No range checking is done in this 
		 * method, and your code will crash if your read area is not large enough. 
		 * @param mem_area_voidInputDataPtr The array to copy from Value cannot be equal 
		 * to null. 
		 * @param source_tuple_count The number of items in the array 
		 * @param item_stride The number of bytes between the address of an item to the 
		 * address of the next. If items are consecutive in memory, this stride should 
		 * be the size of on item. 
		 * @param tuple_stride The number of bytes between the address of the first item 
		 * in one tuple to the address of the first item in the next tuple. E.g, if the 
		 * items are copied from an array of structs, this stride should be the size of 
		 * one of the struct objects in the array. 
		 */
		virtual	void SetDataFromMemoryPtr( void *mem_area_voidInputDataPtr , unsigned int source_tuple_count , unsigned int item_stride , unsigned int tuple_stride ) = 0;

	};

	/**
	 * UnsignedShortArray is the ushort implementation of ValueArray. See ValueArray 
	 * for a description. 
	 */
	class IUnsignedShortArray : public IValueArray
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IUnsignedShortArray is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IUnsignedShortArray",type)==0 )
				return true;
			return IValueArray::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IUnsignedShortArray 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IUnsignedShortArray pointer 
		 * @return a pointer to the IUnsignedShortArray object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IUnsignedShortArray *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IUnsignedShortArray") )
				return static_cast<IUnsignedShortArray*>(ptr);
			return nullptr;
		}
		/**
		 * Adds an item to the list, allocates memory as needed to enlarge the list. If 
		 * many items are being put into the list, use Resize to set the size of the new 
		 * list (only one reallocation needed) and then use SetItem() / SetTuple() to 
		 * set the items directly. 
		 * @param value The value of the item. 
		 */
		virtual	void AddItem( unsigned short value ) = 0;

		/**
		 * Sets an item in the list. The id of the item is the exact location of the item 
		 * (TupleId * TupleSize + Index of item in tuple) Warning! No range checking is 
		 * done. 
		 * @param id The id of the item. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxItemId(). 
		 * @param value The new value of the item. 
		 */
		virtual	void SetItem( rid id , unsigned short value ) = 0;

		/**
		 * Gets the value of an item in the list. The id of the item is the exact location 
		 * of the item (TupleId * TupleSize + Index of item in tuple) Warning! No range 
		 * checking is done. 
		 * @param id The id of the item. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxItemId(). 
		 */
		virtual	unsigned short GetItem( rid id ) = 0;

		/**
		 * Adds a tuple to the list. Reallocates the list if needed. If many items are 
		 * being put into the list, use Resize to set the size of the new list (only one 
		 * reallocation needed) and then use SetItem() / SetRealTuple() to set the items 
		 * directly. 
		 * @param tuple_ushortInputDataPtr The value(s) of the tuple. 
		 */
		virtual	void AddTuple( const unsigned short *tuple_ushortInputDataPtr ) = 0;

		/**
		 * Sets a tuple in the list. The id is the id of the tuple that is being updated. 
		 * Warning! No range checking is done. 
		 * @param id The id of the tuple. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxTupleId(). 
		 * @param tuple_ushortInputDataPtr The new value(s) of the tuple. 
		 */
		virtual	void SetTuple( rid id , const unsigned short *tuple_ushortInputDataPtr ) = 0;

		/**
		 * Gets a tuple in the list. The id is the id of the tuple that is being fetched. 
		 * Warning! No range checking is done. 
		 * @param id The id of the tuple. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxTupleId(). 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spUnsignedShortData GetTuple( rid id ) = 0;

		/**
		 * Returns all tuples in the array as a single item array. 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spUnsignedShortData GetData(  ) = 0;

		/**
		 * Returns a range of tuples in the array. 
		 * @param start_tuple_id The first id in the range. Value cannot be less than 
		 * 0. Value cannot be greater than the value returned by GetMaxTupleId(). 
		 * @param tuple_count The number of tuples in the range. 
		 * @return The returned data array. The array contains a dynamic number of items. 
		 * Check the lenght of the array. 
		 */
		virtual	spUnsignedShortData GetDataRange( rid start_tuple_id , unsigned int tuple_count ) = 0;

		/**
		 * Set the array from a range of data values. Note that the array will be resized 
		 * to the size of the items. Note that the source_item_count is the number of 
		 * items to set, NOT the number of tuples. 
		 * @param source_items_ushortInputDataPtr The array to copy from. Value cannot 
		 * be equal to null. 
		 * @param source_item_count The number of items in the array. 
		 */
		virtual	void SetData( const unsigned short *source_items_ushortInputDataPtr , unsigned int source_item_count ) = 0;

		/**
		 * Set a part of the array from a range of data values. Note that the array will 
		 * be resized to contain the size of the items. Note that the source_item_count 
		 * is the number of items to set, NOT the number of tuples, but start_tuple_id 
		 * IS the first tuple index to update. 
		 * @param start_tuple_id where to start copy to in this array. Value cannot be 
		 * less than 0. Value cannot be greater than the value returned by GetMaxTupleId(). 
		 *  
		 * @param source_items_ushortInputDataPtr The array to copy from. Value cannot 
		 * be equal to null. 
		 * @param source_item_count The number of items in the array. 
		 */
		virtual	void SetDataRange( rid start_tuple_id , const unsigned short *source_items_ushortInputDataPtr , unsigned int source_item_count ) = 0;

		/**
		 * Set the array from a range of data values in a raw memory block. The array 
		 * will be resized to the size of the tuples. Please set the tuple sizebefore 
		 * calling this method. Note! that the source_tuple_count is the number of TUPLES 
		 * to set, not the number of items. Note! This method is intended for advanced 
		 * users who want to get maximum performance. No range checking is done in this 
		 * method, and your code will crash if your read area is not large enough. 
		 * @param mem_area_voidInputDataPtr The array to copy from Value cannot be equal 
		 * to null. 
		 * @param source_tuple_count The number of items in the array 
		 * @param item_stride The number of bytes between the address of an item to the 
		 * address of the next. If items are consecutive in memory, this stride should 
		 * be the size of on item. 
		 * @param tuple_stride The number of bytes between the address of the first item 
		 * in one tuple to the address of the first item in the next tuple. E.g, if the 
		 * items are copied from an array of structs, this stride should be the size of 
		 * one of the struct objects in the array. 
		 */
		virtual	void SetDataFromMemoryPtr( void *mem_area_voidInputDataPtr , unsigned int source_tuple_count , unsigned int item_stride , unsigned int tuple_stride ) = 0;

	};
	class IImageData;

	/**
	 * ChunkedImageData holds chunks for ImageData objects. ImageData objects can be 
	 * referenced, and swapped in/out of memory, to secondary storage. This is useful 
	 * for very large images that cannot be stored in-memory. ImageData objects can 
	 * be indexed in 1-,2- or 3D, and each ImageData chunk is cloned from a source 
	 * ImageData object, at setup. Fields added to ImageData chunks after setup will 
	 * only be added into that chunk, and is not recommended. 
	 */
	class IChunkedImageData : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IChunkedImageData is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IChunkedImageData",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IChunkedImageData 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IChunkedImageData pointer 
		 * @return a pointer to the IChunkedImageData object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IChunkedImageData *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IChunkedImageData") )
				return static_cast<IChunkedImageData*>(ptr);
			return nullptr;
		}
		/**
		 * Makes a new copy of the chunked image data This image must be fully unlocked 
		 * before copying. 
		 * @param copy_data If set, duplicate the data kept in the image data object. 
		 *  
		 */
		virtual	spChunkedImageData NewCopy( bool copy_data ) = 0;

		/**
		 * Deep copies (with template) the data from another image. The source image must 
		 * be fully unlocked before copying. 
		 * @param source Source object. 
		 * @param copy_data If set, duplicate the data kept in the source image data object. 
		 *  
		 */
		virtual	void DeepCopy( spChunkedImageData source , bool copy_data ) = 0;

		/**
		 * The template image to use as template for creating new chunks. The template 
		 * image is cloned, it can be released after the setup. Note that SetTemplateImage 
		 * must be called before allocating image chunks. 
		 * @param _template The template image object. 
		 */
		virtual	void SetTemplateImage( spImageData _template ) = 0;

		/**
		 * The X dimension size of the template image used to create the chunks. 
		 * @return The X dimension size of the template image used to create the chunks. 
		 *  
		 */
		virtual	unsigned int GetTemplateXSize(  ) = 0;

		/**
		 * The Y dimension size of the template image used to create the chunks. 
		 * @return The Y dimension size of the template image used to create the chunks. 
		 *  
		 */
		virtual	unsigned int GetTemplateYSize(  ) = 0;

		/**
		 * The Z dimension size of the template image used to create the chunks. 
		 * @return The Z dimension size of the template image used to create the chunks. 
		 *  
		 */
		virtual	unsigned int GetTemplateZSize(  ) = 0;

		/**
		 * The number of image chunks in the X dimension. 
		 * @return The number of image chunks in the X dimension. 
		 */
		virtual	unsigned int GetXSize(  ) = 0;

		/**
		 * The number of image chunks in the Y dimension. 
		 * @return The number of image chunks in the Y dimension. 
		 */
		virtual	unsigned int GetYSize(  ) = 0;

		/**
		 * The number of image chunks in the Z dimension. 
		 * @return The number of image chunks in the Z dimension. 
		 */
		virtual	unsigned int GetZSize(  ) = 0;

		/**
		 * The number of image chunks in the X dimension. 
		 * @param _xs The desired number of chunks in the X dimension. 
		 */
		virtual	void Set1DSize( unsigned int _xs ) = 0;

		/**
		 * The number of image chunks in the X and Y dimensions. 
		 * @param _xs The desired number of chunks in the X dimension. 
		 * @param _ys The desired number of chunks in the X dimension. 
		 */
		virtual	void Set2DSize( unsigned int _xs , unsigned int _ys ) = 0;

		/**
		 * The number of image chunks in the X, Y and Z dimensions. 
		 * @param _xs The desired number of chunks in the X dimension. 
		 * @param _ys The desired number of chunks in the X dimension. 
		 * @param _zs The desired number of chunks in the X dimension. 
		 */
		virtual	void Set3DSize( unsigned int _xs , unsigned int _ys , unsigned int _zs ) = 0;

		/**
		 * The total X dimension size of the full image. 
		 * @return The total X dimension size of the full image. 
		 */
		virtual	unsigned int GetTotalXSize(  ) = 0;

		/**
		 * The total Y dimension size of the full image. 
		 * @return The total Y dimension size of the full image. 
		 */
		virtual	unsigned int GetTotalYSize(  ) = 0;

		/**
		 * The total Z dimension size of the full image. 
		 * @return The total Z dimension size of the full image. 
		 */
		virtual	unsigned int GetTotalZSize(  ) = 0;

		/**
		 * Clears all data from the image, and removes all data fields. The template image 
		 * is kept, but can be replaced using SetTemplateImage before calling one of the 
		 * SetXDSize methods. Any lock that was hold in the image is automatically released. 
		 *  
		 */
		virtual	void Reset(  ) = 0;

		/**
		 * Locks a chunk for editing, and returns an image object to the caller. Only 
		 * one lock is allowed per chunk. Use IsChunkLocked to check if a chunk is locked 
		 * before trying to lock it. If the Lock failed, because the chunk is already 
		 * locked, null is returned. The method is thread-safe. 
		 * @param x X coordinate of the chunk. 
		 */
		virtual	spImageData LockChunk1D( rid x ) = 0;

		/**
		 * Locks a chunk for editing, and returns an image object to the caller. Only 
		 * one lock is allowed per chunk. Use IsChunkLocked to check if a chunk is locked 
		 * before trying to lock it. If the Lock failed, because the chunk is already 
		 * locked, null is returned. The method is thread-safe. 
		 * @param x X coordinate of the chunk. 
		 * @param y Y coordinate of the chunk. 
		 */
		virtual	spImageData LockChunk2D( rid x , rid y ) = 0;

		/**
		 * Locks a chunk for editing, and returns an image object to the caller. Only 
		 * one lock is allowed per chunk. Use IsChunkLocked to check if a chunk is locked 
		 * before trying to lock it. If the Lock failed, because the chunk is already 
		 * locked, null is returned. The method is thread-safe. 
		 * @param x X coordinate of the chunk. 
		 * @param y Y coordinate of the chunk. 
		 * @param z Z coordinate of the chunk. 
		 */
		virtual	spImageData LockChunk3D( rid x , rid y , rid z ) = 0;

		/**
		 * Returns true if a chunk is locked. The method is thread-safe. 
		 * @param x X coordinate of the chunk. 
		 */
		virtual	bool IsChunkLocked1D( rid x ) = 0;

		/**
		 * Returns true if a chunk is locked. The method is thread-safe. 
		 * @param x X coordinate of the chunk. 
		 * @param y Y coordinate of the chunk. 
		 */
		virtual	bool IsChunkLocked2D( rid x , rid y ) = 0;

		/**
		 * Returns true if a chunk is locked. The method is thread-safe. 
		 * @param x X coordinate of the chunk. 
		 * @param y Y coordinate of the chunk. 
		 * @param z Z coordinate of the chunk. 
		 */
		virtual	bool IsChunkLocked3D( rid x , rid y , rid z ) = 0;

		/**
		 * Unlocks a previously referenced chunk. All references to the object should 
		 * be released. The method is thread-safe. 
		 * @param x X coordinate of the chunk. 
		 */
		virtual	void UnlockChunk1D( rid x ) = 0;

		/**
		 * Unlocks a previously referenced chunk. All references to the object should 
		 * be released. The method is thread-safe. 
		 * @param x X coordinate of the chunk. 
		 * @param y Y coordinate of the chunk. 
		 */
		virtual	void UnlockChunk2D( rid x , rid y ) = 0;

		/**
		 * Unlocks a previously referenced chunk. All references to the object should 
		 * be released. The method is thread-safe. 
		 * @param x X coordinate of the chunk. 
		 * @param y Y coordinate of the chunk. 
		 * @param z Z coordinate of the chunk. 
		 */
		virtual	void UnlockChunk3D( rid x , rid y , rid z ) = 0;

	};
	class IGeometryData;
	class IMaterialTable;
	class IScene;

	/**
	 * A Renderer using DirectX 11 that can be used to preview a scene object containing 
	 * geometry data by rendering it from selected SceneCamera nodes within the given 
	 * scene and then storing the frames to disc. If using a Shading Node Network (having 
	 * an IShadingNode assigned to the IMaterial), then the material can be previewed 
	 * with the generated HLSL shader. 
	 */
	class IDirectXRenderer : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IDirectXRenderer is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IDirectXRenderer",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IDirectXRenderer 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IDirectXRenderer pointer 
		 * @return a pointer to the IDirectXRenderer object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IDirectXRenderer *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IDirectXRenderer") )
				return static_cast<IDirectXRenderer*>(ptr);
			return nullptr;
		}
		/**
		 * Creates a previewer with the specified window dimensions. 
		 * @param _width The window width. 
		 * @param _height The window height. 
		 * @return True if the previewer was successfully created. 
		 */
		virtual	bool CreatePreviewer( int _width , int _height ) = 0;

		/**
		 * Render from each camera view in the camera target direction specified in the 
		 * selection set with the scene cameras and stores the frame to the file path 
		 * specified. 
		 * @param cameraSelectionSetID The ID of the selection set with the scene cameras 
		 * to render from. 
		 * @param file_name_base The desired directory and file name. 
		 * @param format Picture format (PNG or RAW). 
		 */
		virtual	void RenderAlongCameraPathAndStorePics( int cameraSelectionSetID , const char * file_name_base , const char * format ) = 0;

		/**
		 * The render mode to wire frame. 
		 * @param flag True if render mode should be enabled. 
		 */
		virtual	void SetRenderWireFrameMode( bool flag ) = 0;

		/**
		 * The background color of the renderer. 
		 * @param r The red color component for the background color. Value cannot be 
		 * less than 0. Value cannot be greater than 1. 
		 * @param g The green color component for the background color. Value cannot be 
		 * less than 0. Value cannot be greater than 1. 
		 * @param b The blue color component for the background color. Value cannot be 
		 * less than 0. Value cannot be greater than 1. 
		 * @param a The alpha component for the background color. Value cannot be less 
		 * than 0. Value cannot be greater than 1. 
		 */
		virtual	void SetBackgroundColor( real r , real g , real b , real a ) = 0;

		/**
		 * The current background color of the renderer. 
		 * @return The returned data array. The array contains 4 items. 
		 */
		virtual	spRealData GetBackgroundColor(  ) = 0;

		/**
		 * Use in-memory shader generation instead of creating a temporary .fx file on 
		 * disk. Needs to be called after CreatePreviewer to have any effect. 
		 * @param flag The requested boolean value for the UseInMemoryShaderGeneration 
		 * setting. 
		 */
		virtual	void SetUseInMemoryShaderGeneration( bool flag ) = 0;

		/**
		 * Use in-memory shader generation instead of creating a temporary .fx file on 
		 * disk. Needs to be called after CreatePreviewer to have any effect. 
		 */
		virtual	bool GetUseInMemoryShaderGeneration(  ) = 0;

		/**
		 * @deprecated Method is marked as deprecated and will be removed in future version. 
		 * Use \link SetScene SetScene() \endlink instead. Loads a geometry data object 
		 * and its materials into the previewer. 
		 * @param geom The geometry data object to preview. 
		 * @param materials The material table of the geometry. Can be null if no material 
		 * table exists. 
		 * @return True if the geometry data was successfully loaded. 
		 */
		virtual	SGDEPRECATED bool LoadGeometryData( spGeometryData geom , spMaterialTable materials ) = 0;

		/**
		 * @deprecated Method is marked as deprecated and will be removed in future version. 
		 * Use \link SetScene SetScene() \endlink instead. Loads a scene into the previewer. 
		 * The material should have a shading network attached to it. 
		 * @param _scene The scene to preview. 
		 * @return True if the scene was successfully loaded. 
		 */
		virtual	SGDEPRECATED bool LoadGeometryDataWithMaterialShadingNetwork( spScene _scene ) = 0;

		/**
		 * Sets a scene into the previewer. Use InitializeSceneRenderData to generate 
		 * the material shaders. 
		 * @param _scene The scene to preview. 
		 * @return True if the scene was successfully loaded. 
		 */
		virtual	void SetScene( spScene _scene ) = 0;

		/**
		 * Initialize scene geometry's and generates material shaders for rendering. 
		 * @return True if the scene render data was correctly initialized. 
		 */
		virtual	bool InitializeSceneRenderData(  ) = 0;

	};
	class IRidArray;
	class IRealArray;
	class IValueArray;

	/**
	 * FieldData represents multiple fields of data. Each field is implemented as an 
	 * ValueArray object, that has a unique name, and can have complex components (such 
	 * as scalars, vectors, quaternions, tensors or matrices). All fields are assumed 
	 * to be of the same length. IFieldData can be seen as an array with complex tuples, 
	 * where the component can be of different types. 
	 */
	class IFieldData : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IFieldData is a or is a descendant of 
		 * the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IFieldData",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IFieldData 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IFieldData pointer 
		 * @return a pointer to the IFieldData object, if the cast can be made, and a 
		 * NULL pointer otherwise 
		 */

		static IFieldData *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IFieldData") )
				return static_cast<IFieldData*>(ptr);
			return nullptr;
		}
		/**
		 * Creates another field data object with the same field setup. To also copy the 
		 * data to the new object, set copy_data to true. 
		 * @param copy_data True if data should be copied along with the field properties. 
		 *  
		 * @return A copy of this field data. 
		 */
		virtual	spFieldData NewCopy( bool copy_data ) = 0;

		/**
		 * Like NewCopy, NewPackedCopy creates a field data object with the same underlying 
		 * data and tuple settings as the source field data object. However, NewPackedCopy 
		 * only copies unique tuples, and if the index_array parameter is set, this index 
		 * array will contain the same number of tuples as the source field data object, 
		 * and with the ids of a specific tuples within the new copy of the field data 
		 * object. 
		 * @param index_array Will contain indices to the new packed field data values. 
		 *  
		 * @return A packed copy of this field data. 
		 */
		virtual	spFieldData NewPackedCopy( spRidArray index_array ) = 0;

		/**
		 * Copies the field setup and data from another object. To only copy the setup, 
		 * set copy_data to false. 
		 * @param source The source array to copy from. 
		 * @param copy_data True if the data should be copied along with the field data 
		 * properties. 
		 */
		virtual	void DeepCopy( spFieldData source , bool copy_data ) = 0;

		/**
		 * Compares the field setup of this field data object to another field data object. 
		 * If the setups are not identical, false is returned. Note! IsSetupIdenticalTo 
		 * will return false even if the same fields exist in both field data objects, 
		 * but are not in the same order. 
		 * @param other The other field data object used for comparison. 
		 * @return True if the field data objects are identical. 
		 */
		virtual	bool IsSetupIdenticalTo( spFieldData other ) = 0;

		/**
		 * Copies tuples from a source field data object through an id table. The id table 
		 * dictates the order in which the tuples are to be copied. E.g. If the first 
		 * item in the id table has the value 14, then the tuple with id 14 in the source 
		 * array will be copied to the first tuple in this array. Note! All ids in the 
		 * id table must be valid ids of tuples in the source field data object. The id 
		 * table is assumed to have a tuple size of 1. The source and this field data 
		 * object must have the same underlaying data fields, of the same type and the 
		 * same tuple sizes. The FieldData must have enough tuples to hold the new data. 
		 * @param source The source field data object to copy from. Value cannot be equal 
		 * to null. 
		 * @param idtable Array containing the tuple indices to copy. Value cannot be 
		 * equal to null. 
		 * @param startId The first tuple to begin copy into. 
		 */
		virtual	void IndexedCopy( spFieldData source , spRidArray idtable , rid startId ) = 0;

		/**
		 * Works like IndexedCopy, but uses two consecutive ids in the idtable, and a 
		 * blend value from the blendtable. The idtable contains (idtable_cnt*2) indices 
		 * and blendtable contains idtable_cnt blend values. Does the blend: dest = src1*(1-blend) 
		 * + src2*blend The FieldData must have enough tuples to hold the new data. 
		 * @param source The field data to combine from. Value cannot be equal to null. 
		 *  
		 * @param idtable Array containing the tuple indices to combine. Value cannot 
		 * be equal to null. 
		 * @param blendtable Array containing the blend weights. Value cannot be equal 
		 * to null. 
		 * @param startId The tuple to begin putting the combinations into. 
		 */
		virtual	void IndexedCombine( spFieldData source , spRidArray idtable , spRealArray blendtable , rid startId ) = 0;

		/**
		 * Works like IndexedCombine(), but with three ids that are combined through two 
		 * blend values in the blendtable. The idtable contains (idtable_cnt*3) indices 
		 * and blendtable contains (idtable_cnt*2) blend values. Does the blend: dest 
		 * = src1*blend1 + src2*blend2 + src3*(1-(blend1+blend2)) The FieldData must have 
		 * enough tuples to hold the new data. 
		 * @param source The field data to combine from. Value cannot be equal to null. 
		 *  
		 * @param idtable Array containing the tuple indices to combine. Value cannot 
		 * be equal to null. 
		 * @param blendtable Array containing the blend weights. Value cannot be equal 
		 * to null. 
		 * @param startId The tuple to begin putting the combinations into. 
		 */
		virtual	void IndexedCombine3( spFieldData source , spRidArray idtable , spRealArray blendtable , rid startId ) = 0;

		/**
		 * Clears all tuples from the fields. The fields, however, are not removed. 
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Clears all fields from the object. Releases all data in the object. 
		 */
		virtual	void RemoveAllFields(  ) = 0;

		/**
		 * Returns 1 if no tuples exist in the field data. 
		 * @return 1 if empty, else 0 
		 */
		virtual	int IsEmpty(  ) = 0;

		/**
		 * Appends another field data object to this object. The fields are allowed to 
		 * be setup differently, but then comes at a significant performance penalty. 
		 * If fields in the other field data object is missing in this object, these will 
		 * be added, and the items in the old tuples will be set to 0. 
		 * @param other The field data object that is appended. Value cannot be equal 
		 * to null. 
		 * @param add_missing_fields If set to true, missing fields will be added to this 
		 * field data object. 
		 */
		virtual	void AppendTuples( spFieldData other , bool add_missing_fields ) = 0;

		/**
		 * Extracts a range of tuples from this object. The receiving object is assumed 
		 * to have exactly the same data fields as this object. 
		 * @param dest The destination object. Value cannot be equal to null. 
		 * @param start The id of the first tuple that is extracted. 
		 * @param count The number of tuples to extract. 
		 */
		virtual	void ExtractTuples( spFieldData dest , rid start , unsigned int count ) = 0;

		/**
		 * Adds a field. The field must have a unique name set. 
		 * @param field The array to add to the field data. 
		 */
		virtual	void AddField( spValueArray field ) = 0;

		/**
		 * Adds a field based on a base type. Only ValueArray objects are allowed. The 
		 * created and added object is returned. 
		 * @param base_type Should be a base type listed in BaseTypes. 
		 * @param tuple_size The desired tuple size. 
		 * @param name The name of the new field. 
		 * @return A pointer to the new field 
		 */
		virtual	spValueArray AddBaseTypeField( Simplygon::EBaseTypes base_type , unsigned int tuple_size , const char * name ) = 0;

		/**
		 * Retrieves a field. If the field was not found, null is returned. 
		 * @param name The name of the field to fetch. 
		 * @return The field if it exists, otherwise null. 
		 */
		virtual	spValueArray GetField( const char * name ) = 0;

		/**
		 * Retrieves a field from its index in the field data. 
		 * @param id The id of the field. 
		 * @return The field if it exists, otherwise null. 
		 */
		virtual	spValueArray GetFieldWithId( rid id ) = 0;

		/**
		 * Removes a field. Removing a field causes the remaining fields to be remapped 
		 * to new ids. Note that the field must exist. If not, the method will return 
		 * error. To remove a field that may not exist, use SafeRemoveField. 
		 * @param name The name of the field. 
		 */
		virtual	void RemoveField( const char * name ) = 0;

		/**
		 * Removes a field. Removing a field causes the remaining fields to be remapped 
		 * to new ids. 
		 * @param name The name of the field. 
		 */
		virtual	void SafeRemoveField( const char * name ) = 0;

		/**
		 * Returns the number of fields in the field data object. The ids of the fields 
		 * range from 0 through (GetFieldCount()-1). 
		 * @return The number of fields in the field data object. 
		 */
		virtual	unsigned int GetFieldCount(  ) = 0;

		/**
		 * Returns the id of the field with the highest id. NOTE! If no fields exist in 
		 * the field data object, the return is undefined. 
		 * @return The id of the field with the highest id. 
		 */
		virtual	rid GetMaxFieldId(  ) = 0;

		/**
		 * Returns the handle of the first field, or null if no fields are added to the 
		 * object. 
		 * @return The handle of the first field. 
		 */
		virtual	rhandle GetFirstFieldHandle(  ) = 0;

		/**
		 * Returns the next handle, or null if no more fields exist in the object. 
		 * @param hand The current handle. 
		 * @return The handle after the parameter handle. 
		 */
		virtual	rhandle GetNextFieldHandle( rhandle hand ) = 0;

		/**
		 * Returns the field associated with the specified handle. 
		 * @param hand The handle to the requested field. 
		 * @return The requested field 
		 */
		virtual	spValueArray GetFieldWithHandle( rhandle hand ) = 0;

		/**
		 * Resizes/Gets the list to the specified tuplecount. If the list is enlarged, 
		 * the new tuples will contain unspecified data. 
		 * @param tuplecount The desired tuple count. Value cannot be less than 0. Value 
		 * cannot be greater than INT_MAX. 
		 */
		virtual	void SetTupleCount( unsigned int tuplecount ) = 0;

		/**
		 * Resizes/Gets the list to the specified tuplecount. If the list is enlarged, 
		 * the new tuples will contain unspecified data. 
		 */
		virtual	unsigned int GetTupleCount(  ) = 0;

		/**
		 * Adds a number of tuples to the current tuple count. 
		 * @param tuplecount The desired number of tuples to add. Note that the total 
		 * TupleCount cannot exceed INT_MAX. Value cannot be less than 0. Value cannot 
		 * be greater than INT_MAX. 
		 */
		virtual	void AddTupleCount( unsigned int tuplecount ) = 0;

		/**
		 * Returns the id of the last tuple in the array. If the array is empty, the value 
		 * is undefined. 
		 * @return The id of the last tuple in the array 
		 */
		virtual	rid GetMaxTupleId(  ) = 0;

		/**
		 * CopyTuple() copies one tuple to another. Both the dest_id and the source_id 
		 * must exist in the array. This field data object can be used as the source field 
		 * data object to copy within the object. 
		 * @param source The source field data to copy from. 
		 * @param dest_id The tuple index to copy into in this field data. 
		 * @param src_id The tuple index to copy from in the source field data. 
		 */
		virtual	void CopyTuple( spFieldData source , rid dest_id , rid src_id ) = 0;

		/**
		 * CopyCombineTuples() combines the data from two tuples into a destination tuple. 
		 * This field data object can be used as the source field data object to copy 
		 * within the object. 
		 * @param source The field data source to combine from. 
		 * @param dest_id The tuple index to put the combined results into in this field 
		 * data. 
		 * @param src_id_1 The first tuple index to use for combining from the field data 
		 * source. 
		 * @param src_id_2 The second tuple index to use for combining from the field 
		 * data source. 
		 * @param alpha The interpolation value used for combining the source tuples. 
		 *  
		 */
		virtual	void CopyCombineTuples( spFieldData source , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * CopyCombine3Tuples combines the data from three tuples into a destination tuple. 
		 * The call works like CobineTuples, but there is three source tuples, and two 
		 * alpha values. the destination will be weighted by the values: alpha_3 = 1-(alpha_1 
		 * + alpha_2) dest = src_1*alpha_1 + src_2*alpha_2 + src_3*alpha_3 This field 
		 * data object can be used as the source field data object to copy within the 
		 * object. 
		 * @param source The field data source to combine from. 
		 * @param dest_id The tuple index to put the combined results into in this field 
		 * data. 
		 * @param src_id_1 The first tuple index to use for combining from the field data 
		 * source. 
		 * @param src_id_2 The second tuple index to use for combining from the field 
		 * data source. 
		 * @param src_id_3 The third tuple index to use for combining from the field data 
		 * source. 
		 * @param alpha_1 The first interpolation value used for combining the source 
		 * tuples. 
		 * @param alpha_2 The second interpolation value used for combining the source 
		 * tuples. 
		 */
		virtual	void CopyCombine3Tuples( spFieldData source , rid dest_id , rid src_id_1 , rid src_id_2 , rid src_id_3 , real alpha_1 , real alpha_2 ) = 0;

		/**
		 * CopyRange() copies a range of tuples from a source field object into this field 
		 * object. The field objects must have the same field setup. This field object 
		 * must be resized to hold the tuples before copying. 
		 * @param source The source field object to copy from. 
		 * @param start_dest_id The first destination tuple id. 
		 * @param start_src_id The first source tuple id. 
		 * @param count The number of tuples to copy. 
		 */
		virtual	void CopyRange( spFieldData source , rid start_dest_id , rid start_src_id , unsigned int count ) = 0;

	};
	class IPackedGeometryData;
	class IRidArray;
	class IRealArray;
	class IBoolArray;
	class IValueArray;
	class IFieldData;
	class IMatrix4x4;

	/**
	 * GeometryData represents a geometric structure consisting of point data (Vertices) 
	 * and topological data (Triangles). GeometryData may represent a whole geometric 
	 * object, but can also be used by streaming data filters, and in this way, only 
	 * represents a part of the object. Different fields in the Vertices and Triangles 
	 * fields data objects will contain point data and topological data. The standard 
	 * naming convention used in the filters/renderers are as follows: (Case sensitive 
	 * naming, other fields may also be present) 'Coords' Positional coordinates of 
	 * a vertex, expressed with a 3-component real field (XYZ). 'TexCoords0' - 'TexCoords255' 
	 *  Texture coordinates of a vertex, expressed with a 2 components real field. 
	 * By convention, the existing fields must be sequential, and must start with 'TexCoord0'. 
	 *  'Normals' Normal vector for the vertex, expressed with a 3-component real field, 
	 * a normalized (XYZ) vector. 'VertexIds' The id of the current vertex in the primitive. 
	 * This field is present even if the vertex data is directly specified in the primitive 
	 * data, to specify topology. The field is of type rid. 'MaterialIds' The material 
	 * of the primitive. The field is of type rid. The 'Coords' and 'VertexIds' fields 
	 * always exist in the object, but the other fields are optional. Also, there can 
	 * exist user fields. 
	 */
	class IGeometryData : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IGeometryData is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IGeometryData",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IGeometryData 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IGeometryData pointer 
		 * @return a pointer to the IGeometryData object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static IGeometryData *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IGeometryData") )
				return static_cast<IGeometryData*>(ptr);
			return nullptr;
		}
		/**
		 * Creates another geometry data object with the same field setup. To also copy 
		 * the data to the new object, set copy_data to true. 
		 * @param copy_data If true, copies the data along with the GeometryData properties. 
		 *  
		 * @return The new geometry data object. 
		 */
		virtual	spGeometryData NewCopy( bool copy_data ) = 0;

		/**
		 * Creates a "packed" PackedGeometryData object, where all fields in the Corner 
		 * field data object is moved to the vertex field data object. Please note that 
		 * the vertex field data object will be enlarged to accommodate for data in a 
		 * vertex shared by multiple triangles, where the corner data differs between 
		 * the triangles. The method will fail if a Corner field is named the same as 
		 * an existing Vertices field, please make sure to remove any such field before 
		 * calling the method. 
		 * @return The new PackedGeometryData object. 
		 */
		virtual	spPackedGeometryData NewPackedCopy(  ) = 0;

		/**
		 * Copies the field setup and data from another object into this object. To only 
		 * copy the setup, set copy_data to false. 
		 * @param source The GeometryData object to copy from. 
		 * @param copy_data If true, copies the data along with the GeometryData properties. 
		 *  
		 */
		virtual	void DeepCopy( spGeometryData source , bool copy_data ) = 0;

		/**
		 * The number of vertices in the geometry. 
		 * @param count The desired new vertex count. Value cannot be less than 0. Value 
		 * cannot be greater than INT_MAX. 
		 */
		virtual	void SetVertexCount( unsigned int count ) = 0;

		/**
		 * The number of vertices in the geometry. 
		 */
		virtual	unsigned int GetVertexCount(  ) = 0;

		/**
		 * Increases the vertex count by the specified value. 
		 * @param count The number of vertices to add. 
		 */
		virtual	void AddVertices( unsigned int count ) = 0;

		/**
		 * The number of triangles in the geometry. The number of corners is always set 
		 * to (TriangleCount*3), so there is no specific method to set the number of corners. 
		 * @param count The desired new triangle count. Value cannot be less than 0. Value 
		 * cannot be greater than INT_MAX. 
		 */
		virtual	void SetTriangleCount( unsigned int count ) = 0;

		/**
		 * The number of triangles in the geometry. The number of corners is always set 
		 * to (TriangleCount*3), so there is no specific method to set the number of corners. 
		 *  
		 */
		virtual	unsigned int GetTriangleCount(  ) = 0;

		/**
		 * AddTriangles increases the triangle count by the specified value. 
		 * @param count The number of new triangles to add. 
		 */
		virtual	void AddTriangles( unsigned int count ) = 0;

		/**
		 * Each tuple in the "vertex_pairs" array contains the start-vertex and end-vertex 
		 * of a half-edge in the geometry. If a half-edge is found from a tuple in the 
		 * "vertex_pairs" array, the edge-id of that half-edge will be stored in the edge_ids 
		 * array. Do note: the half-edges are directed, so if you want all half-edges 
		 * that contains 2 vertices, you need to add the tuple twice. 
		 * @param vertex_pairs An array with tuplesize 2, which contains start and end-vertex 
		 * of the edges you want to find. 
		 * @param edge_ids Will contain all edge-ids that were found from the vertex-pairs. 
		 * The function will replace all previous data in this array. 
		 */
		virtual	void FindEdgeIdsFromVertexPairs( spRidArray vertex_pairs , spRidArray edge_ids ) = 0;

		/**
		 * The Coords field in the vertices. (Field name: "Coords", Tuple size: 3 , Stored 
		 * as: Vertex attribute) 
		 * @return The array of coords. 
		 */
		virtual	spRealArray GetCoords(  ) = 0;

		/**
		 * Adds the VertexLocks field for the vertices. If the value for a vertex is true, 
		 * then the vertex should be locked, and not be removed in the collapse-process. 
		 * (Field name: "VertexLocks", Tuple size: 1 , Stored as: Vertex attribute) 
		 */
		virtual	void AddVertexLocks(  ) = 0;

		/**
		 * Removes the VertexLocks field for the vertices. If the value for a vertex is 
		 * true, then the vertex should be locked, and not be removed in the collapse-process. 
		 * (Field name: "VertexLocks", Tuple size: 1 , Stored as: Vertex attribute) 
		 */
		virtual	void RemoveVertexLocks(  ) = 0;

		/**
		 * The VertexLocks field for the vertices. If the value for a vertex is true, 
		 * then the vertex should be locked, and not be removed in the collapse-process. 
		 * (Field name: "VertexLocks", Tuple size: 1 , Stored as: Vertex attribute) 
		 */
		virtual	spBoolArray GetVertexLocks(  ) = 0;

		/**
		 * Adds the BoneWeights and BoneIds fields in the vertices. The BoneWeights and 
		 * BoneIds fields are added and removed in unison, and should always be the same 
		 * tuple size. (Field names: "BoneWeights" & "BoneIds", Tuple size: varying , 
		 * Stored as: Vertex attribute) 
		 * @param tuplesize The number of bones allowed per vertex. 
		 */
		virtual	void AddBoneWeights( unsigned int tuplesize ) = 0;

		/**
		 * Removes the BoneWeights and BoneIds fields in the vertices. The BoneWeights 
		 * and BoneIds fields are added and removed in unison, and should always be the 
		 * same tuple size. (Field names: "BoneWeights" & "BoneIds", Tuple size: varying 
		 * , Stored as: Vertex attribute) 
		 */
		virtual	void RemoveBoneWeights(  ) = 0;

		/**
		 * The BoneWeights field in the vertices. (Field name: "BoneWeights", Tuple size: 
		 * varying , Stored as: Vertex attribute) 
		 * @return The array containing the bone weights 
		 */
		virtual	spRealArray GetBoneWeights(  ) = 0;

		/**
		 * The BoneIds fields in the vertices. (Field name: "BoneIds", Tuple size: varying 
		 * , Stored as: Vertex attribute) 
		 * @return The array containing the bone ids, i.e. the bones per vertex that affects 
		 * them 
		 */
		virtual	spRidArray GetBoneIds(  ) = 0;

		/**
		 * Adds the VertexWeights field for the vertices. The weights are used to determine 
		 * how important it is to keep the vertices when the geometry is reduced. 1 means 
		 * the weight won't change the importance, values closer to 0 means it will be 
		 * less important, values > 1 means the vertex is more important and less probable 
		 * to be removed. (Field name: "VertexWeights", Tuple size: 1 , Stored as: Vertex 
		 * attribute) 
		 */
		virtual	void AddVertexWeights(  ) = 0;

		/**
		 * Removes the VertexWeights field for the vertices. The weights are used to determine 
		 * how important it is to keep the vertices when the geometry is reduced. 1 means 
		 * the weight won't change the importance, values closer to 0 means it will be 
		 * less important, values > 1 means the vertex is more important and less probable 
		 * to be removed. (Field name: "VertexWeights", Tuple size: 1 , Stored as: Vertex 
		 * attribute) 
		 */
		virtual	void RemoveVertexWeights(  ) = 0;

		/**
		 * The VertexWeights field for the vertices. The weights are used to determine 
		 * how important it is to keep the vertices when the geometry is reduced. 1 means 
		 * the weight won't change the importance, values closer to 0 means it will be 
		 * less important, values > 1 means the vertex is more important and less probable 
		 * to be removed. (Field name: "VertexWeights", Tuple size: 1 , Stored as: Vertex 
		 * attribute) 
		 * @return The array of vertex weights 
		 */
		virtual	spRealArray GetVertexWeights(  ) = 0;

		/**
		 * Adds a user-specified vertex field. To be able to add a field, it must have 
		 * a name that does not conflict with the existing vertex fields. 
		 * @param field The field to add to this GeometryData object. 
		 */
		virtual	void AddUserVertexField( spValueArray field ) = 0;

		/**
		 * Removes a user-specified vertex field. 
		 * @param name The name of the user vertex field to be removed from the GeometryData 
		 * object. 
		 */
		virtual	void RemoveUserVertexField( const char * name ) = 0;

		/**
		 * Gets a user-specified vertex field. 
		 * @param name The name of the user vertex field to be fetched from the GeometryData 
		 * object. 
		 * @return The requested user-specified vertex field. 
		 */
		virtual	spValueArray GetUserVertexField( const char * name ) = 0;

		/**
		 * Adds a user-specified vertex field. To be able to add a field, it must have 
		 * a name that does not conflict with the existing vertex fields. 
		 * @param base_type The BaseType of the new user field, data types are listed 
		 * in BaseTypes. 
		 * @param name The name of the new user field. 
		 * @param tuple_size The tuple size of the new user field, defaults to 1 if not 
		 * specified. 
		 * @return Pointer to the created array. 
		 */
		virtual	spValueArray AddBaseTypeUserVertexField( Simplygon::EBaseTypes base_type , const char * name , unsigned int tuple_size ) = 0;

		/**
		 * Copies all fields in the specified vertex in the source geometry to the destination 
		 * vertex in this geometry. 
		 * @param source The GeometryData object to copy from. 
		 * @param dest_id The vertex id to replace in this GeometryData object. 
		 * @param src_id The id of the vertex to copy. 
		 */
		virtual	void CopyVertex( spGeometryData source , rid dest_id , rid src_id ) = 0;

		/**
		 * Combines the fields of two vertices by linear interpolation into the destination 
		 * vertex. 
		 * @param source The GeometryData object to combine from. 
		 * @param dest_id The vertex id to replace in this GeometryData object. 
		 * @param src_id_1 The first vertex id to combine from. 
		 * @param src_id_2 The second vertex id to combine from. 
		 * @param alpha The interpolation value between 0 and 1. 
		 */
		virtual	void CopyCombineVertices( spGeometryData source , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Combines the fields of three vertices via barycentric coordinates. alpha_3 
		 * = 1-(alpha_1 + alpha_2) dest = src_1*alpha_1 + src_2*alpha_2 + src_3*alpha_3. 
		 * @param source The GeometryData object to combine from. 
		 * @param dest_id The vertex id to replace in this GeometryData object. 
		 * @param src_id_1 The first vertex id to combine from. 
		 * @param src_id_2 The second vertex id to combine from. 
		 * @param src_id_3 The third vertex id to combine from. 
		 * @param alpha_1 The first interpolation value. 
		 * @param alpha_2 The first interpolation value. 
		 */
		virtual	void CopyCombine3Vertices( spGeometryData source , rid dest_id , rid src_id_1 , rid src_id_2 , rid src_id_3 , real alpha_1 , real alpha_2 ) = 0;

		/**
		 * Retrieves the IFieldData object that contains the vertex fields. 
		 * @return The vertex fields. 
		 */
		virtual	spFieldData GetVertices(  ) = 0;

		/**
		 * The VertexIds field in the corners. 
		 * @return The VertexIds field. 
		 */
		virtual	spRidArray GetVertexIds(  ) = 0;

		/**
		 * Adds a TexCoords field in the corners. The valid id range of the level parameter 
		 * is 0-255, which equals fields 'TexCoords0' - 'TexCoords255' (Field name: "TexCoords0" 
		 * - "TexCoords255", Tuple size: 2 , Stored as: Corner attribute) 
		 * @param level The id of the texture field to add. 
		 */
		virtual	void AddTexCoords( rid level ) = 0;

		/**
		 * Adds a named TexCoords field in the corners. (Field name: "TexCoords0" - "TexCoords255", 
		 * Tuple size: 2 , Stored as: Corner attribute) 
		 * @param alternative_name The name of the texcoord level i.e. 'TexCoord0'. 
		 */
		virtual	rid AddNamedTexCoords( const char * alternative_name ) = 0;

		/**
		 * Removes a TexCoords field in the corners. The valid id range of the level parameter 
		 * is 0-255, which equals fields 'TexCoords0' - 'TexCoords255' (Field name: "TexCoords0" 
		 * - "TexCoords255", Tuple size: 2 , Stored as: Corner attribute) 
		 * @param level The id of the texture field to remove. 
		 */
		virtual	void RemoveTexCoords( rid level ) = 0;

		/**
		 * Removes a named TexCoords field in the corners. 'TexCoords0' - 'TexCoords255' 
		 * (Field name: "TexCoords0" - "TexCoords255", Tuple size: 2 , Stored as: Corner 
		 * attribute) 
		 * @param alternative_name The name of the texcoord level i.e. 'TexCoord0'. 
		 */
		virtual	bool RemoveNamedTexCoords( const char * alternative_name ) = 0;

		/**
		 * Gets a TexCoords field in the corners. The valid id range of the level parameter 
		 * is 0-255, which equals fields 'TexCoords0' - 'TexCoords255' (Field name: "TexCoords0" 
		 * - "TexCoords255", Tuple size: 2 , Stored as: Corner attribute). 
		 * @param level The id of the texture field to get. 
		 * @return The requested field 
		 */
		virtual	spRealArray GetTexCoords( rid level ) = 0;

		/**
		 * Gets a TexCoords field, using the alternative name instead of the index. 
		 * @param alternative_name The alternative name of the field. 
		 * @return The requested field if it was found, or null if not. 
		 */
		virtual	spRealArray GetNamedTexCoords( const char * alternative_name ) = 0;

		/**
		 * Adds Tangents and Bitangents fields in the corners. The valid id range of the 
		 * level parameter is 0-255. (Field names: "Tangents0" - "Tangents255" & "Bitangents0" 
		 * - "Bitangents255", Tuple size: 3 , Stored as: Corner attribute) 
		 * @param level The texture channel. 
		 */
		virtual	void AddTangents( rid level ) = 0;

		/**
		 * Removes Tangents and Bitangents fields in the corners. The valid id range of 
		 * the level parameter is 0-255. (Field names: "Tangents0" - "Tangents255" & "Bitangents0" 
		 * - "Bitangents255", Tuple size: 3 , Stored as: Corner attribute) 
		 * @param level The texture channel. 
		 */
		virtual	void RemoveTangents( rid level ) = 0;

		/**
		 * Gets a Tangents field in the corners. The valid id range of the level parameter 
		 * is 0-255. (Field name: "Tangents0" - "Tangents255", Tuple size: 3 , Stored 
		 * as: Corner attribute) 
		 * @param level The texture channel. 
		 * @return The tangent field for the selected texture channel. 
		 */
		virtual	spRealArray GetTangents( rid level ) = 0;

		/**
		 * Gets a Bitangents field in the corners. The valid id range of the level parameter 
		 * is 0-255. (Field name: "Bitangents0" - "Bitangents255", Tuple size: 3 , Stored 
		 * as: Corner attribute) 
		 * @param level The texture channel. 
		 * @return The bi-tangent field for the selected texture channel. 
		 */
		virtual	spRealArray GetBitangents( rid level ) = 0;

		/**
		 * Adds the Normals field in the corners. (Field name: "Normals" , Tuple size: 
		 * 3 , Stored as: Corner attribute) 
		 */
		virtual	void AddNormals(  ) = 0;

		/**
		 * Removes the Normals field in the corners. (Field name: "Normals" , Tuple size: 
		 * 3 , Stored as: Corner attribute) 
		 */
		virtual	void RemoveNormals(  ) = 0;

		/**
		 * The Normals field in the corners. (Field name: "Normals" , Tuple size: 3 , 
		 * Stored as: Corner attribute) 
		 * @return The normals field 
		 */
		virtual	spRealArray GetNormals(  ) = 0;

		/**
		 * The vertex colors in the input channel from the corners the geometry. The valid 
		 * id range of the channel parameter is 0-255, which equals fields 'Colors0' - 
		 * 'Colors255' (Field name: 'Color0'-'Color255' which is stored as attribute per 
		 * corner) 
		 * @param channel The channel to retrieve the vertex colors for(0-255) 
		 */
		virtual	void AddColors( rid channel ) = 0;

		/**
		 * Adds a named Color field in the corners. (Field name: "Colors0" - "Colors255", 
		 * Tuple size: 4 , Stored as: Corner attribute) 
		 * @param alternative_name The named color channel "Colors0" - "Colors255". 
		 */
		virtual	rid AddNamedColors( const char * alternative_name ) = 0;

		/**
		 * Removes a Color field in the corners. The valid id range of the level parameter 
		 * is 0-255, which equals fields 'Colors0' - 'Colors255' (Field name: "Colors0" 
		 * - "Colors255", Tuple size: 4 , Stored as: Corner attribute) 
		 * @param level The color level (0-255) 
		 */
		virtual	void RemoveColors( rid level ) = 0;

		/**
		 * Removes a named Color field in the corners. (Field name: "Colors0" - "Colors255", 
		 * Tuple size: 4 , Stored as: Corner attribute) 
		 * @param alternative_name The named color channel "Colors0" - "Colors255". 
		 */
		virtual	bool RemoveNamedColors( const char * alternative_name ) = 0;

		/**
		 * Gets a Color field in the corners. The valid id range of the level parameter 
		 * is 0-255, which equals fields 'Colors0' - 'Colors255' (Field name: "Colors0" 
		 * - "Colors255", Tuple size: 4 , Stored as: Corner attribute) 
		 * @param level The color level (0-255) 
		 * @return The color field 
		 */
		virtual	spRealArray GetColors( rid level ) = 0;

		/**
		 * Gets a Color field, using the alternative name instead of the index. 
		 * @param alternative_name The alternative name of the field. 
		 * @return The requested field, if it was found, or null if not 
		 */
		virtual	spRealArray GetNamedColors( const char * alternative_name ) = 0;

		/**
		 * Adds a user-specified corner field. To be able to add a field, it must have 
		 * a name that does not conflict with the existing corner fields. 
		 * @param field The field to add into the GeometryData object. 
		 */
		virtual	void AddUserCornerField( spValueArray field ) = 0;

		/**
		 * Removes a user-specified corner field. 
		 * @param name The name of the field to remove from the GeometryData object. 
		 */
		virtual	void RemoveUserCornerField( const char * name ) = 0;

		/**
		 * Gets a user-specified corner field. 
		 * @param name The name of the field to get. 
		 * @return The requested field 
		 */
		virtual	spValueArray GetUserCornerField( const char * name ) = 0;

		/**
		 * Adds an empty user-specified corner field. 
		 * @param base_type Specifies the base type of the new corner field, data types 
		 * are listed in BaseTypes. 
		 * @param name The name of the field to add. 
		 * @param tuple_size The tuple size of the new field, defaults to 1 if not specified. 
		 *  
		 * @return Pointer to the created field 
		 */
		virtual	spValueArray AddBaseTypeUserCornerField( Simplygon::EBaseTypes base_type , const char * name , unsigned int tuple_size ) = 0;

		/**
		 * Copies all fields in the specified corner in the source geometry to the destination 
		 * corner in this geometry . 
		 * @param source The GeometryData object to copy from. 
		 * @param dest_id The vertex id to replace in this GeometryData object. 
		 * @param src_id The id of the vertex to copy. 
		 */
		virtual	void CopyCorner( spGeometryData source , rid dest_id , rid src_id ) = 0;

		/**
		 * Combines the fields of two corners by linear interpolation into the destination 
		 * corner. 
		 * @param source The GeometryData object to combine from. 
		 * @param dest_id The corner id to replace in this GeometryData object. 
		 * @param src_id_1 The first corner id to combine from. 
		 * @param src_id_2 The second corner id to combine from. 
		 * @param alpha The interpolation value between 0 and 1. 
		 */
		virtual	void CopyCombineCorners( spGeometryData source , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Combines three corners via barycentric coordinates. alpha_3 = 1-(alpha_1 + 
		 * alpha_2) dest = src_1*alpha_1 + src_2*alpha_2 + src_3*alpha_3. 
		 * @param source The GeometryData object to combine from. 
		 * @param dest_id The corner id to replace in this GeometryData object. 
		 * @param src_id_1 The first corner id to combine from. 
		 * @param src_id_2 The second corner id to combine from. 
		 * @param src_id_3 The third corner id to combine from. 
		 * @param alpha_1 The first interpolation value. 
		 * @param alpha_2 The second interpolation value. 
		 */
		virtual	void CopyCombine3Corners( spGeometryData source , rid dest_id , rid src_id_1 , rid src_id_2 , rid src_id_3 , real alpha_1 , real alpha_2 ) = 0;

		/**
		 * Retrieves the IFieldData object that contains the corner fields. 
		 * @return The corner IFieldData 
		 */
		virtual	spFieldData GetCorners(  ) = 0;

		/**
		 * Adds the MaterialIds field in the triangles. (Field name: "MaterialIds", Tuple 
		 * size: 1 , Stored as: triangle attribute) 
		 */
		virtual	void AddMaterialIds(  ) = 0;

		/**
		 * Removes the MaterialIds field in the triangles. (Field name: "MaterialIds", 
		 * Tuple size: 1 , Stored as: triangle attribute) 
		 */
		virtual	void RemoveMaterialIds(  ) = 0;

		/**
		 * The MaterialIds field in the triangles. (Field name: "MaterialIds", Tuple size: 
		 * 1 , Stored as: triangle attribute) 
		 * @return The MaterialIds field 
		 */
		virtual	spRidArray GetMaterialIds(  ) = 0;

		/**
		 * Adds the GroupIds field in the triangles. (Field name: "GroupIds", Tuple size: 
		 * 1 , Stored as: triangle attribute) 
		 */
		virtual	void AddGroupIds(  ) = 0;

		/**
		 * Removes the GroupIds field in the triangles. (Field name: "GroupIds", Tuple 
		 * size: 1 , Stored as: triangle attribute) 
		 */
		virtual	void RemoveGroupIds(  ) = 0;

		/**
		 * The GroupIds field in the triangles. (Field name: "GroupIds", Tuple size: 1 
		 * , Stored as: triangle attribute) 
		 */
		virtual	spRidArray GetGroupIds(  ) = 0;

		/**
		 * Adds a user-specified triangle field. To be able to add a field, it must have 
		 * a name that does not conflict with the existing triangle fields. 
		 * @param field The triangle field to add to the GeometryData object. 
		 */
		virtual	void AddUserTriangleField( spValueArray field ) = 0;

		/**
		 * Removes a user-specified triangle field. 
		 * @param name The name of the triangle field to remove from the GeometryData 
		 * object. 
		 */
		virtual	void RemoveUserTriangleField( const char * name ) = 0;

		/**
		 * Gets a user-specified triangle field. 
		 * @param name The name of the triangle field to get from the GeometryData object. 
		 *  
		 * @return The requested triangle field 
		 */
		virtual	spValueArray GetUserTriangleField( const char * name ) = 0;

		/**
		 * Adds an empty user-specified triangle field. 
		 * @param base_type The base_type of the new user triangle field, data types are 
		 * listed in BaseTypes. 
		 * @param name The name of the triangle field to add to the GeometryData object. 
		 *  
		 * @param tuple_size The tuple size of the new field, deafaults to 1 if not specified. 
		 *  
		 * @return Pointer to the newly created triangle field 
		 */
		virtual	spValueArray AddBaseTypeUserTriangleField( Simplygon::EBaseTypes base_type , const char * name , unsigned int tuple_size ) = 0;

		/**
		 * Copies all fields in the specified triangle in the source geometry to the destination 
		 * triangle in this geometry. 
		 * @param source The GeometryData object to copy from. 
		 * @param dest_id The triangle id to replace in this GeometryData object. 
		 * @param src_id The id of the triangle to copy. 
		 */
		virtual	void CopyTriangle( spGeometryData source , rid dest_id , rid src_id ) = 0;

		/**
		 * Combines the fields of two triangles by linear interpolation into the destination 
		 * triangle. 
		 * @param source The GeometryData object to combine from. 
		 * @param dest_id The triangle id to replace in this GeometryData object. 
		 * @param src_id_1 The first triangle id to combine from. 
		 * @param src_id_2 The second triangle id to combine from. 
		 * @param alpha The interpolation value between 0 and 1. 
		 */
		virtual	void CopyCombineTriangles( spGeometryData source , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Combines the fields of three triangles via barycentric coordinates. alpha_3 
		 * = 1-(alpha_1 + alpha_2) dest = src_1*alpha_1 + src_2*alpha_2 + src_3*alpha_3. 
		 * @param source The GeometryData object to combine from. 
		 * @param dest_id The triangle id to replace in this GeometryData object. 
		 * @param src_id_1 The first triangle id to combine from. 
		 * @param src_id_2 The second triangle id to combine from. 
		 * @param src_id_3 The third triangle id to combine from. 
		 * @param alpha_1 The first interpolation value. 
		 * @param alpha_2 The second interpolation value. 
		 */
		virtual	void CopyCombine3Triangles( spGeometryData source , rid dest_id , rid src_id_1 , rid src_id_2 , rid src_id_3 , real alpha_1 , real alpha_2 ) = 0;

		/**
		 * Retrieves the IFieldData object that contains the triangle fields. 
		 * @return The triangle field data object. 
		 */
		virtual	spFieldData GetTriangles(  ) = 0;

		/**
		 * Adds a custom field. To be able to add a field, it must have a name that does 
		 * not conflict with the existing custom fields. 
		 * @param field The custom field to add to the GeometryData object. 
		 */
		virtual	void AddCustomField( spValueArray field ) = 0;

		/**
		 * Removes a custom field. 
		 * @param name The name of the custom field to remove from the GeometryData object. 
		 *  
		 */
		virtual	void RemoveCustomField( const char * name ) = 0;

		/**
		 * Gets a custom field. 
		 * @param name The name of the custom field to get from the GeometryData object. 
		 *  
		 * @return The requested custom field 
		 */
		virtual	spValueArray GetCustomField( const char * name ) = 0;

		/**
		 * Adds an empty custom field. To be able to add a field, it must have a name 
		 * that does not conflict with the existing custom fields. 
		 * @param base_type The base_type of the new custom field, data types are listed 
		 * in BaseTypes. 
		 * @param name The name of the new custom field. 
		 * @param tuple_size The tuple size of the new custom field, defaults to 1 if 
		 * not specified. 
		 * @return Pointer to the created field 
		 */
		virtual	spValueArray AddBaseTypeCustomField( Simplygon::EBaseTypes base_type , const char * name , unsigned int tuple_size ) = 0;

		/**
		 * Finds all Nan (1.#IND, 1.#INF etc) values in the real/float/double arrays in 
		 * the GeometryData, and sets them to 0.0 just to make sure all numbers in the 
		 * GeometryData are legit. Should not be needed if all the data loaded into the 
		 * GeometryData object is ok to begin with. 
		 */
		virtual	void CleanupNanValues(  ) = 0;

		/**
		 * Finds triangles that contain the same vertex more than once, and invalidates 
		 * them, ie. sets all the vertex id references to -1. These triangles can be culled 
		 * using Compact(). 
		 */
		virtual	void CleanupInvalidTriangles(  ) = 0;

		/**
		 * Returns the level index of the texcoord field with the name returns -1 if not 
		 * found. 
		 * @param field_name The named TexCoord field to be fetched. 
		 * @return The index of the field 
		 */
		virtual	rid FindNamedTexCoordsIndex( const char * field_name ) = 0;

		/**
		 * Returns the level index of the colors field with the name returns -1 if not 
		 * found. 
		 * @param field_name The named Colors field to be fetched. 
		 * @return The index of the field 
		 */
		virtual	rid FindNamedColorsIndex( const char * field_name ) = 0;

		/**
		 * Returns an axis aligned bounding box GeometryData of this geometry. 
		 * @return The AABB GeometryData 
		 */
		virtual	spGeometryData CreateAABB(  ) = 0;

		/**
		 * Expands the Vertices field data so that there exists one vertex for each of 
		 * the three corners of each triangle in the geometry. The vertices will be organized 
		 * identical to the Corners field. The triangles will be remapped to use the new 
		 * vertices correctly. Expanding the vertex field is required to be able to extract 
		 * a range of the geometry, and to be able to stream it. Note! This will lead 
		 * to increased memory requirement, as vertex data is not shared among neigbouring 
		 * triangles. It also removes the connectivity information of the triangles, and 
		 * effectively detaches all triangles from one another. This call may replace 
		 * fields in the Vertices field data. Requery any previously cached field pointer 
		 * after the call. All user fields are copied as well. 
		 */
		virtual	void ExpandVertices(  ) = 0;

		/**
		 * Extracts a range of triangles with their vertices from the geometry. ExpandVertices() 
		 * must first be called for the extraction to succeed. ExtractGeometry() can be 
		 * used to stream geometries in chunks. If writing to a stream, the extracted 
		 * geometry is guaranteed to have the same setup as the original. Any previous 
		 * data in the destination will be deleted. 
		 * @param dest The GeometryData object that is written to. 
		 * @param start_tri_id The first triangle to be extracted. 
		 * @param count The number of triangles to extract. 
		 */
		virtual	void ExtractRange( spGeometryData dest , rid start_tri_id , unsigned int count ) = 0;

		/**
		 * Extracts specified triangles from the geometry. The destination geometry will 
		 * contain the triangles and vertices. The vertices in the destination will be 
		 * expanded so that there exists one vertex for each of the three corners of each 
		 * triangle in the geometry. 
		 * @param dest The GeometryData object that is written to. 
		 * @param triangle_ids The list of triangles indices to extract. 
		 */
		virtual	void ExtractTriangles( spGeometryData dest , spRidArray triangle_ids ) = 0;

		/**
		 * Appends the geometry data to this geometry. This geometry will contain all 
		 * triangles and vertices of both geometries. The VertexIds that are copied from 
		 * the source are remapped to point at the vertices, which are appended to the 
		 * end of the current vertices. Any field in the appended geometry that does not 
		 * exist in this geometry will be added, with the tuples that are added set to 
		 * 0. The method will fail if the source geometry has identically named fields, 
		 * but with different tuple sizes or base types. 
		 * @param source The source geometry that will be appended to this geometry. the 
		 * contents of source will not be modified. 
		 */
		virtual	void AppendGeometry( spGeometryData source ) = 0;

		/**
		 * Removes invalid triangles and vertices not referenced by any triangle. If any 
		 * vertices are removed, the triangles will be remapped to the new compacted vertex 
		 * field. 
		 * @param only_compact_triangles If true, no vertices will be removed. 
		 */
		virtual	void Compact( bool only_compact_triangles ) = 0;

		/**
		 * Welds all vertices in the geometry that are closer than the welding threshold. 
		 * Non-referenced vertices will not be removed, only the vertex indices will be 
		 * remapped. Call Compact() to clean up the geometry and free up memory. 
		 * @param threshold The welding threshold distance. 
		 */
		virtual	void Weld( real threshold ) = 0;

		/**
		 * The inferior (minimum) extent of the geometry. 
		 * @return The returned data array. The array contains 3 items. 
		 */
		virtual	spRealData GetInf(  ) = 0;

		/**
		 * The inferior (minimum) extent of the geometry. 
		 * @param vec_realInputDataPtr The new inferior. 
		 */
		virtual	void SetInf( const real *vec_realInputDataPtr ) = 0;

		/**
		 * The superior (maximum) extent of the geometry. 
		 * @return The returned data array. The array contains 3 items. 
		 */
		virtual	spRealData GetSup(  ) = 0;

		/**
		 * The superior (maximum) extent of the geometry. 
		 * @param vec_realInputDataPtr The new superior. 
		 */
		virtual	void SetSup( const real *vec_realInputDataPtr ) = 0;

		/**
		 * Calculate the extents by checking the coordinates of all vertices in the geometry. 
		 * Set only_triangles to true to test only vertices that are indexed by a triangle. 
		 * This is a slower test, and the bounding box may not encompass all vertices' 
		 * positions. the new extents are found by calling GetInf() and GetSup() afterwards. 
		 * @param only_triangles True if only vertices indexed by triangles should be 
		 * checked, defaults to false if not specified. 
		 */
		virtual	void CalculateExtents( bool only_triangles ) = 0;

		/**
		 * Tests if the extents of the geometry fully contain all vertex coordinates. 
		 * Note! ExtentsContainCoords() checks all vertices in the geometry, regardless 
		 * to whether the vertex is referenced by any triangle. Use Compact() to remove 
		 * any non-referenced vertex before calling ExtentsContainCoords. 
		 * @return True if geometry fully contain all vertex coordinates 
		 */
		virtual	bool ExtentsContainCoords(  ) = 0;

		/**
		 * Transforms the geometry using the supplied matrix transformation. The fields 
		 * that are modified are the Coords field of Vertices, as well as the Normals 
		 * and all Tangent and Bi-tangent fields of the Corners. 
		 * @param transformation The 4x4 transformation as a IMatrix4x4. 
		 */
		virtual	void Transform( spMatrix4x4 transformation ) = 0;

		/**
		 * Detect triangle edge neighbors. Neighbor ids are stored in the "SgEdgeNeighbours" 
		 * Corner field. 
		 */
		virtual	void DetectEdgeNeighbours(  ) = 0;

		/**
		 * Converts the handedness of the triangle winding, coords, normals and texture 
		 * coordinates of the geometry from left-handed to right-handed coordinate systems 
		 * and vice versa. Simplygon generally uses right-handed coordinates, so this 
		 * conversion needs to be done before processing any left-handed geometry. 
		 */
		virtual	void ConvertHandedness(  ) = 0;

		/**
		 * Change winding. 
		 */
		virtual	void ChangeWinding(  ) = 0;

	};
	class IGeometryData;
	class IRidArray;
	class IRealArray;
	class IBoolArray;
	class IValueArray;
	class IFieldData;

	/**
	 * PackedGeometryData keeps the same information as GeometryData, but with all 
	 * corner data fields moved into per-vertex fields. No per-corner fields exist, 
	 * apart from the VertexIds field. Please note that the number of vertices in an 
	 * PackedGeometryData is commonly higher than in an GeometryData, as vertices must 
	 * be split to accommodate for different corner data. 
	 */
	class IPackedGeometryData : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IPackedGeometryData is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IPackedGeometryData",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IPackedGeometryData 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IPackedGeometryData pointer 
		 * @return a pointer to the IPackedGeometryData object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IPackedGeometryData *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IPackedGeometryData") )
				return static_cast<IPackedGeometryData*>(ptr);
			return nullptr;
		}
		/**
		 * Creates another geometry data object with the same field setup. To also copy 
		 * the data to the new object, set copy_data to true. 
		 * @param copy_data Determines if the data is included in the new copy. 
		 * @return The new packed geometry data object. 
		 */
		virtual	spPackedGeometryData NewCopy( bool copy_data ) = 0;

		/**
		 * Creates an "unpacked" GeometryData object. Please note that since the data 
		 * in the PackedGeometryData structure is per-vertex, you may have to weld the 
		 * resulting GeometryData to remove vertices with the same spatial coordinates. 
		 * @return The new unpacked geometry data object. 
		 */
		virtual	spGeometryData NewUnpackedCopy(  ) = 0;

		/**
		 * Copies the field setup and data from another object. To only copy the setup, 
		 * set copy_data to false. 
		 * @param source The source from which the data will be copied. 
		 * @param copy_data The bool determining whether to copy the data or just the 
		 * field setup. 
		 */
		virtual	void DeepCopy( spPackedGeometryData source , bool copy_data ) = 0;

		/**
		 * Appends all vertex-tuples in "source" that don't already exists in the current 
		 * GeometryData. For each vertex field in this PackedGeometryData, the "source" 
		 * must contain a corresponding vertex or corner field. All extra-fields in "source" 
		 * will be skipped however. Returns the number of new and unique vertices created, 
		 * and the NewVertexIds will contain the indices for the triangles of the "source" 
		 * Geometry. The VertexIds of the current GeometryData will still be valid. If 
		 * collapseToOriginalVertices is set to true, all vertices from source will be 
		 * collapsed to the closest matching vertex of the current geometry. This means 
		 * that no new vertices will be added, so the returned value will always be 0. 
		 * If the "NewVertexIds"-array is not initiated before send into this function, 
		 * it will do nothing and return -1 instead, as error value. The method does not 
		 * append triangle ids or triangle field data from "source" to the current object. 
		 * @param source The geometry from which to append. 
		 * @param NewVertexIds Will be written to and contain the indices for the appended 
		 * geometries triangles. 
		 * @param collapseToOriginalVertices Will determine if the appended vertices are 
		 * collapsed to existing ones or not. 
		 * @return The number of unique verts added to the packed geometry 
		 */
		virtual	int AppendPackedGeometry( spGeometryData source , spRidArray NewVertexIds , bool collapseToOriginalVertices ) = 0;

		/**
		 * The number of vertices in the geometry. 
		 * @param count The new vertexcount. Value cannot be less than 0. Value cannot 
		 * be greater than INT_MAX. 
		 */
		virtual	void SetVertexCount( unsigned int count ) = 0;

		/**
		 * The number of vertices in the geometry. 
		 */
		virtual	unsigned int GetVertexCount(  ) = 0;

		/**
		 * AddVertices increases the vertex count by the specified value. 
		 * @param count The number of vertices to add. 
		 */
		virtual	void AddVertices( unsigned int count ) = 0;

		/**
		 * The number of triangles in the geometry. 
		 * @param count The number of triangles to add. Value cannot be less than 0. Value 
		 * cannot be greater than INT_MAX. 
		 */
		virtual	void SetTriangleCount( unsigned int count ) = 0;

		/**
		 * The number of triangles in the geometry. 
		 */
		virtual	unsigned int GetTriangleCount(  ) = 0;

		/**
		 * Increases the triangle count by the specified value. 
		 * @param count The number of triangles to add. 
		 * @return The current triangle count 
		 */
		virtual	void AddTriangles( unsigned int count ) = 0;

		/**
		 * The Coords field in the vertices. (Field name: "Coords", Tuple size: 3 , Stored 
		 * as: Vertex attribute) 
		 * @return The vertex coords array 
		 */
		virtual	spRealArray GetCoords(  ) = 0;

		/**
		 * Adds the VertexLocks field for the vertices. If the value for a vertex is true, 
		 * then the vertex should be locked, and not be removed in the collapse-process. 
		 * (Field name: "VertexLocks", Tuple size: 1 , Stored as: Vertex attribute) 
		 */
		virtual	void AddVertexLocks(  ) = 0;

		/**
		 * Removes the VertexLocks field for the vertices. If the value for a vertex is 
		 * true, then the vertex should be locked, and not be removed in the collapse-process. 
		 * (Field name: "VertexLocks", Tuple size: 1 , Stored as: Vertex attribute) 
		 */
		virtual	void RemoveVertexLocks(  ) = 0;

		/**
		 * The VertexLocks field for the vertices. If the value for a vertex is true, 
		 * then the vertex should be locked, and not be removed in the collapse-process. 
		 * (Field name: "VertexLocks", Tuple size: 1 , Stored as: Vertex attribute) 
		 * @return an array containing the vertex lock bools 
		 */
		virtual	spBoolArray GetVertexLocks(  ) = 0;

		/**
		 * Adds the BoneWeights and BoneIds fields in the vertices. The BoneWeights and 
		 * BoneIds fields are added and removed in unison, and should always be the same 
		 * tuple size. (Field names: "BoneWeights" & "BoneIds", Tuple size: varying , 
		 * Stored as: Vertex attribute) 
		 * @param tuplesize The size of the tuples in the new bone weight and bone id 
		 * field. 
		 */
		virtual	void AddBoneWeights( unsigned int tuplesize ) = 0;

		/**
		 * Removes the BoneWeights and BoneIds fields in the vertices. The BoneWeights 
		 * and BoneIds fields are added and removed in unison, and should always be the 
		 * same tuple size. (Field names: "BoneWeights" & "BoneIds", Tuple size: varying 
		 * , Stored as: Vertex attribute) 
		 */
		virtual	void RemoveBoneWeights(  ) = 0;

		/**
		 * The BoneWeights field. (Field name: "BoneWeights", Tuple size: varying , Stored 
		 * as: Vertex attribute) 
		 * @return The bone weights array 
		 */
		virtual	spRealArray GetBoneWeights(  ) = 0;

		/**
		 * The BoneIds field. (Field name: "BoneIds", Tuple size: varying , Stored as: 
		 * Vertex attribute) 
		 * @return The bone id array 
		 */
		virtual	spRidArray GetBoneIds(  ) = 0;

		/**
		 * Adds the VertexWeighting field for the vertices. (Field name: "VertexWeights", 
		 * Tuple size: 1 , Stored as: Vertex attribute) 
		 */
		virtual	void AddVertexWeighting(  ) = 0;

		/**
		 * Removes the VertexWeighting field for the vertices. (Field name: "VertexWeights", 
		 * Tuple size: 1 , Stored as: Vertex attribute) 
		 */
		virtual	void RemoveVertexWeighting(  ) = 0;

		/**
		 * The VertexWeighting field for the vertices. (Field name: "VertexWeights", Tuple 
		 * size: 1 , Stored as: Vertex attribute) 
		 * @return The vertex weighting array 
		 */
		virtual	spRealArray GetVertexWeighting(  ) = 0;

		/**
		 * Adds the VertexWeights field for the vertices. (Field name: "VertexWeights", 
		 * Tuple size: 1 , Stored as: Vertex attribute) 
		 */
		virtual	void AddVertexWeights(  ) = 0;

		/**
		 * Removes the VertexWeights field for the vertices. (Field name: "VertexWeights", 
		 * Tuple size: 1 , Stored as: Vertex attribute) 
		 */
		virtual	void RemoveVertexWeights(  ) = 0;

		/**
		 * The VertexWeights field for the vertices. (Field name: "VertexWeights", Tuple 
		 * size: 1 , Stored as: Vertex attribute) 
		 * @return The vertex weighting array 
		 */
		virtual	spRealArray GetVertexWeights(  ) = 0;

		/**
		 * Adds a TexCoords field in the vertices. The valid id range of the level parameter 
		 * is 0-255, which equals fields 'TexCoords0' - 'TexCoords255' (Field name: "TexCoords0" 
		 * - "TexCoords255", Tuple size: 2 , Stored as: Vertex attribute) 
		 * @param level The level of the new texcoord field. 
		 */
		virtual	void AddTexCoords( rid level ) = 0;

		/**
		 * Adds a named TexCoords field in the corners. (Field name: "TexCoords0" - "TexCoords255", 
		 * Tuple size: 2 , Stored as: Corner attribute) 
		 * @param alternative_name The name of the texcoord level i.e. 'TexCoord0'. 
		 */
		virtual	rid AddNamedTexCoords( const char * alternative_name ) = 0;

		/**
		 * Removes a TexCoords field in the vertices. The valid id range of the level 
		 * parameter is 0-255, which equals fields 'TexCoords0' - 'TexCoords255' (Field 
		 * name: "TexCoords0" - "TexCoords255", Tuple size: 2 , Stored as: Vertex attribute) 
		 * @param level The level of the texcoord field to remove. 
		 */
		virtual	void RemoveTexCoords( rid level ) = 0;

		/**
		 * Removes a named TexCoords field in the corners. 'TexCoords0' - 'TexCoords255' 
		 * (Field name: "TexCoords0" - "TexCoords255", Tuple size: 2 , Stored as: Corner 
		 * attribute) 
		 * @param alternative_name The name of the texcoord level i.e. 'TexCoord0'. 
		 */
		virtual	bool RemoveNamedTexCoords( const char * alternative_name ) = 0;

		/**
		 * Gets a TexCoords field in the vertices. The valid id range of the level parameter 
		 * is 0-255, which equals fields 'TexCoords0' - 'TexCoords255' (Field name: "TexCoords0" 
		 * - "TexCoords255", Tuple size: 2 , Stored as: Vertex attribute) 
		 * @param level The level of the texcoord field to get. 
		 * @return The texcoord array for the requested level 
		 */
		virtual	spRealArray GetTexCoords( rid level ) = 0;

		/**
		 * Gets a TexCoords field, using the alternative name instead of the index. 
		 * @param alternative_name The alternative name of the field. 
		 * @return The requested field, if it was found, or null if not 
		 */
		virtual	spRealArray GetNamedTexCoords( const char * alternative_name ) = 0;

		/**
		 * Adds a Tangents field in the vertices. (Field name: "Tangents0" - "Tangents255" 
		 * & "Bitangents0" - "Bitangents255", Tuple size: 3 , Stored as: Vertex attribute) 
		 * @param level The level of the new tangent fields. 
		 */
		virtual	void AddTangents( rid level ) = 0;

		/**
		 * Removes a Tangents field in the vertices. (Field name: "Tangents0" - "Tangents255" 
		 * & "Bitangents0" - "Bitangents255", Tuple size: 3 , Stored as: Vertex attribute) 
		 * @param level The level of the tangent fields to remove. 
		 */
		virtual	void RemoveTangents( rid level ) = 0;

		/**
		 * Gets a Tangents field in the vertices. (Field name: "Tangents0" - "Tangents255" 
		 * & "Bitangents0" - "Bitangents255", Tuple size: 3 , Stored as: Vertex attribute) 
		 * @param level The level of the tangent field to get. 
		 * @return The tangent array for the requested level 
		 */
		virtual	spRealArray GetTangents( rid level ) = 0;

		/**
		 * Gets a Bitangents field in the vertices. (Field name: "Tangents0" - "Tangents255" 
		 * & "Bitangents0" - "Bitangents255", Tuple size: 3 , Stored as: Vertex attribute) 
		 * @param level The level of the bitangent field to get. 
		 * @return The bitangent array for the requested level 
		 */
		virtual	spRealArray GetBitangents( rid level ) = 0;

		/**
		 * Adds the Normals field in the vertices. (Field name: "Normals" , Tuple size: 
		 * 3 , Stored as: Vertex attribute) 
		 */
		virtual	void AddNormals(  ) = 0;

		/**
		 * Removes the Normals field in the vertices. (Field name: "Normals" , Tuple size: 
		 * 3 , Stored as: Vertex attribute) 
		 */
		virtual	void RemoveNormals(  ) = 0;

		/**
		 * The Normals field in the vertices. (Field name: "Normals" , Tuple size: 3 , 
		 * Stored as: Vertex attribute) 
		 * @return The normals array 
		 */
		virtual	spRealArray GetNormals(  ) = 0;

		/**
		 * Adds a Color field in the vertices. The valid id range of the level parameter 
		 * is 0-255, which equals fields 'Colors0' - 'Colors255' (Field name: "Colors0" 
		 * - "Colors255", Tuple size: 4 , Stored as: Vertex attribute) 
		 * @param level The level of the Color field to add. 
		 */
		virtual	void AddColors( rid level ) = 0;

		/**
		 * Adds a named Color field in the corners. (Field name: "Colors0" - "Colors255", 
		 * Tuple size: 4 , Stored as: Corner attribute) 
		 * @param alternative_name The named color channel "Colors0" - "Colors255". 
		 */
		virtual	rid AddNamedColors( const char * alternative_name ) = 0;

		/**
		 * Removes a Color field in the vertices. The valid id range of the level parameter 
		 * is 0-255, which equals fields 'Colors0' - 'Colors255' (Field name: "Colors0" 
		 * - "Colors255", Tuple size: 4 , Stored as: Vertex attribute) 
		 * @param level The level of the Color field to remove. 
		 */
		virtual	void RemoveColors( rid level ) = 0;

		/**
		 * Removes a named Color field in the corners. (Field name: "Colors0" - "Colors255", 
		 * Tuple size: 4 , Stored as: Corner attribute) 
		 * @param alternative_name The named color channel "Colors0" - "Colors255". 
		 */
		virtual	bool RemoveNamedColors( const char * alternative_name ) = 0;

		/**
		 * Gets a Color field in the vertices. The valid id range of the level parameter 
		 * is 0-255, which equals fields 'Colors0' - 'Colors255' (Field name: "Colors0" 
		 * - "Colors255", Tuple size: 4 , Stored as: Vertex attribute) 
		 * @param level The level of the Colors field to get. 
		 * @return The colors array 
		 */
		virtual	spRealArray GetColors( rid level ) = 0;

		/**
		 * Gets a Color field, using the alternative name instead of the index. 
		 * @param alternative_name The alternative name of the field. 
		 * @return The requested field, if it was found, or null if not 
		 */
		virtual	spRealArray GetNamedColors( const char * alternative_name ) = 0;

		/**
		 * Adds a user-specified vertex field from an already populated value array. To 
		 * be able to add a field, it must have a name that does not conflict with the 
		 * existing vertex fields. 
		 * @param field The field that is to be added. 
		 */
		virtual	void AddUserVertexField( spValueArray field ) = 0;

		/**
		 * Removes a user-specified vertex field. 
		 * @param name The name of the field that is to be removed. 
		 */
		virtual	void RemoveUserVertexField( const char * name ) = 0;

		/**
		 * Gets a user-specified vertex field. 
		 * @param name The name of the field to be fetched. 
		 * @return The matching field, or null if no such field exists 
		 */
		virtual	spValueArray GetUserVertexField( const char * name ) = 0;

		/**
		 * Adds an empty user-specified vertex field. To be able to add a field, it must 
		 * have a name that does not conflict with the existing vertex fields. 
		 * @param base_type The type of data in the field, the alternatives can be found 
		 * in BaseTypes. 
		 * @param name The name of the new field. 
		 * @param tuple_size The tuple size of the new field. 
		 * @return The newly added field 
		 */
		virtual	spValueArray AddBaseTypeUserVertexField( Simplygon::EBaseTypes base_type , const char * name , unsigned int tuple_size ) = 0;

		/**
		 * Retrieves the FieldData object that contains the vertex fields. 
		 * @return The vertex fields data 
		 */
		virtual	spFieldData GetVertices(  ) = 0;

		/**
		 * The VertexIds field in the triangles. 
		 * @return The vertex ids array 
		 */
		virtual	spRidArray GetVertexIds(  ) = 0;

		/**
		 * Adds the MaterialIds field in the triangles. (Field name: "MaterialIds", Tuple 
		 * size: 1 , Stored as: triangle attribute) 
		 */
		virtual	void AddMaterialIds(  ) = 0;

		/**
		 * Removes the MaterialIds field in the triangles. (Field name: "MaterialIds", 
		 * Tuple size: 1 , Stored as: triangle attribute) 
		 */
		virtual	void RemoveMaterialIds(  ) = 0;

		/**
		 * The MaterialIds field in the triangles. (Field name: "MaterialIds", Tuple size: 
		 * 1 , Stored as: triangle attribute) 
		 * @return The material ids array 
		 */
		virtual	spRidArray GetMaterialIds(  ) = 0;

		/**
		 * Adds the GroupIds field in the triangles. (Field name: "GroupIds", Tuple size: 
		 * 1 , Stored as: triangle attribute) 
		 */
		virtual	void AddGroupIds(  ) = 0;

		/**
		 * Removes the GroupIds field in the triangles. (Field name: "GroupIds", Tuple 
		 * size: 1 , Stored as: triangle attribute) 
		 */
		virtual	void RemoveGroupIds(  ) = 0;

		/**
		 * The GroupIds field in the triangles. (Field name: "GroupIds", Tuple size: 1 
		 * , Stored as: triangle attribute) 
		 * @return The material ids array 
		 */
		virtual	spRidArray GetGroupIds(  ) = 0;

		/**
		 * Adds a user-specified triangle field from an already populated array. To be 
		 * able to add a field, it must have a name that does not conflict with the existing 
		 * triangle fields. 
		 * @param field The array that is to be added. 
		 */
		virtual	void AddUserTriangleField( spValueArray field ) = 0;

		/**
		 * Removes a user-specified triangle field. To be able to add a field, it must 
		 * have a name that does not conflict with the existing triangle fields. 
		 * @param name Name of the field to be removed. 
		 */
		virtual	void RemoveUserTriangleField( const char * name ) = 0;

		/**
		 * Gets a user-specified triangle field. To be able to add a field, it must have 
		 * a name that does not conflict with the existing triangle fields. 
		 * @param name Name of the field to be fetched. 
		 */
		virtual	spValueArray GetUserTriangleField( const char * name ) = 0;

		/**
		 * Adds an empty user-specified triangle field. To be able to add a field, it 
		 * must have a name that does not conflict with the existing triangle fields. 
		 * @param base_type The type of data in the field, the alternatives can be found 
		 * in BaseTypes. 
		 * @param name The name of the new field. 
		 * @param tuple_size The tuple size of the new field. 
		 * @return The newly added field 
		 */
		virtual	spValueArray AddBaseTypeUserTriangleField( Simplygon::EBaseTypes base_type , const char * name , unsigned int tuple_size ) = 0;

		/**
		 * Retrieves the ReFieldData object that contains the triangle fields. 
		 * @return The triangle fields data 
		 */
		virtual	spFieldData GetTriangles(  ) = 0;

		/**
		 * The inferior (minimum) extent of the geometry. 
		 * @return The returned data array. The array contains 3 items. 
		 */
		virtual	spRealData GetInf(  ) = 0;

		/**
		 * The inferior (minimum) extent of the geometry. 
		 * @param vec_realInputDataPtr The desired values that the minimum extent of the 
		 * geometry is to be set to. 
		 */
		virtual	void SetInf( const real *vec_realInputDataPtr ) = 0;

		/**
		 * The superior (maximum) extent of the geometry. 
		 * @return The returned data array. The array contains 3 items. 
		 */
		virtual	spRealData GetSup(  ) = 0;

		/**
		 * The superior (maximum) extent of the geometry. 
		 * @param vec_realInputDataPtr The desired values that the maximum extent of the 
		 * geometry is to be set to. 
		 */
		virtual	void SetSup( const real *vec_realInputDataPtr ) = 0;

	};
	class IValueArray;
	class IFieldData;

	/**
	 * ImageData holds unpacked image data. The data is stored in an FieldData object 
	 * as value fields. For simplicity all images are implemented as 3D images, but 
	 * has an extent of 1 in Z for 2D images, and an extent of 1 in both Y and Z for 
	 * 1D images. Cube maps are stored as a 3D image with Z-depth of 6 (one for each 
	 * side) 
	 */
	class IImageData : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IImageData is a or is a descendant of 
		 * the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IImageData",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IImageData 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IImageData pointer 
		 * @return a pointer to the IImageData object, if the cast can be made, and a 
		 * NULL pointer otherwise 
		 */

		static IImageData *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IImageData") )
				return static_cast<IImageData*>(ptr);
			return nullptr;
		}
		/**
		 * Creates another image data object with the same field setup. To also copy the 
		 * data to the new object, set copy_data to true. 
		 * @param copy_data If true, all data is copied. 
		 * @return The new copy of the image data object. 
		 */
		virtual	spImageData NewCopy( bool copy_data ) = 0;

		/**
		 * Copies the field setup and data from another object. To only copy the setup, 
		 * set copy_data to false. 
		 * @param source The IImageData object to copy from. 
		 * @param copy_data True if the data should be copied along with the image data 
		 * properties. 
		 */
		virtual	void DeepCopy( spImageData source , bool copy_data ) = 0;

		/**
		 * Adds the Colors field. 
		 * @param valuetype The type used to store the tuples. Use TYPES_ID_UCHAR base 
		 * type for 8-bit per channel data, and TYPES_ID_USHORT base type for 16-bit per 
		 * channel data. 
		 * @param format A string that describes the format of the color field. Each character 
		 * in format represents a color channel in the color tuple. All characters in 
		 * the format string must be unique and uppercase. Normal values for format are: 
		 * RGB, RGBA, YUV, HLS, CMYK, L and R. In these examples the tuplesize of the 
		 * formats will be 3,4,3,3,4,1 and 1, respectively. The format string must be 
		 * at least one character long. Use the SG_IMAGEDATA_FORMAT_[] defines to define 
		 * the standard types. 
		 */
		virtual	void AddColors( Simplygon::EBaseTypes valuetype , const char * format ) = 0;

		/**
		 * Removes the Colors field. 
		 */
		virtual	void RemoveColors(  ) = 0;

		/**
		 * The Colors field. 
		 * @return The value array used by the colors field. 
		 */
		virtual	spValueArray GetColors(  ) = 0;

		/**
		 * The base type used by the colors field. 
		 * @return The base type used by the colors field. 
		 */
		virtual	Simplygon::EBaseTypes GetColorsValueType(  ) = 0;

		/**
		 * Checks if the image has a color field. 
		 * @return True if the image has a color field 
		 */
		virtual	bool HasColors(  ) = 0;

		/**
		 * The color field format specification. 
		 * @return The format specification string 
		 */
		virtual	spString GetColorsFormat(  ) = 0;

		/**
		 * Adds a field. The field must have a name that does not conflict with any of 
		 * the existing field names. The field is referenced by the image after the call 
		 * to AddField() 
		 * @param name The name of the field to add. 
		 * @param valuetype The type of the field, types listed in BaseTypes. 
		 * @param tuplesize The size of tuples in the new field. 
		 */
		virtual	void AddField( const char * name , Simplygon::EBaseTypes valuetype , unsigned int tuplesize ) = 0;

		/**
		 * Removes a field. 
		 * @param name The name of the field to remove. 
		 */
		virtual	void RemoveField( const char * name ) = 0;

		/**
		 * Gets a field. 
		 * @param name The name of the field to get. 
		 * @return The requested field 
		 */
		virtual	spValueArray GetField( const char * name ) = 0;

		/**
		 * Gets the value type of a field. 
		 * @param name The name of the field whose type to get, types listed in BaseTypes. 
		 *  
		 * @return The base type of the field 
		 */
		virtual	Simplygon::EBaseTypes GetFieldValueType( const char * name ) = 0;

		/**
		 * Check if a field exists in the IImageData object. 
		 * @param name The name of the field to check for. 
		 * @return True if field exists, otherwise false 
		 */
		virtual	bool HasField( const char * name ) = 0;

		/**
		 * The type of this image data. 
		 * @return The type of this image data 
		 */
		virtual	unsigned int GetType(  ) = 0;

		/**
		 * The X dimension size of this image data. 
		 * @return The X dimension size of this image data. 
		 */
		virtual	unsigned int GetXSize(  ) = 0;

		/**
		 * The Y dimension size of this image data. 
		 * @return The Y dimension size of this image data. 
		 */
		virtual	unsigned int GetYSize(  ) = 0;

		/**
		 * The Z dimension size of this image data. 
		 * @return The Z dimension size of this image data. 
		 */
		virtual	unsigned int GetZSize(  ) = 0;

		/**
		 * The X dimension size of this image data. 
		 * @param _xs The desired X dimension size of this image data. 
		 */
		virtual	void Set1DSize( unsigned int _xs ) = 0;

		/**
		 * The X and Y dimension size of this image data. 
		 * @param _xs The desired X dimension size of this image data. 
		 * @param _ys The desired Y dimension size of this image data. 
		 */
		virtual	void Set2DSize( unsigned int _xs , unsigned int _ys ) = 0;

		/**
		 * The X, Y and Z dimension size of this image data. 
		 * @param _xs The desired X dimension size of this image data. 
		 * @param _ys The desired Y dimension size of this image data. 
		 * @param _zs The desired Z dimension size of this image data. 
		 */
		virtual	void Set3DSize( unsigned int _xs , unsigned int _ys , unsigned int _zs ) = 0;

		/**
		 * The 6 uniform cube side dimensions of this image data. 
		 * @param _xs The desired X dimension size of each cube side in this image data. 
		 *  
		 * @param _ys The desired Y dimension size of each cube side in this image data. 
		 *  
		 */
		virtual	void SetCubeSize( unsigned int _xs , unsigned int _ys ) = 0;

		/**
		 * Clears all data from the image, and removes all data fields. The type is reset 
		 * to 2D. 
		 */
		virtual	void Reset(  ) = 0;

		/**
		 * The ImageFields field data object, that holds all fields within the image. 
		 * @return The ImageFields field data object. 
		 */
		virtual	spFieldData GetImageFields(  ) = 0;

	};
	class IObject;

	/**
	 * Table is the base class for tables objects, where items are added into an id-indexed 
	 * array of objects. 
	 */
	class ITable : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if ITable is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("ITable",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a ITable 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ITable pointer 
		 * @return a pointer to the ITable object, if the cast can be made, and a NULL 
		 * pointer otherwise 
		 */

		static ITable *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("ITable") )
				return static_cast<ITable*>(ptr);
			return nullptr;
		}
		/**
		 * Adds an item to the table. The returned value is the id of the item within 
		 * the table, which can be used to retrieve the item using GetItem(). 
		 * @param item Is the item that is to be added to the table. 
		 * @return the id of the added item in the table 
		 */
		virtual	rid AddItem( spObject item ) = 0;

		/**
		 * Sets an item in the table. The id must exist in the table. 
		 * @param id Is the id that is to be set. 
		 * @param item Is the object set to the id. 
		 */
		virtual	void SetItem( rid id , spObject item ) = 0;

		/**
		 * Finds a named item in the table. If multiple items have the same name, the 
		 * first will be returned. If no item was found, null will be returned. 
		 * @param name Is the string that is to be searched for. 
		 * @return the matching object, or null if no match was found 
		 */
		virtual	spObject FindItem( const char * name ) = 0;

		/**
		 * Finds the id of an item in the table, using the name. If multiple items have 
		 * the same name, the first will be returned. If no item was found, the return 
		 * will be -1. 
		 * @param name Is the string that is to be searched for. 
		 * @return the id of the found object, or -1 if no match was found 
		 */
		virtual	rid FindItemId( const char * name ) = 0;

		/**
		 * Returns the i:th item, using the id of the item. 
		 * @param id Is the id of the requested object. 
		 * @return the found object 
		 */
		virtual	spObject GetItem( rid id ) = 0;

		/**
		 * Removes an item, and invalidates the id. The id will not point at a valid item, 
		 * until Clear is called and new items are added up until the id. 
		 * @param id The id of the object that should be removed. 
		 */
		virtual	void RemoveItem( rid id ) = 0;

		/**
		 * Clears the table, and removes all items. If AddItem is called after Clear, 
		 * the item ids will start over from 0. 
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * The number of item id:s in the table. If an item has been removed, using RemoveItem, 
		 * the id is still counted in this method. GetIdsCount also equals the id that 
		 * will be applied to the next item added to the table. 
		 * @return the itemcount of the table 
		 */
		virtual	unsigned int GetItemsCount(  ) = 0;

		/**
		 * Clears the current table and copies the items from a source table. 
		 * @param src The table to copy. 
		 */
		virtual	void Copy( spTable src ) = 0;

	};
	class IShadingNode;
	class IStringArray;

	/**
	 * Material object that keeps material information used while rendering. 
	 */
	class IMaterial : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IMaterial is a or is a descendant of 
		 * the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IMaterial",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IMaterial 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IMaterial pointer 
		 * @return a pointer to the IMaterial object, if the cast can be made, and a NULL 
		 * pointer otherwise 
		 */

		static IMaterial *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IMaterial") )
				return static_cast<IMaterial*>(ptr);
			return nullptr;
		}
		/**
		 * Returns the number of material channels in the material. 
		 * @return The current channel count 
		 */
		virtual	unsigned int GetMaterialChannelCount(  ) = 0;

		/**
		 * Returns the name of a channel from the index. Note that by adding/removing 
		 * channels the indices are changed, and this method should only be used for enumeration. 
		 * @param index The index to the channel to be fetched. 
		 * @return The channel name corresponding to the index 
		 */
		virtual	spString GetMaterialChannelFromIndex( rid index ) = 0;

		/**
		 * Add a material channel. 
		 * @param channel_name The name of the material channel. 
		 */
		virtual	void AddMaterialChannel( const char * channel_name ) = 0;

		/**
		 * Remove a material channel. 
		 * @param channel_name The name of the material channel. 
		 */
		virtual	void RemoveMaterialChannel( const char * channel_name ) = 0;

		/**
		 * Check if the channel exists within the material. 
		 * @param channel_name The name of the material channel. 
		 * @return True if the channel exists, false if not 
		 */
		virtual	bool HasMaterialChannel( const char * channel_name ) = 0;

		/**
		 * Set which shading network to use for the material channel. 
		 * @param channel_name The name of the new channel. 
		 * @param node The shading network exit node. 
		 */
		virtual	void SetShadingNetwork( const char * channel_name , spShadingNode node ) = 0;

		/**
		 * Get which shading network to use for the material channel. 
		 * @param channel_name The name of the channel. 
		 * @return The current shading network exit node 
		 */
		virtual	spShadingNode GetShadingNetwork( const char * channel_name ) = 0;

		/**
		 * Save shading network to XML. 
		 * @param channel_name The name of the channel. 
		 * @param in_xml The xml descriping the shading node graph. 
		 * @return The current shading network exit node 
		 */
		virtual	void LoadShadingNetworkFromXML( const char * channel_name , const char * in_xml ) = 0;

		/**
		 * Save shading network to XML. 
		 * @param channel_name The name of the channel. 
		 * @return The current shading network exit node 
		 */
		virtual	spString SaveShadingNetworkToXML( const char * channel_name ) = 0;

		/**
		 * The UseTangentSpaceNormals flag. If set, the normal map has tangent space normals. 
		 * @param value The desired flag value. 
		 */
		virtual	void SetUseTangentSpaceNormals( bool value ) = 0;

		/**
		 * The UseTangentSpaceNormals flag. If set, the normal map has tangent space normals. 
		 *  
		 */
		virtual	bool GetUseTangentSpaceNormals(  ) = 0;

		/**
		 * Returns true if the material is setup identical to this material. 
		 * @param mat The material to compare to. 
		 */
		virtual	bool IsIdenticalTo( spMaterial mat ) = 0;

		/**
		 * Returns true if the material could be transparent. 
		 */
		virtual	bool IsTransparent(  ) = 0;

		/**
		 * The unique id for this node. 
		 * @param value The node id of type string. 
		 */
		virtual	void SetMaterialGUID( const char * value ) = 0;

		/**
		 * The unique id for this node. 
		 */
		virtual	spString GetMaterialGUID(  ) = 0;

		/**
		 * The material type, used to specify which shader should be used to render the 
		 * material. 
		 * @param value The material type. One of the following: Standard -> Use the standard 
		 * shader. Flipbook -> Use the flipbook shader. BillboardCloud -> Use the billboard 
		 * cloud shader. 
		 */
		virtual	void SetMaterialType( Simplygon::EMaterialType value ) = 0;

		/**
		 * The material type, used to specify which shader should be used to render the 
		 * material. 
		 */
		virtual	Simplygon::EMaterialType GetMaterialType(  ) = 0;

		/**
		 * The opacity type determines how the opacity channel of this material is interpreted 
		 * when casting. To make (0.0->1.0) map to (transparent-opaque), use 'Opacity'. 
		 * To make (0.0->1.0) map to (opaque-transparent), use 'Transparency' 
		 * @param value The new opacity type. 
		 */
		virtual	void SetOpacityType( Simplygon::EOpacityType value ) = 0;

		/**
		 * The opacity type determines how the opacity channel of this material is interpreted 
		 * when casting. To make (0.0->1.0) map to (transparent-opaque), use 'Opacity'. 
		 * To make (0.0->1.0) map to (opaque-transparent), use 'Transparency' 
		 */
		virtual	Simplygon::EOpacityType GetOpacityType(  ) = 0;

		/**
		 * Material blend mode specifies which type of blend function to use to blend 
		 * materials. The blend mode function will be used while blending layers during 
		 * material casting. 
		 * @param value The blend mode function used while blending layers during material 
		 * casting. 
		 */
		virtual	void SetBlendMode( Simplygon::EMaterialBlendMode value ) = 0;

		/**
		 * Material blend mode specifies which type of blend function to use to blend 
		 * materials. The blend mode function will be used while blending layers during 
		 * material casting. 
		 */
		virtual	Simplygon::EMaterialBlendMode GetBlendMode(  ) = 0;

		/**
		 * The cutoff value for opacity when using mask blend mode. 
		 * @param value The opacity cutoff value. 
		 */
		virtual	void SetOpacityCutoff( real value ) = 0;

		/**
		 * The cutoff value for opacity when using mask blend mode. 
		 */
		virtual	real GetOpacityCutoff(  ) = 0;

		/**
		 * Changes the prefix path (drive, directory) of all matching texture paths in 
		 * the material, with the new one. This method is useful when external textures 
		 * are placed in a specific folder, which needs to be moved. 
		 * @param current_path_prefix The current prefix path, either relative or absolute. 
		 *  
		 * @param new_path_prefix The new prefix path. 
		 */
		virtual	void ChangeTexturePrefixPath( const char * current_path_prefix , const char * new_path_prefix ) = 0;

		/**
		 * Maps the alpha component of the diffuse channel to all the RGBA components 
		 * in the opacity channel (by using a swizzle node). 
		 */
		virtual	void SetOpacityFromDiffuseAlpha(  ) = 0;

		/**
		 * Converts parameters such as UVTiling and UVOffset in shading networks. 
		 */
		virtual	void ConvertHandedness(  ) = 0;

		/**
		 * Get all unique material channel names in the material. 
		 * @param channels The array receiving unique channel names. 
		 */
		virtual	void GetMaterialChannels( spStringArray channels ) = 0;

		/**
		 * Get all unique material channel names having texture inputs in the material. 
		 * @param channels The array receiving unique channel names. 
		 */
		virtual	void GetMaterialChannelsWithTextureInputs( spStringArray channels ) = 0;

	};
	class IMaterial;
	class IRidArray;
	class IStringArray;

	/**
	 * MaterialTable keeps information on materials used while rendering. 
	 */
	class IMaterialTable : public ITable
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IMaterialTable is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IMaterialTable",type)==0 )
				return true;
			return ITable::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IMaterialTable 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IMaterialTable pointer 
		 * @return a pointer to the IMaterialTable object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static IMaterialTable *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IMaterialTable") )
				return static_cast<IMaterialTable*>(ptr);
			return nullptr;
		}
		/**
		 * Adds a material to the table. The returned value is the id of the material 
		 * within the table. 
		 * @param material The material to add into the table. 
		 * @return The material id of the material in the table 
		 */
		virtual	rid AddMaterial( spMaterial material ) = 0;

		/**
		 * Finds a material in the table, using the material name. If multiple materials 
		 * have the same name, the first will be returned. If the material was not found, 
		 * null is returned. 
		 * @param name The material name to look for. 
		 * @return The material if found, null otherwise 
		 */
		virtual	spMaterial FindMaterial( const char * name ) = 0;

		/**
		 * Finds a material in the table that is setup identical to the specified material. 
		 * @param mat The material setup to look for. 
		 * @return The material if found, null otherwise 
		 */
		virtual	spMaterial FindIdenticalMaterial( spMaterial mat ) = 0;

		/**
		 * Finds the id of a material in the table, using the material name. If multiple 
		 * materials have the same name, the first will be returned. If the material was 
		 * not found, the return will be -1. 
		 * @param name The material name to look for. 
		 * @return The material id if found, -1 otherwise 
		 */
		virtual	rid FindMaterialId( const char * name ) = 0;

		/**
		 * Finds the id of a material in the table that is setup identical to the specified 
		 * material. 
		 * @param mat The material setup to look for. 
		 * @return The material id if found, -1 otherwise 
		 */
		virtual	rid FindIdenticalMaterialId( spMaterial mat ) = 0;

		/**
		 * Finds the materials in the table that are setup identical to the specified 
		 * material. 
		 * @param mat The material setup to look for. 
		 * @return The an array material ids if found, null otherwise 
		 */
		virtual	spRidArray FindIdenticalMaterialIds( spMaterial mat ) = 0;

		/**
		 * Sets a material in the table. 
		 * @param id The id of the material in the table. 
		 * @param material The material to set into the table. 
		 */
		virtual	void SetMaterial( rid id , spMaterial material ) = 0;

		/**
		 * Returns the i:th material, using the id of the material. 
		 * @param id The id of the material in the table. 
		 * @return The the material in the table 
		 */
		virtual	spMaterial GetMaterial( rid id ) = 0;

		/**
		 * Removes a material. If GetMaterial is subsequently called with the same material 
		 * id, the value returned will be null. 
		 * @param id The id of the material in the table. 
		 */
		virtual	void RemoveMaterial( rid id ) = 0;

		/**
		 * Returns the number of materials in the table. 
		 */
		virtual	unsigned int GetMaterialsCount(  ) = 0;

		/**
		 * Changes the prefix path (drive, directory) of all matching texture paths in 
		 * all the materials in the table, with the new one. This method is useful when 
		 * external textures are placed in a specific folder, which needs to be moved. 
		 * @param current_path_prefix The current prefix path, either relative or absolute. 
		 *  
		 * @param new_path_prefix The new prefix path. 
		 */
		virtual	void ChangeTexturePrefixPath( const char * current_path_prefix , const char * new_path_prefix ) = 0;

		/**
		 * Get all unique material channel names for all materials in table. 
		 * @param channels The array receiving unique channel names. 
		 */
		virtual	void GetMaterialChannels( spStringArray channels ) = 0;

		/**
		 * Get all unique material channel names having texture inputs for all materials 
		 * in table. 
		 * @param channels The array receiving unique channel names. 
		 */
		virtual	void GetMaterialChannelsWithTextureInputs( spStringArray channels ) = 0;

	};
	class IRealArray;

	/**
	 * Matrix4x4 is used to represent and manipulate 4x4 transformation matrices, which 
	 * can be either standard matrices, or homogeneous 4x4 matrices used to transform 
	 * 3D homogeneous coordinates [x y z w]. The transformations are defined in row-major 
	 * order. 
	 */
	class IMatrix4x4 : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IMatrix4x4 is a or is a descendant of 
		 * the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IMatrix4x4",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IMatrix4x4 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IMatrix4x4 pointer 
		 * @return a pointer to the IMatrix4x4 object, if the cast can be made, and a 
		 * NULL pointer otherwise 
		 */

		static IMatrix4x4 *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IMatrix4x4") )
				return static_cast<IMatrix4x4*>(ptr);
			return nullptr;
		}
		/**
		 * Copies the contents of an input matrix to the current matrix. 
		 * @param mtxin The source matrix. 
		 */
		virtual	void DeepCopy( spMatrix4x4 mtxin ) = 0;

		/**
		 * Set the matrix to the zero matrix (all zeros). 
		 */
		virtual	void Zero(  ) = 0;

		/**
		 * Set the matrix to the identity matrix. 
		 */
		virtual	void Identity(  ) = 0;

		/**
		 * Get a matrix element. 
		 * @param column The column index. 
		 * @param row The row index. 
		 * @return The value of the element 
		 */
		virtual	real GetElement( unsigned int column , unsigned int row ) = 0;

		/**
		 * Set a matrix element. 
		 * @param column The column index. 
		 * @param row The row index. 
		 * @param value The value to which the element will be set. 
		 */
		virtual	void SetElement( unsigned int column , unsigned int row , real value ) = 0;

		/**
		 * The elements of the matrix. 
		 * @return The returned data array. The array contains 16 items. 
		 * @return an array containing all elements 
		 */
		virtual	spRealData GetElements(  ) = 0;

		/**
		 * The matrix to the transpose of the input matrix. 
		 * @param mtxin The input matrix. 
		 */
		virtual	void SetToTranspose( spMatrix4x4 mtxin ) = 0;

		/**
		 * Transpose the current matrix. 
		 */
		virtual	void Transpose(  ) = 0;

		/**
		 * The matrix to the invert of the input matrix. 
		 * @param mtxin The input matrix. 
		 */
		virtual	void SetToInvert( spMatrix4x4 mtxin ) = 0;

		/**
		 * Invert the current matrix. 
		 */
		virtual	void Invert(  ) = 0;

		/**
		 * Returns the top 3x3 determinant. 
		 */
		virtual	real Determinant3x3(  ) = 0;

		/**
		 * Multiply in-place an array with 3D points [x y z 1]. 
		 * @param vecarray The vectors to be multiplied and written to. 
		 */
		virtual	void Point3ArrayMultiply( spRealArray vecarray ) = 0;

		/**
		 * Multiply in-place an array with 3D direction vectors [x y z 0]. 
		 * @param vecarray The vectors to be multiplied and written to. 
		 */
		virtual	void Direction3ArrayMultiply( spRealArray vecarray ) = 0;

		/**
		 * Multiply in-place an array with full 4D vectors [x y z w]. 
		 * @param vecarray The vectors to be multiplied and written to. 
		 */
		virtual	void Vector4ArrayMultiply( spRealArray vecarray ) = 0;

		/**
		 * Creates a 3D rotation in a homogeneous transformation 4x4 matrix around the 
		 * specified axis. 
		 * @param angle The angle. 
		 * @param ax The x component of the rotation axis. 
		 * @param ay The y component of the rotation axis. 
		 * @param az The z component of the rotation axis. 
		 */
		virtual	void SetToRotationTransform( real angle , real ax , real ay , real az ) = 0;

		/**
		 * Creates a 3D scaling in a homogeneous transformation 4x4 matrix. 
		 * @param sx The x component of the scaling. 
		 * @param sy The y component of the scaling. 
		 * @param sz The z component of the scaling. 
		 */
		virtual	void SetToScalingTransform( real sx , real sy , real sz ) = 0;

		/**
		 * Creates a 3D translation in a homogeneous 4x4 matrix. 
		 * @param tx The x component of the scaling. 
		 * @param ty The y component of the scaling. 
		 * @param tz The z component of the scaling. 
		 */
		virtual	void SetToTranslationTransform( real tx , real ty , real tz ) = 0;

	};
	class IMatrix4x4;
	class IRealArray;

	/**
	 * Transform3 handles homogeneous 4x4 transforms, i.e. transformations which can 
	 * be represented by multiplying a 4x4 matrix with a homogeneous 3D coordinate. 
	 * Transform3 can either pre-multiply a matrix onto the transformation, which will 
	 * add a transform around the current transform, or it can post-multiply the matrix, 
	 * which will add a transform inside the current transform. Post-multiply is the 
	 * default mode. 
	 */
	class ITransform3 : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if ITransform3 is a or is a descendant of 
		 * the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("ITransform3",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a ITransform3 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ITransform3 pointer 
		 * @return a pointer to the ITransform3 object, if the cast can be made, and a 
		 * NULL pointer otherwise 
		 */

		static ITransform3 *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("ITransform3") )
				return static_cast<ITransform3*>(ptr);
			return nullptr;
		}
		/**
		 * Resets the transformation to the identity transform, resets the multiplication 
		 * mode to postmultiply, and clears the matrix stack. 
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * The matrix that is used to specify the transform. 
		 * @return the transform matrix 
		 */
		virtual	spMatrix4x4 GetMatrix(  ) = 0;

		/**
		 * The real array that is used to store the matrix stack. 
		 * @return the matrix stack array 
		 */
		virtual	spRealArray GetStack(  ) = 0;

		/**
		 * The transform concatenation mode to post-multiply, any added transform will 
		 * be concatenated using this mode. 
		 */
		virtual	void PostMultiply(  ) = 0;

		/**
		 * The transform concatenation mode to pre-multiply, any added transform will 
		 * be concatenated using this mode. 
		 */
		virtual	void PreMultiply(  ) = 0;

		/**
		 * The transform concatenation mode. 
		 * @return true if the mode is set to post-multiply, false otherwise 
		 */
		virtual	bool IsPostMultiply(  ) = 0;

		/**
		 * The transform concatenation mode. 
		 * @return true if the mode is set to pre-multiply, false otherwise 
		 */
		virtual	bool IsPreMultiply(  ) = 0;

		/**
		 * Concatenates a rotation transform to the current transform. 
		 * @param angle The rotation angle around the axis. 
		 * @param rx The x axis rotation component. 
		 * @param ry The y axis rotation component. 
		 * @param rz The z axis rotation component. 
		 */
		virtual	void AddRotation( real angle , real rx , real ry , real rz ) = 0;

		/**
		 * Concatenates a scaling transform to the current transform. 
		 * @param sx The scaling vector x axis component. 
		 * @param sy The scaling vector y axis component. 
		 * @param sz The scaling vector z axis component. 
		 */
		virtual	void AddScaling( real sx , real sy , real sz ) = 0;

		/**
		 * Concatenates a translation transform to the current transform. 
		 * @param tx The translation vector x component. 
		 * @param ty The translation vector y component. 
		 * @param tz The translation vector z component. 
		 */
		virtual	void AddTranslation( real tx , real ty , real tz ) = 0;

		/**
		 * Concatenates a generic transform to the current transform. 
		 * @param transform The input transform matrix. 
		 */
		virtual	void AddTransformation( spMatrix4x4 transform ) = 0;

		/**
		 * Pushes the current transform onto the matrix stack. 
		 */
		virtual	void Push(  ) = 0;

		/**
		 * Pops the topmost matrix on the the matrix stack, and replaces the current transform 
		 * with the popped matrix. 
		 */
		virtual	void Pop(  ) = 0;

	};
	class IChunkedImageData;
	class IMappingImageMeshData;

	/**
	 * MappingImage stores the mapping between a processed geometry and the source 
	 * geometry it is based on. The mapping image object also stores multisampling 
	 * settings. It can be used to cast information from the original geometry to the 
	 * processed geometry, such as surface transfer or calculating normal maps. See 
	 * IMaterialCaster and subclasses for casting uses. 
	 */
	class IMappingImage : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IMappingImage is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IMappingImage",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IMappingImage 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IMappingImage pointer 
		 * @return a pointer to the IMappingImage object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static IMappingImage *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IMappingImage") )
				return static_cast<IMappingImage*>(ptr);
			return nullptr;
		}
		/**
		 * Return a copy of the mapping image which is scaled in size by half, in width 
		 * and height. The area covered is a quarter size of the original, hence its name. 
		 * @return copy of the mapping image, reduced in size to half of the original 
		 * width and height 
		 */
		virtual	spMappingImage NewQuartersizeCopy(  ) = 0;

		/**
		 * The width of the mapping texture. 
		 * @return The Width of the mapping texture 
		 */
		virtual	unsigned int GetWidth(  ) = 0;

		/**
		 * The height of the mapping texture. 
		 * @return The Height of the mapping texture 
		 */
		virtual	unsigned int GetHeight(  ) = 0;

		/**
		 * The number of layers of the mapping texture. 
		 * @return The LayerCount of the mapping texture 
		 */
		virtual	unsigned int GetLayerCount(  ) = 0;

		/**
		 * The multi sampling width of the mapping texture. 
		 * @return The multi sampling width 
		 */
		virtual	unsigned int GetMultisamplingWidth(  ) = 0;

		/**
		 * The multi sampling height of the mapping texture. 
		 * @return The multi sampling height 
		 */
		virtual	unsigned int GetMultisamplingHeight(  ) = 0;

		/**
		 * The ImageData object, which stores the mapping data. 
		 * @return The ImageData object. 
		 */
		virtual	spChunkedImageData GetImageData(  ) = 0;

		/**
		 * The IMappingImageMeshData Mesh data that is used to retrieve the triangle mapping 
		 * to mesh information to map back to the original scene. 
		 * @return The mapping mesh data object. 
		 */
		virtual	spMappingImageMeshData GetMappingMeshData(  ) = 0;

	};

	/**
	 * ProcessingObject is the abstract base class for all processing objects in Simplygon. 
	 * Processing objects take parameters, exports the RunProcessing to run the main 
	 * processing and Clear to clear the internal states of the processing object. 
	 * All processing objects also export information on how far the process has moved 
	 * and the possibility to cancel long running processings. 
	 */
	class IProcessingObject : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IProcessingObject is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IProcessingObject",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IProcessingObject 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IProcessingObject pointer 
		 * @return a pointer to the IProcessingObject object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IProcessingObject *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IProcessingObject") )
				return static_cast<IProcessingObject*>(ptr);
			return nullptr;
		}
		/**
		 * Runs the processing the object is designed for. 
		 */
		virtual	void RunProcessing(  ) = 0;

		/**
		 * Clear all internal states of the object. This will NOT clear the parameters 
		 * set in the object. 
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Returns the current progress of the processing as a value between 0 and 100. 
		 * @return The current progress of the process as a value between 0 and 100. 
		 */
		virtual	real GetPercentDone(  ) = 0;

		/**
		 * Get settings as JSON for debugging purposes. 
		 * @return All settings as JSON 
		 */
		virtual	spString ToJSON(  ) = 0;

	};
	class IGeometryData;
	class IRealArray;

	/**
	 * Computes texture coordinates for arbitrary geometry. 
	 */
	class IParameterizer : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IParameterizer is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IParameterizer",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IParameterizer 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IParameterizer pointer 
		 * @return a pointer to the IParameterizer object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static IParameterizer *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IParameterizer") )
				return static_cast<IParameterizer*>(ptr);
			return nullptr;
		}
		/**
		 * Executes the parameterization of the geometry. 
		 * @param geom The geometry which is to be parameterized. 
		 * @param arr Will contain the completed parameterization. 
		 * @return True if the parameterization succeeds, false otherwise 
		 */
		virtual	bool Parameterize( spGeometryData geom , spRealArray arr ) = 0;

		/**
		 * The maximum allowed texture stretch. Range 0->1. 
		 * @param value The desired value to which MaxStretch will be set. Value cannot 
		 * be less than 0. Value cannot be greater than 1. 
		 */
		virtual	void SetMaxStretch( real value ) = 0;

		/**
		 * The maximum allowed texture stretch. Range 0->1. 
		 */
		virtual	real GetMaxStretch(  ) = 0;

		/**
		 * Only used when computing new UVs. The importance value for trying to have as 
		 * large and few charts as possible. The closer the value is to 1, the slower 
		 * it is. Having 0 means no extra focus will be put on reducing the number of 
		 * charts. Having value 1 means maximum focus will be put on reducing the number 
		 * of charts and thereby increasing the size of the charts. 
		 * @param value The desired large charts importance value. Value cannot be less 
		 * than 0. Value cannot be greater than 1. 
		 */
		virtual	void SetLargeChartsImportance( real value ) = 0;

		/**
		 * Only used when computing new UVs. The importance value for trying to have as 
		 * large and few charts as possible. The closer the value is to 1, the slower 
		 * it is. Having 0 means no extra focus will be put on reducing the number of 
		 * charts. Having value 1 means maximum focus will be put on reducing the number 
		 * of charts and thereby increasing the size of the charts. 
		 */
		virtual	real GetLargeChartsImportance(  ) = 0;

		/**
		 * The number of input materials used in the original geometry for mapping to 
		 * multiple output materials. This needs to be set before you can set any specific 
		 * in-out material mapping. 0 signifies that no in-out material mapping is used, 
		 * ie. the process will produce one resulting mapping image. 
		 * @param value The number of outputs. 
		 */
		virtual	void SetInputMaterialCount( unsigned int value ) = 0;

		/**
		 * The number of input materials used in the original geometry for mapping to 
		 * multiple output materials. This needs to be set before you can set any specific 
		 * in-out material mapping. 0 signifies that no in-out material mapping is used, 
		 * ie. the process will produce one resulting mapping image. 
		 */
		virtual	unsigned int GetInputMaterialCount(  ) = 0;

		/**
		 * The number of output mapping images that are to be generated. Setup the mapping 
		 * between input and output materials with SetInputOutputMaterialMapping. 
		 * @param value The number of outputs. Value cannot be less than 1. Value cannot 
		 * be greater than SG_MAXIMUM_PARAMETERIZER_OUTPUT_MATERIAL_COUNT. 
		 */
		virtual	void SetOutputMaterialCount( unsigned int value ) = 0;

		/**
		 * The number of output mapping images that are to be generated. Setup the mapping 
		 * between input and output materials with SetInputOutputMaterialMapping. 
		 */
		virtual	unsigned int GetOutputMaterialCount(  ) = 0;

		/**
		 * The material mapping for InMaterialId, meaning what material of the generated 
		 * LOD InMaterialId will be baked into. Both InputMaterialCount and OutputMaterialCount 
		 * need to be set for this mapping to work, and all original materials need to 
		 * be mapped to an existing output id. 
		 * @param InMaterialId Is input material id. 
		 * @param OutMaterialId The output material id. 
		 */
		virtual	void SetInputOutputMaterialMapping( unsigned int InMaterialId , int OutMaterialId ) = 0;

		/**
		 * The previously set material mapping for mat_id. 
		 * @param InMaterialId Is input material id. 
		 * @return The currently mapped output material for InMaterialId. -1 means mapping 
		 * is not set. 
		 */
		virtual	int GetInputOutputMaterialMapping( unsigned int InMaterialId ) = 0;

		/**
		 * The width of the texture to use for mapping image index 0. Use SetTextureWidthForImageIndex 
		 * to set for another mapping image index. 
		 * @param value The texture width. 
		 */
		virtual	void SetTextureWidth( unsigned int value ) = 0;

		/**
		 * The width of the texture to use for mapping image index 0. Use SetTextureWidthForImageIndex 
		 * to set for another mapping image index. 
		 */
		virtual	unsigned int GetTextureWidth(  ) = 0;

		/**
		 * The width of the texture to use. 
		 * @param id The output material index. 
		 * @param value The new output texture width. 
		 */
		virtual	void SetTextureWidthForImageIndex( unsigned int id , unsigned int value ) = 0;

		/**
		 * The width of the texture to use. 
		 * @param id The material id of the output material. 
		 * @return The current texture width 
		 */
		virtual	unsigned int GetTextureWidthForImageIndex( unsigned int id ) = 0;

		/**
		 * The height of the texture to use for mapping image index 0. Use SetTextureHeightForImageIndex 
		 * to set for another mapping image index. 
		 * @param value The new output texture height. 
		 */
		virtual	void SetTextureHeight( unsigned int value ) = 0;

		/**
		 * The height of the texture to use for mapping image index 0. Use SetTextureHeightForImageIndex 
		 * to set for another mapping image index. 
		 */
		virtual	unsigned int GetTextureHeight(  ) = 0;

		/**
		 * The height of the texture to use. 
		 * @param id The output material id. 
		 * @param value The new output texture height. 
		 */
		virtual	void SetTextureHeightForImageIndex( unsigned int id , unsigned int value ) = 0;

		/**
		 * The height of the texture to use. 
		 * @param id The output material id. 
		 * @return The current texture height 
		 */
		virtual	unsigned int GetTextureHeightForImageIndex( unsigned int id ) = 0;

		/**
		 * The minimum number of pixels between charts for mapping image index 0. Use 
		 * SetGutterSpaceForImageIndex to set for another mapping image index. 
		 * @param value The desired value to which GutterSpace will be set. 
		 */
		virtual	void SetGutterSpace( unsigned int value ) = 0;

		/**
		 * The minimum number of pixels between charts for mapping image index 0. Use 
		 * SetGutterSpaceForImageIndex to set for another mapping image index. 
		 */
		virtual	unsigned int GetGutterSpace(  ) = 0;

		/**
		 * The minimum number of pixels between charts. 
		 * @param id The output material id. 
		 * @param value The desired value to which GutterSpace will be set. 
		 */
		virtual	void SetGutterSpaceForImageIndex( unsigned int id , unsigned int value ) = 0;

		/**
		 * The minimum number of pixels between charts. 
		 * @param id The output material id. 
		 * @return The current value of GutterSpace 
		 */
		virtual	unsigned int GetGutterSpaceForImageIndex( unsigned int id ) = 0;

		/**
		 * The FeatureFlagsMask. Any edge that has one of the flags present as a feature 
		 * edge, will have the edge forced as a parameterization feature. 
		 * @param value The mask to which FeatureFlagsMask will be set. 
		 */
		virtual	void SetFeatureFlagsMask( unsigned int value ) = 0;

		/**
		 * The FeatureFlagsMask. Any edge that has one of the flags present as a feature 
		 * edge, will have the edge forced as a parameterization feature. 
		 */
		virtual	unsigned int GetFeatureFlagsMask(  ) = 0;

		/**
		 * The automatic_texture_size flag. If true, then texture sizes will be computed 
		 * for the reduced mesh depending on its pixel size on screen. 
		 * @param value The desired flag. 
		 */
		virtual	void SetUseAutomaticTextureSize( bool value ) = 0;

		/**
		 * The automatic_texture_size flag. If true, then texture sizes will be computed 
		 * for the reduced mesh depending on its pixel size on screen. 
		 */
		virtual	bool GetUseAutomaticTextureSize(  ) = 0;

		/**
		 * Set/Get a texture dimension length multiplier for the automatic texture size. 
		 * @param value The desired multiplier. 
		 */
		virtual	void SetAutomaticTextureSizeMultiplier( real value ) = 0;

		/**
		 * Set/Get a texture dimension length multiplier for the automatic texture size. 
		 *  
		 */
		virtual	real GetAutomaticTextureSizeMultiplier(  ) = 0;

		/**
		 * If automatic_texture_size is enabled, then force the texture sizes to be a 
		 * power of 2. 
		 * @param value The desired flag. 
		 */
		virtual	void SetForcePower2Texture( bool value ) = 0;

		/**
		 * If automatic_texture_size is enabled, then force the texture sizes to be a 
		 * power of 2. 
		 */
		virtual	bool GetForcePower2Texture(  ) = 0;

		/**
		 * If UseVertexWeights is enabled, the weights help determine the UV charts and 
		 * their UV area. 
		 * @param value The desired flag. 
		 */
		virtual	void SetUseVertexWeights( bool value ) = 0;

		/**
		 * If UseVertexWeights is enabled, the weights help determine the UV charts and 
		 * their UV area. 
		 */
		virtual	bool GetUseVertexWeights(  ) = 0;

		/**
		 * If UseVisibilityWeights is enabled, the weights help determine the UV charts 
		 * and their UV area. 
		 * @param value The desired flag. 
		 */
		virtual	void SetUseVisibilityWeights( bool value ) = 0;

		/**
		 * If UseVisibilityWeights is enabled, the weights help determine the UV charts 
		 * and their UV area. 
		 */
		virtual	bool GetUseVisibilityWeights(  ) = 0;

	};
	class IObject;

	/**
	 * ObjectCollection and its specializations handles a collection of Objects. There 
	 * are methods for adding, removing and iterating through the objects. 
	 */
	class IObjectCollection : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IObjectCollection is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IObjectCollection",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IObjectCollection 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IObjectCollection pointer 
		 * @return a pointer to the IObjectCollection object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IObjectCollection *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IObjectCollection") )
				return static_cast<IObjectCollection*>(ptr);
			return nullptr;
		}
		/**
		 * Adds an object to the collection. The handle refers to the object until the 
		 * object is removed from the collection again. 
		 * @param obj The object that is to be added to the collection. 
		 * @return The handle of the added object in the collection 
		 */
		virtual	rhandle AddObject( spObject obj ) = 0;

		/**
		 * Adds an object to the collection, as AddObject, but sorts the object into the 
		 * collection based on its name. 
		 * @param obj The object that is to be added to the collection. 
		 * @param ascending Determines the sorting order. 
		 * @return The handle of the added object in the collection 
		 */
		virtual	rhandle AddObjectSorted( spObject obj , bool ascending ) = 0;

		/**
		 * Returns the start of the collection. The handle returned refers to the first 
		 * object in the collection. If the handle is null, then the collection is empty. 
		 * @return The first item in collection, or null if collection is empty 
		 */
		virtual	rhandle GetFirstItem(  ) = 0;

		/**
		 * Returns the handle to the next item in the collection. Use GetFirstItem and 
		 * this method to step through the collection. If the return is null, the end 
		 * of the collection has been reached. 
		 * @param objhandle The handle of an object i. 
		 * @return The handle of the object i+1 
		 */
		virtual	rhandle GetNextItem( rhandle objhandle ) = 0;

		/**
		 * The object the handle is referring to. 
		 * @param objhandle The handle of an object in the collection. 
		 * @return The object associated with the handle 
		 */
		virtual	spObject GetItemsObject( rhandle objhandle ) = 0;

		/**
		 * Removes an item from the collection. The handle returned is the first item 
		 * after this item that is in the collection. If the return is null, the item 
		 * was the last item in the collection. Warning! The handle is invalid after the 
		 * removal of the object. 
		 * @param objhandle The handle of the object that is to be removed. 
		 * @return The handle to the item following the removed one, or null if collection 
		 * is now empty 
		 */
		virtual	rhandle RemoveItem( rhandle objhandle ) = 0;

		/**
		 * Removes an object from the collection. Only the first occurance of the object 
		 * is removed from the collection. 
		 * @param pobj The object that is to be removed. 
		 */
		virtual	void RemoveObject( spObject pobj ) = 0;

		/**
		 * Removes all items from the collection. 
		 */
		virtual	void RemoveAllItems(  ) = 0;

		/**
		 * The number of items in the collection. 
		 * @return The number of items in the collection 
		 */
		virtual	unsigned int GetItemCount(  ) = 0;

		/**
		 * Returns the handle of the i:th item. 
		 * @param index The index of an object in the collection. 
		 * @return The handle of the object with the relevant index 
		 */
		virtual	rhandle GetItem( unsigned int index ) = 0;

		/**
		 * Returns the object of the i:th item. 
		 * @param index The index of an object in the collection. 
		 * @return The object with the relevant index 
		 */
		virtual	spObject GetItemAsObject( unsigned int index ) = 0;

		/**
		 * Returns true if the object is in the collection. 
		 * @param pobj The object to be checked for. 
		 * @return True if the collection contains pobj, false otherwise 
		 */
		virtual	bool IsObjectInCollection( spObject pobj ) = 0;

		/**
		 * Returns true if the item is in the collection. 
		 * @param objhandle The handle of an object to be checked for. 
		 * @return True if the collection contains the object, false otherwise 
		 */
		virtual	bool IsItemInCollection( rhandle objhandle ) = 0;

		/**
		 * Finds a named object in the collection. The first object with this name is 
		 * returned. The search is case-sensitive. 
		 * @param name The name of an object in the collection. 
		 * @return The object with the relevant name, or null if none is found 
		 */
		virtual	spObject FindObject( const char * name ) = 0;

	};
	class IGeometryData;

	/**
	 * GeometryDataCollection holds a number of GeometryData objects. The objects can 
	 * be looked up by their names (if they have been named with a call to SetName). 
	 */
	class IGeometryDataCollection : public IObjectCollection
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IGeometryDataCollection is a or is a 
		 * descendant of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IGeometryDataCollection",type)==0 )
				return true;
			return IObjectCollection::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IGeometryDataCollection 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IGeometryDataCollection pointer 
		 * @return a pointer to the IGeometryDataCollection object, if the cast can be 
		 * made, and a NULL pointer otherwise 
		 */

		static IGeometryDataCollection *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IGeometryDataCollection") )
				return static_cast<IGeometryDataCollection*>(ptr);
			return nullptr;
		}
		/**
		 * Adds a GeometryData object to the collection. The handle refers to the GeometryData 
		 * until it is removed from the collection again. If the GeometryData and the 
		 * pre-existing collection shares a field name they have to be of the same type 
		 * and tuple size. 
		 * @param obj The GeometryData to add. 
		 * @return a handle to the added geometry in the collection 
		 */
		virtual	rhandle AddGeometryData( spGeometryData obj ) = 0;

		/**
		 * The object the handle is referring to. 
		 * @param objhandle The handle of the geometry data object to fetch. 
		 * @return The requested GeometryData object. 
		 */
		virtual	spGeometryData GetGeometryData( rhandle objhandle ) = 0;

		/**
		 * Removes an object from the collection. Only the first occurrence of the object 
		 * is removed. 
		 * @param pobj The GeometryData to remove from the collection. 
		 */
		virtual	void RemoveGeometryData( spGeometryData pobj ) = 0;

		/**
		 * Finds a named object. 
		 * @param name The name of the geometry object. 
		 * @return The requested GeometryData object. 
		 */
		virtual	spGeometryData FindGeometryData( const char * name ) = 0;

		/**
		 * Returns the object of the next item. 
		 * @param phandle_rhandleInputDataPtr The handle to the geometry object. 
		 */
		virtual	spGeometryData GetNextItemAsGeometryData( rhandle *phandle_rhandleInputDataPtr ) = 0;

		/**
		 * Returns true if the object is in the collection. 
		 * @param pobj The GeometryData to look for. 
		 * @return True if the GeometryData is in the collection, otherwise false 
		 */
		virtual	bool IsGeometryDataInCollection( spGeometryData pobj ) = 0;

	};
	class IScene;

	/**
	 * Base class for graphics import classes 
	 */
	class IGraphicsImporter : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IGraphicsImporter is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IGraphicsImporter",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IGraphicsImporter 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IGraphicsImporter pointer 
		 * @return a pointer to the IGraphicsImporter object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IGraphicsImporter *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IGraphicsImporter") )
				return static_cast<IGraphicsImporter*>(ptr);
			return nullptr;
		}
		/**
		 * The main import file path. This must always be set. Some importers, such as 
		 * WavefrontImporter, also have secondary files that may be set. For info regarding 
		 * these secondary files, please see the documentation for the specific importer. 
		 * @param value The desired ImportFilePath string. 
		 */
		virtual	void SetImportFilePath( const char * value ) = 0;

		/**
		 * The main import file path. This must always be set. Some importers, such as 
		 * WavefrontImporter, also have secondary files that may be set. For info regarding 
		 * these secondary files, please see the documentation for the specific importer. 
		 *  
		 */
		virtual	spString GetImportFilePath(  ) = 0;

		/**
		 * Runs the import. Note that all parameters must be setup before importing. 
		 * @return True if the import was successful, false otherwise 
		 */
		virtual	bool RunImport(  ) = 0;

		/**
		 * Close any open file or stream, release any allocated data. 
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * The the scene loaded from the importer. 
		 * @return The loaded scene 
		 */
		virtual	spScene GetScene(  ) = 0;

	};

	/**
	 * OBJ scene importer 
	 */
	class IWavefrontImporter : public IGraphicsImporter
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IWavefrontImporter is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IWavefrontImporter",type)==0 )
				return true;
			return IGraphicsImporter::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IWavefrontImporter 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IWavefrontImporter pointer 
		 * @return a pointer to the IWavefrontImporter object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IWavefrontImporter *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IWavefrontImporter") )
				return static_cast<IWavefrontImporter*>(ptr);
			return nullptr;
		}
		/**
		 * The material file path. If the path is not set, it is assumed to equal the 
		 * path of the main obj file, but with the extension '.mtl' instead of '.obj'. 
		 * If no material file is found or specified, materials that are found in the 
		 * Wavefront file is added using default material settings to the material table. 
		 * @param value Is the path to the material file. 
		 */
		virtual	void SetMaterialFilePath( const char * value ) = 0;

		/**
		 * The material file path. If the path is not set, it is assumed to equal the 
		 * path of the main obj file, but with the extension '.mtl' instead of '.obj'. 
		 * If no material file is found or specified, materials that are found in the 
		 * Wavefront file is added using default material settings to the material table. 
		 *  
		 */
		virtual	spString GetMaterialFilePath(  ) = 0;

		/**
		 * The ExtractGroups boolean. If true, each group within the wavefront file is 
		 * extracted into a separate geometry data object, that is named as the group. 
		 * If false, the whole file is imported into one geometry data, and groups are 
		 * ignored. 
		 * @param value Is the bool the parameter is to be set to. 
		 */
		virtual	void SetExtractGroups( bool value ) = 0;

		/**
		 * The ExtractGroups boolean. If true, each group within the wavefront file is 
		 * extracted into a separate geometry data object, that is named as the group. 
		 * If false, the whole file is imported into one geometry data, and groups are 
		 * ignored. 
		 */
		virtual	bool GetExtractGroups(  ) = 0;

		/**
		 * The UseAlphaAsOpacity boolean. If set, then if the material has a map_d texture 
		 * definition, and that texture is RGBA, the material will use the alpha channel 
		 * rather than the color (R) to specify the opacity. 
		 * @param value Is the bool the parameter is to be set to. 
		 */
		virtual	void SetUseAlphaAsOpacity( bool value ) = 0;

		/**
		 * The UseAlphaAsOpacity boolean. If set, then if the material has a map_d texture 
		 * definition, and that texture is RGBA, the material will use the alpha channel 
		 * rather than the color (R) to specify the opacity. 
		 */
		virtual	bool GetUseAlphaAsOpacity(  ) = 0;

		/**
		 * The UseFallbackDiffuse boolean. If set to true and the material is missing 
		 * thediffuse channel, a default, bright diffuse will be used. 
		 * @param value The requested value of the bool. 
		 */
		virtual	void SetUseFallbackDiffuse( bool value ) = 0;

		/**
		 * The UseFallbackDiffuse boolean. If set to true and the material is missing 
		 * thediffuse channel, a default, bright diffuse will be used. 
		 */
		virtual	bool GetUseFallbackDiffuse(  ) = 0;

	};

	/**
	 * glTF scene importer 
	 */
	class IGLTFImporter : public IGraphicsImporter
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IGLTFImporter is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IGLTFImporter",type)==0 )
				return true;
			return IGraphicsImporter::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IGLTFImporter 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IGLTFImporter pointer 
		 * @return a pointer to the IGLTFImporter object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static IGLTFImporter *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IGLTFImporter") )
				return static_cast<IGLTFImporter*>(ptr);
			return nullptr;
		}
	};

	/**
	 * FBX scene importer 
	 */
	class IFBXImporter : public IGraphicsImporter
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IFBXImporter is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IFBXImporter",type)==0 )
				return true;
			return IGraphicsImporter::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IFBXImporter 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IFBXImporter pointer 
		 * @return a pointer to the IFBXImporter object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static IFBXImporter *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IFBXImporter") )
				return static_cast<IFBXImporter*>(ptr);
			return nullptr;
		}
	};
	class IScene;

	/**
	 * Base class for graphics export classes 
	 */
	class IGraphicsExporter : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IGraphicsExporter is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IGraphicsExporter",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IGraphicsExporter 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IGraphicsExporter pointer 
		 * @return a pointer to the IGraphicsExporter object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IGraphicsExporter *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IGraphicsExporter") )
				return static_cast<IGraphicsExporter*>(ptr);
			return nullptr;
		}
		/**
		 * The main export file path. This is the main file being written to, and must 
		 * always be set. 
		 * @param value The desired file path. 
		 */
		virtual	void SetExportFilePath( const char * value ) = 0;

		/**
		 * The main export file path. This is the main file being written to, and must 
		 * always be set. 
		 */
		virtual	spString GetExportFilePath(  ) = 0;

		/**
		 * The scene to export. 
		 * @param scene The desired scene object. 
		 */
		virtual	void SetScene( spScene scene ) = 0;

		/**
		 * The selection set (of nodes from the scene) to export. 
		 * @param exportSelectionSetID The desired selection set id to use. 
		 */
		virtual	void SetSelectionSet( int exportSelectionSetID ) = 0;

		/**
		 * Runs the export. Note that all required parameters must be setup before exporting. 
		 * @return True if the export was successful, false otherwise 
		 */
		virtual	bool RunExport(  ) = 0;

		/**
		 * The name of the texcoord level to use as primary level in case the file formatonly 
		 * supports a single texture coordinate layer. If the primary level name is notset, 
		 * the first found level will be used as primary level. 
		 * @param name The name of the primary texcoord level. 
		 */
		virtual	void SetPrimaryTexCoordName( const char * name ) = 0;

		/**
		 * The name of the texcoord level to use as primary level in case the file formatonly 
		 * supports a single texture coordinate layer. If the primary level name is notset, 
		 * the first found level will be used as primary level. 
		 */
		virtual	spString GetPrimaryTexCoordName(  ) = 0;

		/**
		 * Flag to control if cascaded scenes should be included in the export (note that 
		 * not all file formats support this). 
		 * @param value Export cascaded scenes flag. 
		 */
		virtual	void SetExportCascadedScenes( bool value ) = 0;

		/**
		 * Flag to control if cascaded scenes should be included in the export (note that 
		 * not all file formats support this). 
		 */
		virtual	bool GetExportCascadedScenes(  ) = 0;

	};

	/**
	 * Wavefront .obj geometry exporter. 
	 */
	class IWavefrontExporter : public IGraphicsExporter
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IWavefrontExporter is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IWavefrontExporter",type)==0 )
				return true;
			return IGraphicsExporter::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IWavefrontExporter 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IWavefrontExporter pointer 
		 * @return a pointer to the IWavefrontExporter object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IWavefrontExporter *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IWavefrontExporter") )
				return static_cast<IWavefrontExporter*>(ptr);
			return nullptr;
		}
		/**
		 * The material file path. If the path is not set, it is assumed to equal the 
		 * path of the main obj file, but with the extension '.mtl' instead of '.obj'. 
		 * @param value Is the path to the material file. 
		 */
		virtual	void SetMaterialFilePath( const char * value ) = 0;

		/**
		 * The material file path. If the path is not set, it is assumed to equal the 
		 * path of the main obj file, but with the extension '.mtl' instead of '.obj'. 
		 *  
		 */
		virtual	spString GetMaterialFilePath(  ) = 0;

	};

	/**
	 * FBX scene exporter. 
	 */
	class IFBXExporter : public IGraphicsExporter
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IFBXExporter is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IFBXExporter",type)==0 )
				return true;
			return IGraphicsExporter::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IFBXExporter 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IFBXExporter pointer 
		 * @return a pointer to the IFBXExporter object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static IFBXExporter *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IFBXExporter") )
				return static_cast<IFBXExporter*>(ptr);
			return nullptr;
		}
	};

	/**
	 * glTF geometry exporter capable of exporting both glTF and GLB files determined 
	 * by output path extension. Textures and binary blob files for glTF export will 
	 * be placed alongside the glTF file and have names prefixed by the output file 
	 * name. Note that any normal textures for the scene must be in tangent space, 
	 * as generated by a normal caster with SetGenerateTangentSpaceNormals set to true. 
	 */
	class IGLTFExporter : public IGraphicsExporter
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IGLTFExporter is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IGLTFExporter",type)==0 )
				return true;
			return IGraphicsExporter::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IGLTFExporter 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IGLTFExporter pointer 
		 * @return a pointer to the IGLTFExporter object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static IGLTFExporter *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IGLTFExporter") )
				return static_cast<IGLTFExporter*>(ptr);
			return nullptr;
		}
		/**
		 * Flag to control if referenced textures should be embedded in binary blob or 
		 * referenced by path to external files. 
		 * @param value Embed flag. 
		 */
		virtual	void SetEmbedReferences( bool value ) = 0;

		/**
		 * Flag to control if referenced textures should be embedded in binary blob or 
		 * referenced by path to external files. 
		 */
		virtual	bool GetEmbedReferences(  ) = 0;

	};

	/**
	 * BinaryImporter loads the geometry data from a binary file, that is specific 
	 * for Simplygon. Please note that the binary file is only intended for temporary 
	 * storage, and that no compatibility between versions of Simplygon is guaranteed. 
	 */
	class IBinaryImporter : public IGraphicsImporter
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IBinaryImporter is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IBinaryImporter",type)==0 )
				return true;
			return IGraphicsImporter::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IBinaryImporter 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IBinaryImporter pointer 
		 * @return a pointer to the IBinaryImporter object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static IBinaryImporter *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IBinaryImporter") )
				return static_cast<IBinaryImporter*>(ptr);
			return nullptr;
		}
	};

	/**
	 * BinaryExporter stores the geometry data into a binary file, that is specific 
	 * for Simplygon. Please note that the binary file is only intended for temporary 
	 * storage, and that no compatibility between versions of Simplygon is guaranteed. 
	 */
	class IBinaryExporter : public IGraphicsExporter
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IBinaryExporter is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IBinaryExporter",type)==0 )
				return true;
			return IGraphicsExporter::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IBinaryExporter 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IBinaryExporter pointer 
		 * @return a pointer to the IBinaryExporter object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static IBinaryExporter *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IBinaryExporter") )
				return static_cast<IBinaryExporter*>(ptr);
			return nullptr;
		}
	};
	class IGeometryData;

	/**
	 * Checks the geometry for consistent indices, number of triangles etc. 
	 */
	class IGeometryValidator : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IGeometryValidator is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IGeometryValidator",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IGeometryValidator 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IGeometryValidator pointer 
		 * @return a pointer to the IGeometryValidator object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IGeometryValidator *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IGeometryValidator") )
				return static_cast<IGeometryValidator*>(ptr);
			return nullptr;
		}
		/**
		 * Checks if the data stored in the Geometry is stored correctly. 
		 * @param geom The geometry data to validate. 
		 * @return True if the geometry is stored correct, or false if something is wrong. 
		 *  
		 */
		virtual	bool ValidateGeometry( spGeometryData geom ) = 0;

		/**
		 * Returns the error-code for the last check that was performed. 0 means no error 
		 * was found, and values less than 0 means an error was found. 
		 * @return The last error-code 
		 */
		virtual	unsigned int GetErrorValue(  ) = 0;

		/**
		 * Returns a string describing the error that was found for the last check that 
		 * was performed. 
		 * @return The last string describing the error 
		 */
		virtual	spString GetErrorString(  ) = 0;

		/**
		 * If set, faces that have the same index more than once will not be allowed. 
		 * @param value The desired flag value. 
		 */
		virtual	void SetCheckDegenerateFaceIndices( bool value ) = 0;

		/**
		 * If set, faces that have the same index more than once will not be allowed. 
		 *  
		 */
		virtual	bool GetCheckDegenerateFaceIndices(  ) = 0;

		/**
		 * If set, faces that have zero area will not be allowed. 
		 * @param value The desired flag value. 
		 */
		virtual	void SetCheckZeroAreaFaces( bool value ) = 0;

		/**
		 * If set, faces that have zero area will not be allowed. 
		 */
		virtual	bool GetCheckZeroAreaFaces(  ) = 0;

		/**
		 * This is the number of allowed materials used in the scene. Only indices within 
		 * this range are allowed. 
		 * @param value The desired flag value. 
		 */
		virtual	void SetAllowedMaterialCount( unsigned int value ) = 0;

		/**
		 * This is the number of allowed bones used in the scene. Only indices within 
		 * this range are allowed. 
		 * @param value The desired flag value. 
		 * @return The flag value 
		 */
		virtual	void SetAllowedBoneCount( unsigned int value ) = 0;

		/**
		 * This is the number of allowed groups/objects used in the scene. Only indices 
		 * within this range are allowed. 
		 * @param value The desired flag value. 
		 * @return The flag value 
		 */
		virtual	void SetAllowedGroupCount( unsigned int value ) = 0;

	};

	/**
	 * SettingsObject is the abstract base class for all settings objects in Simplygon. 
	 * Settings objects contains parameters for processing objects to use. These settings 
	 * objects will have their data set and reached from a ProcessingObject and then 
	 * used therein. 
	 */
	class ISettingsObject : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if ISettingsObject is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("ISettingsObject",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a ISettingsObject 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ISettingsObject pointer 
		 * @return a pointer to the ISettingsObject object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static ISettingsObject *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("ISettingsObject") )
				return static_cast<ISettingsObject*>(ptr);
			return nullptr;
		}
		/**
		 * Validates the current settings values. 
		 * @return True if all settings are valid 
		 */
		virtual	bool ValidateSettings(  ) = 0;

		/**
		 * Returns a string describing the error that was found the last time ValidateSettings 
		 * was performed. 
		 * @return The last string describing the error 
		 */
		virtual	spString GetErrorString(  ) = 0;

		/**
		 * Set a named parameter boolean value. 
		 * @param name Parameter name. 
		 * @param value New value for parameter. 
		 * @return True if successful, false if error (mismatching parameter type) 
		 */
		virtual	bool SetBoolParameter( const char * name , bool value ) = 0;

		/**
		 * Set a named parameter integer value. 
		 * @param name Parameter name. 
		 * @param value New value for parameter. 
		 * @return True if successful, false if error (mismatching parameter type) 
		 */
		virtual	bool SetIntParameter( const char * name , int value ) = 0;

		/**
		 * Set a named parameter unsigned integer value. 
		 * @param name Parameter name. 
		 * @param value New value for parameter. 
		 * @return True if successful, false if error (mismatching parameter type) 
		 */
		virtual	bool SetUIntParameter( const char * name , unsigned int value ) = 0;

		/**
		 * Set a named parameter floating point value. 
		 * @param name Parameter name. 
		 * @param value New value for parameter. 
		 * @return True if successful, false if error (mismatching parameter type) 
		 */
		virtual	bool SetDoubleParameter( const char * name , double value ) = 0;

		/**
		 * Set a named parameter string value. 
		 * @param name Parameter name. 
		 * @param value New value for parameter. 
		 * @return True if successful, false if error (mismatching parameter type) 
		 */
		virtual	bool SetStringParameter( const char * name , const char * value ) = 0;

		/**
		 * Get a named parameter boolean value. 
		 * @param name Parameter name. 
		 * @return Parameter value, or false if mismatching type 
		 */
		virtual	bool GetBoolParameter( const char * name ) = 0;

		/**
		 * Get a named parameter integer value. 
		 * @param name Parameter name. 
		 * @return Parameter value, or 0 if mismatching type 
		 */
		virtual	int GetIntParameter( const char * name ) = 0;

		/**
		 * Get a named parameter unsigned integer value. 
		 * @param name Parameter name. 
		 * @return Parameter value, or 0 if mismatching type 
		 */
		virtual	unsigned int GetUIntParameter( const char * name ) = 0;

		/**
		 * Get a named parameter floating point value. 
		 * @param name Parameter name. 
		 * @return Parameter value, or 0 if mismatching type 
		 */
		virtual	double GetDoubleParameter( const char * name ) = 0;

		/**
		 * Get a named parameter string value. 
		 * @param name Parameter name. 
		 * @return Parameter value, or null pointer if mismatching type 
		 */
		virtual	spString GetStringParameter( const char * name ) = 0;

		/**
		 * Get settings as JSON for debugging purposes. 
		 * @return All settings as JSON 
		 */
		virtual	spString ToJSON(  ) = 0;

		/**
		 * Set if parameter names should be validated or not. Parameters that previously 
		 * do not exist will generate and error if validation is enabled and be allowed 
		 * if validation is disabled. 
		 * @param validate Flag indicating if validation is performed or not. 
		 */
		virtual	void SetValidateParameterNames( bool validate ) = 0;

	};
	class IMaterialCasterSettings;
	class ITextureTable;
	class IMaterialTable;
	class IMappingImage;
	class IImageData;

	/**
	 * MaterialCaster is the base interface for material casting interfaces. The interface 
	 * exports methods for defining input geometries & mapping image, materials, output 
	 * image paths & formats 
	 */
	class IMaterialCaster : public IProcessingObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IMaterialCaster is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IMaterialCaster",type)==0 )
				return true;
			return IProcessingObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IMaterialCaster 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IMaterialCaster pointer 
		 * @return a pointer to the IMaterialCaster object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static IMaterialCaster *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IMaterialCaster") )
				return static_cast<IMaterialCaster*>(ptr);
			return nullptr;
		}
		/**
		 * The settings object. 
		 */
		virtual	spMaterialCasterSettings GetMaterialCasterSettings(  ) = 0;

		/**
		 * The SourceTextures object. The SourceTextures object contains all textures 
		 * of the the source geometry. 
		 * @param value The texture table to which SourceTextures will be set. 
		 */
		virtual	void SetSourceTextures( spTextureTable value ) = 0;

		/**
		 * The SourceTextures object. The SourceTextures object contains all textures 
		 * of the the source geometry. 
		 */
		virtual	spTextureTable GetSourceTextures(  ) = 0;

		/**
		 * The SourceMaterials object. The SourceMaterials object contains all materials 
		 * of the the source geometry. The source geometry must have a "MaterialIds" field 
		 * that indices the material table. 
		 * @param value The material table to which SourceMaterials will be set. 
		 */
		virtual	void SetSourceMaterials( spMaterialTable value ) = 0;

		/**
		 * The SourceMaterials object. The SourceMaterials object contains all materials 
		 * of the the source geometry. The source geometry must have a "MaterialIds" field 
		 * that indices the material table. 
		 */
		virtual	spMaterialTable GetSourceMaterials(  ) = 0;

		/**
		 * The DestMaterialId object. If set, only the parts of the destination map that. 
		 * To disable, set to -1. 
		 * @param value The value to which DestMaterialId will be set. 
		 */
		virtual	void SetDestMaterialId( rid value ) = 0;

		/**
		 * The DestMaterialId object. If set, only the parts of the destination map that. 
		 * To disable, set to -1. 
		 */
		virtual	rid GetDestMaterialId(  ) = 0;

		/**
		 * The MappingImage object. The MappingImage object contains the mapping between 
		 * the Geometry and SourceGeometry objects. 
		 * @param value The mapping image to which MappingImage will be set. 
		 */
		virtual	void SetMappingImage( spMappingImage value ) = 0;

		/**
		 * The MappingImage object. The MappingImage object contains the mapping between 
		 * the Geometry and SourceGeometry objects. 
		 */
		virtual	spMappingImage GetMappingImage(  ) = 0;

		/**
		 * The OutputFilePath file path, where the output image will be placed. Note that 
		 * the extension will be appended the file path if it differs from the OutputImageFileFormat 
		 * set in the caster settings object. Either OutputImage or OutputFilePath must 
		 * be set. If OutputImage is set, then OutputFilePath is ignored. 
		 * @param value The string to which OutputFilePath will be set. 
		 */
		virtual	void SetOutputFilePath( const char * value ) = 0;

		/**
		 * The OutputFilePath file path, where the output image will be placed. Note that 
		 * the extension will be appended the file path if it differs from the OutputImageFileFormat 
		 * set in the caster settings object. Either OutputImage or OutputFilePath must 
		 * be set. If OutputImage is set, then OutputFilePath is ignored. 
		 */
		virtual	spString GetOutputFilePath(  ) = 0;

		/**
		 * The OutputImage object that will receive the image. The current contents of 
		 * the image will be removed, and the image will be written to the Colors field 
		 * of the ImageData object. Either OutputImage or OutputFilePath must be set. 
		 * If OutputImage is set, then OutputFilePath is ignored. 
		 * @param value The image data to which OutputImage will be set. 
		 */
		virtual	void SetOutputImage( spImageData value ) = 0;

		/**
		 * The OutputImage object that will receive the image. The current contents of 
		 * the image will be removed, and the image will be written to the Colors field 
		 * of the ImageData object. Either OutputImage or OutputFilePath must be set. 
		 * If OutputImage is set, then OutputFilePath is ignored. 
		 */
		virtual	spImageData GetOutputImage(  ) = 0;

	};

	/**
	 * MaterialCasterSettings is the base interface for material casting settings 
	 */
	class IMaterialCasterSettings : public ISettingsObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IMaterialCasterSettings is a or is a 
		 * descendant of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IMaterialCasterSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IMaterialCasterSettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IMaterialCasterSettings pointer 
		 * @return a pointer to the IMaterialCasterSettings object, if the cast can be 
		 * made, and a NULL pointer otherwise 
		 */

		static IMaterialCasterSettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IMaterialCasterSettings") )
				return static_cast<IMaterialCasterSettings*>(ptr);
			return nullptr;
		}
		/**
		 * The name of the input material channel to cast. Existing user channels of any 
		 * arbitrary name in the input materials can be cast. 
		 * @param value The input material channel name. 
		 */
		virtual	void SetMaterialChannel( const char * value ) = 0;

		/**
		 * The name of the input material channel to cast. Existing user channels of any 
		 * arbitrary name in the input materials can be cast. 
		 */
		virtual	spString GetMaterialChannel(  ) = 0;

		/**
		 * The name of the input opacity channel to use for combining layers in most casters 
		 * and casting opacity in the opacitycaster. User channels of any arbitrary name 
		 * can be used. 
		 * @param value The desired material channel. 
		 */
		virtual	void SetOpacityChannel( const char * value ) = 0;

		/**
		 * The name of the input opacity channel to use for combining layers in most casters 
		 * and casting opacity in the opacitycaster. User channels of any arbitrary name 
		 * can be used. 
		 */
		virtual	spString GetOpacityChannel(  ) = 0;

		/**
		 * The component in the opacity channel to use as opacity value. 
		 * @param value The desired component in the opacity material channel to use as 
		 * opacity value. 
		 */
		virtual	void SetOpacityChannelComponent( Simplygon::EColorComponent value ) = 0;

		/**
		 * The component in the opacity channel to use as opacity value. 
		 */
		virtual	Simplygon::EColorComponent GetOpacityChannelComponent(  ) = 0;

		/**
		 * The Dilation value. Where applicable, such as colors and normals, the caster 
		 * will fill empty pixels surrounding filled pixels with values mixed from the 
		 * filled ones. This setting sets how many pixels to fill outside the original 
		 * filled pixels. 
		 * @param value The value to which Dilation will be set. Value cannot be less 
		 * than 0. Value cannot be greater than 1000. 
		 */
		virtual	void SetDilation( unsigned int value ) = 0;

		/**
		 * The Dilation value. Where applicable, such as colors and normals, the caster 
		 * will fill empty pixels surrounding filled pixels with values mixed from the 
		 * filled ones. This setting sets how many pixels to fill outside the original 
		 * filled pixels. 
		 */
		virtual	unsigned int GetDilation(  ) = 0;

		/**
		 * The output pixel format 
		 * @param value The desired value to which OutputChannels will be set. 
		 */
		virtual	void SetOutputPixelFormat( Simplygon::EPixelFormat value ) = 0;

		/**
		 * The output pixel format 
		 */
		virtual	Simplygon::EPixelFormat GetOutputPixelFormat(  ) = 0;

		/**
		 * The type of dithering to use when creating the output object. 
		 * @param value The desired value of the DitherType to use. 
		 */
		virtual	void SetDitherType( Simplygon::EDitherPatterns value ) = 0;

		/**
		 * The type of dithering to use when creating the output object. 
		 */
		virtual	Simplygon::EDitherPatterns GetDitherType(  ) = 0;

		/**
		 * The fill mode determines what to do with the pixels that remain unfilled after 
		 * both the casting and dilation has been performed. Options are: None = Do not 
		 * fill remaining pixels Interpolate = linearly interpolate the closest samples 
		 *  NearestNeighbor = use the closest available pixel value without interpolation. 
		 * @param value The mode to which the fill mode will be set. 
		 */
		virtual	void SetFillMode( Simplygon::EAtlasFillMode value ) = 0;

		/**
		 * The fill mode determines what to do with the pixels that remain unfilled after 
		 * both the casting and dilation has been performed. Options are: None = Do not 
		 * fill remaining pixels Interpolate = linearly interpolate the closest samples 
		 *  NearestNeighbor = use the closest available pixel value without interpolation. 
		 *  
		 */
		virtual	Simplygon::EAtlasFillMode GetFillMode(  ) = 0;

		/**
		 * Enable or disable multisampling. 
		 * @param value The desired value of the flag. 
		 */
		virtual	void SetUseMultisampling( bool value ) = 0;

		/**
		 * Enable or disable multisampling. 
		 */
		virtual	bool GetUseMultisampling(  ) = 0;

		/**
		 * File format for output texture. 
		 * @param value The desired file format. 
		 */
		virtual	void SetOutputImageFileFormat( Simplygon::EImageOutputFormat value ) = 0;

		/**
		 * File format for output texture. 
		 */
		virtual	Simplygon::EImageOutputFormat GetOutputImageFileFormat(  ) = 0;

		/**
		 * DDS compression if output format is DDS. 
		 * @param value The desired DDS compression type. 
		 */
		virtual	void SetOutputDDSCompressionType( Simplygon::EDDSCompressionType value ) = 0;

		/**
		 * DDS compression if output format is DDS. 
		 */
		virtual	Simplygon::EDDSCompressionType GetOutputDDSCompressionType(  ) = 0;

	};
	class IColorCasterSettings;

	/**
	 * ColorCaster is the interface used to cast basic color values. Currently supported 
	 * material color value types are Ambient, Diffuse and Specular + Shininess. 
	 */
	class IColorCaster : public IMaterialCaster
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IColorCaster is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IColorCaster",type)==0 )
				return true;
			return IMaterialCaster::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IColorCaster 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IColorCaster pointer 
		 * @return a pointer to the IColorCaster object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static IColorCaster *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IColorCaster") )
				return static_cast<IColorCaster*>(ptr);
			return nullptr;
		}
		/**
		 * If SkipCastingIfNoInputChannel is set to true, and the last processing skipped, 
		 * the LastCastingWasSkipped will be set to true. The initial value before the 
		 * first process will be set to false. 
		 */
		virtual	bool GetLastCastingWasSkipped(  ) = 0;

		/**
		 * The color caster settings object. 
		 * @return Color caster settings object. 
		 */
		virtual	spColorCasterSettings GetColorCasterSettings(  ) = 0;

	};

	/**
	 * ColorCasterSettings is the interface for basic color caster settings. 
	 */
	class IColorCasterSettings : public IMaterialCasterSettings
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IColorCasterSettings is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IColorCasterSettings",type)==0 )
				return true;
			return IMaterialCasterSettings::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IColorCasterSettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IColorCasterSettings pointer 
		 * @return a pointer to the IColorCasterSettings object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IColorCasterSettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IColorCasterSettings") )
				return static_cast<IColorCasterSettings*>(ptr);
			return nullptr;
		}
		/**
		 * If set, the total opacity of the baked layers replaces the alpha value in the 
		 * output texture. 
		 * @param value The new BakeOpacityInAlpha value. 
		 * @return The current BakeOpacityInAlpha value 
		 */
		virtual	void SetBakeOpacityInAlpha( bool value ) = 0;

		/**
		 * If set, the total opacity of the baked layers replaces the alpha value in the 
		 * output texture. 
		 * @return The current BakeOpacityInAlpha value Default value is false 
		 */
		virtual	bool GetBakeOpacityInAlpha(  ) = 0;

		/**
		 * The opacity type determines how the opacity channel of this material should 
		 * be saved. To make (0.0->1.0) map to (transparent-opaque), use 'Opacity'. To 
		 * make (0.0->1.0) map to (opaque-transparent), use 'Transparency' 
		 * @param value The new opacity type. 
		 */
		virtual	void SetOutputOpacityType( Simplygon::EOpacityType value ) = 0;

		/**
		 * The opacity type determines how the opacity channel of this material should 
		 * be saved. To make (0.0->1.0) map to (transparent-opaque), use 'Opacity'. To 
		 * make (0.0->1.0) map to (opaque-transparent), use 'Transparency' 
		 */
		virtual	Simplygon::EOpacityType GetOutputOpacityType(  ) = 0;

		/**
		 * If this flag is set, the caster will only run if there is at least one input 
		 * material that has the main input channel which is to be cast. If the flag is 
		 * not set, the caster will always produce an output, even if it is totally empty/unset. 
		 * @param value The desired SkipCastingIfNoInputChannel flag. 
		 * @return The current SkipCastingIfNoInputChannel flag. 
		 */
		virtual	void SetSkipCastingIfNoInputChannel( bool value ) = 0;

		/**
		 * If this flag is set, the caster will only run if there is at least one input 
		 * material that has the main input channel which is to be cast. If the flag is 
		 * not set, the caster will always produce an output, even if it is totally empty/unset. 
		 * @return The current SkipCastingIfNoInputChannel flag. Default value is false 
		 *  
		 */
		virtual	bool GetSkipCastingIfNoInputChannel(  ) = 0;

		/**
		 * If set, output textures are exported in sRGB format. Input texture format is 
		 * determined by the flag in the corresponding texture node in the material definition. 
		 * @param value The desired sRGB flag. 
		 */
		virtual	void SetOutputSRGB( bool value ) = 0;

		/**
		 * If set, output textures are exported in sRGB format. Input texture format is 
		 * determined by the flag in the corresponding texture node in the material definition. 
		 *  
		 */
		virtual	bool GetOutputSRGB(  ) = 0;

	};
	class IOpacityCasterSettings;

	/**
	 * OpacityCaster is the interface used to cast opacity values. To be used when 
	 * opacity is needed as a separate texture. IMPORTANT: Make sure to set OpacityChannel 
	 * to the channel you want to cast, since this caster bakes opacity rather than 
	 * the channel set in the MaterialChannel setting like most other casters. 
	 */
	class IOpacityCaster : public IMaterialCaster
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IOpacityCaster is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IOpacityCaster",type)==0 )
				return true;
			return IMaterialCaster::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IOpacityCaster 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IOpacityCaster pointer 
		 * @return a pointer to the IOpacityCaster object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static IOpacityCaster *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IOpacityCaster") )
				return static_cast<IOpacityCaster*>(ptr);
			return nullptr;
		}
		/**
		 * The opacity caster settings object. 
		 * @return Opacity caster settings object. 
		 */
		virtual	spOpacityCasterSettings GetOpacityCasterSettings(  ) = 0;

	};

	/**
	 * OpacityCasterSettings is the interface used to manage settings for an opacity 
	 * caster. IMPORTANT: Make sure to set the OpacityChannel setting to the channel 
	 * you want to cast, since this caster bakes opacity rather than the channel set 
	 * in the MaterialChannel setting like most other casters. 
	 */
	class IOpacityCasterSettings : public IMaterialCasterSettings
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IOpacityCasterSettings is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IOpacityCasterSettings",type)==0 )
				return true;
			return IMaterialCasterSettings::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IOpacityCasterSettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IOpacityCasterSettings pointer 
		 * @return a pointer to the IOpacityCasterSettings object, if the cast can be 
		 * made, and a NULL pointer otherwise 
		 */

		static IOpacityCasterSettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IOpacityCasterSettings") )
				return static_cast<IOpacityCasterSettings*>(ptr);
			return nullptr;
		}
		/**
		 * If set, output textures are exported in sRGB format. Input texture format is 
		 * determined by the flag in the corresponding texture node in the material definition. 
		 * @param value The desired sRGB flag. 
		 */
		virtual	void SetOutputSRGB( bool value ) = 0;

		/**
		 * If set, output textures are exported in sRGB format. Input texture format is 
		 * determined by the flag in the corresponding texture node in the material definition. 
		 *  
		 */
		virtual	bool GetOutputSRGB(  ) = 0;

		/**
		 * The opacity type determines how the opacity channel of this material should 
		 * be saved. To make (0.0->1.0) map to (transparent-opaque), use 'Opacity'. To 
		 * make (0.0->1.0) map to (opaque-transparent), use 'Transparency' 
		 * @param value The new opacity type. 
		 */
		virtual	void SetOutputOpacityType( Simplygon::EOpacityType value ) = 0;

		/**
		 * The opacity type determines how the opacity channel of this material should 
		 * be saved. To make (0.0->1.0) map to (transparent-opaque), use 'Opacity'. To 
		 * make (0.0->1.0) map to (opaque-transparent), use 'Transparency' 
		 */
		virtual	Simplygon::EOpacityType GetOutputOpacityType(  ) = 0;

	};
	class INormalCasterSettings;

	/**
	 * NormalCaster is the interface used to cast normals data onto the receiving geometry. 
	 */
	class INormalCaster : public IMaterialCaster
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if INormalCaster is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("INormalCaster",type)==0 )
				return true;
			return IMaterialCaster::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a INormalCaster 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a INormalCaster pointer 
		 * @return a pointer to the INormalCaster object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static INormalCaster *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("INormalCaster") )
				return static_cast<INormalCaster*>(ptr);
			return nullptr;
		}
		/**
		 * The normal caster settings object. 
		 * @return Normal caster settings object. 
		 */
		virtual	spNormalCasterSettings GetNormalCasterSettings(  ) = 0;

	};

	/**
	 * NormalCasterSettings is the interface used to manage settings for a normal caster 
	 */
	class INormalCasterSettings : public IMaterialCasterSettings
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if INormalCasterSettings is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("INormalCasterSettings",type)==0 )
				return true;
			return IMaterialCasterSettings::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a INormalCasterSettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a INormalCasterSettings pointer 
		 * @return a pointer to the INormalCasterSettings object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static INormalCasterSettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("INormalCasterSettings") )
				return static_cast<INormalCasterSettings*>(ptr);
			return nullptr;
		}
		/**
		 * If set, then normals will be flipped if they are back facing, i.e. pointing 
		 * into the surface. This may introduce artifacts on geometries that have correctly 
		 * facing normals, so only use for geometries with known back-facing normals. 
		 * @param value The value to which the FlipBackfacingNormals bool is to be set. 
		 *  
		 */
		virtual	void SetFlipBackfacingNormals( bool value ) = 0;

		/**
		 * If set, then normals will be flipped if they are back facing, i.e. pointing 
		 * into the surface. This may introduce artifacts on geometries that have correctly 
		 * facing normals, so only use for geometries with known back-facing normals. 
		 *  
		 */
		virtual	bool GetFlipBackfacingNormals(  ) = 0;

		/**
		 * If set, then the generated normal map will be in tangent space. Please note 
		 * that the geometry casted to must contain tangent space fields. 
		 * @param value The value to which the GenerateTangentSpaceNormals bool is to 
		 * be set. 
		 */
		virtual	void SetGenerateTangentSpaceNormals( bool value ) = 0;

		/**
		 * If set, then the generated normal map will be in tangent space. Please note 
		 * that the geometry casted to must contain tangent space fields. 
		 */
		virtual	bool GetGenerateTangentSpaceNormals(  ) = 0;

		/**
		 * If set, the green channel is assumed to point along the negative bitangent 
		 * instead of the positive. This is roughly equivalent to switching between left- 
		 * and righthanded, but some rounding may differ. 
		 * @param value The value the FlipGreen bool is to be set. 
		 */
		virtual	void SetFlipGreen( bool value ) = 0;

		/**
		 * If set, the green channel is assumed to point along the negative bitangent 
		 * instead of the positive. This is roughly equivalent to switching between left- 
		 * and righthanded, but some rounding may differ. 
		 */
		virtual	bool GetFlipGreen(  ) = 0;

		/**
		 * If set, the normal caster calculates the bitangent used for encoding per-fragment 
		 * using the normal, tangent and bitangent sign instead of interpolating the actual 
		 * bitangent vertex data. This needs to match the behaviour of the renderer to 
		 * not produce rendering artifacts. 
		 * @param value The value the CalculateBitangentPerFragment bool is to be set. 
		 *  
		 */
		virtual	void SetCalculateBitangentPerFragment( bool value ) = 0;

		/**
		 * If set, the normal caster calculates the bitangent used for encoding per-fragment 
		 * using the normal, tangent and bitangent sign instead of interpolating the actual 
		 * bitangent vertex data. This needs to match the behaviour of the renderer to 
		 * not produce rendering artifacts. 
		 */
		virtual	bool GetCalculateBitangentPerFragment(  ) = 0;

		/**
		 * If set, the normal caster normalizes the normal and tangent data used for encoding 
		 * after interpolation. This needs to match the behaviour of the renderer to not 
		 * produce rendering artifacts. 
		 * @param value The value the NormalizeInterpolatedTangentSpace bool is to be 
		 * set. 
		 */
		virtual	void SetNormalizeInterpolatedTangentSpace( bool value ) = 0;

		/**
		 * If set, the normal caster normalizes the normal and tangent data used for encoding 
		 * after interpolation. This needs to match the behaviour of the renderer to not 
		 * produce rendering artifacts. 
		 */
		virtual	bool GetNormalizeInterpolatedTangentSpace(  ) = 0;

	};
	class IScene;
	class IGeometryData;

	/**
	 * Repairs normals on a processed geometry. 
	 */
	class INormalRepairer : public IProcessingObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if INormalRepairer is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("INormalRepairer",type)==0 )
				return true;
			return IProcessingObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a INormalRepairer 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a INormalRepairer pointer 
		 * @return a pointer to the INormalRepairer object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static INormalRepairer *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("INormalRepairer") )
				return static_cast<INormalRepairer*>(ptr);
			return nullptr;
		}
		/**
		 * The scene. 
		 * @param value The scene object to use. 
		 */
		virtual	void SetScene( spScene value ) = 0;

		/**
		 * The scene. 
		 */
		virtual	spScene GetScene(  ) = 0;

		/**
		 * The ID of the SelectionSet containing the meshes to process If the ID is -1, 
		 * all meshes are selected. 
		 * @param value The selection set id to use. 
		 */
		virtual	void SetProcessSelectionSetID( rid value ) = 0;

		/**
		 * The ID of the SelectionSet containing the meshes to process If the ID is -1, 
		 * all meshes are selected. 
		 */
		virtual	rid GetProcessSelectionSetID(  ) = 0;

		/**
		 * Which selection set should be processed. If SetName is not found, all geometries 
		 * in the scene will be processed. If both selection set name and ID are set, 
		 * the name will be used. 
		 * @param value The desired SelectionSet name. 
		 */
		virtual	void SetProcessSelectionSetName( const char * value ) = 0;

		/**
		 * Which selection set should be processed. If SetName is not found, all geometries 
		 * in the scene will be processed. If both selection set name and ID are set, 
		 * the name will be used. 
		 */
		virtual	spString GetProcessSelectionSetName(  ) = 0;

		/**
		 * Set/Get whether to recalculate new normals. 
		 * @param value The new value of RecalculateNormals. 
		 */
		virtual	void SetRecalculateNormals( bool value ) = 0;

		/**
		 * Set/Get whether to recalculate new normals. 
		 */
		virtual	bool GetRecalculateNormals(  ) = 0;

		/**
		 * The edge angle in degrees above which an edge is considered "hard". 
		 * @param value The value to which HardEdgeAngle is to be set. Value cannot be 
		 * less than 0. Value cannot be greater than 180. 
		 */
		virtual	void SetHardEdgeAngle( real value ) = 0;

		/**
		 * The edge angle in degrees above which an edge is considered "hard". 
		 */
		virtual	real GetHardEdgeAngle(  ) = 0;

		/**
		 * The ScaleByArea flag. If set, the influence of a triangle normal upon the vertex 
		 * normals is scaled by the area of the triangle. 
		 * @param value The value to which the ScaleByArea bool is to be set. 
		 */
		virtual	void SetScaleByArea( bool value ) = 0;

		/**
		 * The ScaleByArea flag. If set, the influence of a triangle normal upon the vertex 
		 * normals is scaled by the area of the triangle. 
		 */
		virtual	bool GetScaleByArea(  ) = 0;

		/**
		 * The ScaleByAngle flag. If set, the influence of a triangle normal upon the 
		 * vertex normals is scaled by the angle of the corner at the vertex. 
		 * @param value The value to which the ScaleByAngle bool is to be set. 
		 */
		virtual	void SetScaleByAngle( bool value ) = 0;

		/**
		 * The ScaleByAngle flag. If set, the influence of a triangle normal upon the 
		 * vertex normals is scaled by the angle of the corner at the vertex. 
		 */
		virtual	bool GetScaleByAngle(  ) = 0;

		/**
		 * The RepairOnlyInvalidNormals flag If set, then only those normals that are 
		 * invalid (backfacing, zero length etc) will be fixed. 
		 * @param value The value to which the RepairOnlyInvalidNormals bool is to be 
		 * set. 
		 */
		virtual	void SetRepairOnlyInvalidNormals( bool value ) = 0;

		/**
		 * The RepairOnlyInvalidNormals flag If set, then only those normals that are 
		 * invalid (backfacing, zero length etc) will be fixed. 
		 */
		virtual	bool GetRepairOnlyInvalidNormals(  ) = 0;

		/**
		 * The SnapNormalsToFlatSurfaces flag. If set, perfectly flat shaded surfaces 
		 * will be created, where possible. Normals adjacent to perfectly geometrically 
		 * flat surfaces will be recalculated to have the same direction as for those 
		 * of the adjacent flat surface. 
		 * @param value To use for SnapNormalsToFlatSurfaces. 
		 */
		virtual	void SetSnapNormalsToFlatSurfaces( bool value ) = 0;

		/**
		 * The SnapNormalsToFlatSurfaces flag. If set, perfectly flat shaded surfaces 
		 * will be created, where possible. Normals adjacent to perfectly geometrically 
		 * flat surfaces will be recalculated to have the same direction as for those 
		 * of the adjacent flat surface. 
		 */
		virtual	bool GetSnapNormalsToFlatSurfaces(  ) = 0;

		/**
		 * Set/Get setting for whether and how to flip the faces and or normals in the 
		 * scene. None - Don't flip Automatic - Automatically detect and fix backfaces 
		 * per part MakeDoubleSided - Append inverted winded triangles with inverted normals 
		 * to the geometry InvertFaces - Invert the winding of the triangles InvertNormals 
		 * - Invert the vertex normals InvertFacesAndNormals - Invert winding of all triangles 
		 * and vertex normals. 
		 * @param value The desired flag value. 
		 */
		virtual	void SetFlipFacesAndNormals( Simplygon::EFlipFacesAndNormals value ) = 0;

		/**
		 * Set/Get setting for whether and how to flip the faces and or normals in the 
		 * scene. None - Don't flip Automatic - Automatically detect and fix backfaces 
		 * per part MakeDoubleSided - Append inverted winded triangles with inverted normals 
		 * to the geometry InvertFaces - Invert the winding of the triangles InvertNormals 
		 * - Invert the vertex normals InvertFacesAndNormals - Invert winding of all triangles 
		 * and vertex normals. 
		 */
		virtual	Simplygon::EFlipFacesAndNormals GetFlipFacesAndNormals(  ) = 0;

		/**
		 * The Geometry object. 
		 * @param value The geometry that is to be repaired. 
		 */
		virtual	void SetGeometry( spGeometryData value ) = 0;

		/**
		 * The Geometry object. 
		 */
		virtual	spGeometryData GetGeometry(  ) = 0;

		/**
		 * Set true to allow for double sided triangles. 
		 * @param value The desired value of the flag. 
		 */
		virtual	void SetAutoCorrectionAllowsDoubleSided( bool value ) = 0;

		/**
		 * The threshold ratio for auto correction. 
		 * @param value The desired threshold ratio. 
		 */
		virtual	void SetAutoCorrectionRatioThreshold( real value ) = 0;

		/**
		 * The threshold ratio for auto correction to treat triangle as single sided. 
		 * @param value The desired threshold. 
		 */
		virtual	void SetAutoCorrectionSingleSidedThreshold( real value ) = 0;

	};
	class IDisplacementCasterSettings;

	/**
	 * DisplacementCaster is used to store the delta-values between the original and 
	 * processed geometries. The values are divided by a scaling value, and clamped 
	 * into the -1 -> 1 range before being stored into an image. 
	 */
	class IDisplacementCaster : public IMaterialCaster
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IDisplacementCaster is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IDisplacementCaster",type)==0 )
				return true;
			return IMaterialCaster::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IDisplacementCaster 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IDisplacementCaster pointer 
		 * @return a pointer to the IDisplacementCaster object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IDisplacementCaster *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IDisplacementCaster") )
				return static_cast<IDisplacementCaster*>(ptr);
			return nullptr;
		}
		/**
		 * The displacement caster settings object. 
		 * @return Displacement caster settings object. 
		 */
		virtual	spDisplacementCasterSettings GetDisplacementCasterSettings(  ) = 0;

	};

	/**
	 * DisplacementCasterSettings is used to store the settings for a displacement 
	 * caster 
	 */
	class IDisplacementCasterSettings : public IMaterialCasterSettings
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IDisplacementCasterSettings is a or is 
		 * a descendant of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IDisplacementCasterSettings",type)==0 )
				return true;
			return IMaterialCasterSettings::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IDisplacementCasterSettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IDisplacementCasterSettings pointer 
		 * @return a pointer to the IDisplacementCasterSettings object, if the cast can 
		 * be made, and a NULL pointer otherwise 
		 */

		static IDisplacementCasterSettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IDisplacementCasterSettings") )
				return static_cast<IDisplacementCasterSettings*>(ptr);
			return nullptr;
		}
		/**
		 * All the delta values are divided by this value before storing them into an 
		 * image. 
		 * @param value The desired DistanceScaling value. Value cannot be less than 0. 
		 * Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetDistanceScaling( real value ) = 0;

		/**
		 * All the delta values are divided by this value before storing them into an 
		 * image. 
		 */
		virtual	real GetDistanceScaling(  ) = 0;

		/**
		 * If set to true, the size of the displacement vector components in the direction 
		 * of the interpolated normal are stored in the displacement map, instead of the 
		 * displacement vectors. 
		 * @param value The desired GenerateScalarDisplacement flag. 
		 */
		virtual	void SetGenerateScalarDisplacement( bool value ) = 0;

		/**
		 * If set to true, the size of the displacement vector components in the direction 
		 * of the interpolated normal are stored in the displacement map, instead of the 
		 * displacement vectors. 
		 */
		virtual	bool GetGenerateScalarDisplacement(  ) = 0;

		/**
		 * If set, the displacement vectors are transformed into the destination object 
		 * tangent space. 
		 * @param value The desired GenerateTangentSpaceDisplacement flag. 
		 */
		virtual	void SetGenerateTangentSpaceDisplacement( bool value ) = 0;

		/**
		 * If set, the displacement vectors are transformed into the destination object 
		 * tangent space. 
		 */
		virtual	bool GetGenerateTangentSpaceDisplacement(  ) = 0;

		/**
		 * The texture coordinate level to use for the tangent space displacement vectors. 
		 * @param value The desired NormalMapTextureLevel value. Value cannot be less 
		 * than 0. Value cannot be greater than UINT_MAX. 
		 */
		virtual	void SetNormalMapTexCoordLevel( rid value ) = 0;

		/**
		 * The texture coordinate level to use for the tangent space displacement vectors. 
		 *  
		 */
		virtual	rid GetNormalMapTexCoordLevel(  ) = 0;

	};
	class IGeometryData;
	class ISceneNode;

	/**
	 * TangentCalculator calculates tangent vectors for geometry data objects. One 
	 * corner field of texture coordinates must exist, as well as normals. The tangents 
	 * are placed into two corner fields called "Tangents" and "Bitangents". If any 
	 * of these fields already exists, it is replaced by the new field. 
	 */
	class ITangentCalculator : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if ITangentCalculator is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("ITangentCalculator",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a ITangentCalculator 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ITangentCalculator pointer 
		 * @return a pointer to the ITangentCalculator object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static ITangentCalculator *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("ITangentCalculator") )
				return static_cast<ITangentCalculator*>(ptr);
			return nullptr;
		}
		/**
		 * Calculates the tangents of a geometry data object. 
		 * @param geom The geometry object receives new fields, as described in the class 
		 * description. 
		 */
		virtual	void CalculateTangents( spGeometryData geom ) = 0;

		/**
		 * Calculates the tangents of a tree of scene nodes (only the geometry nodes of 
		 * course). 
		 * @param node Is the scene node that will have itselfs and its childrens tangents 
		 * calculated. 
		 */
		virtual	void CalculateTangentsForNodeHierarchy( spSceneNode node ) = 0;

		/**
		 * The TexCoords field id to use for the tangent calculation. If set to -1, all 
		 * texture coordinates will get corresponding tangent fields. 
		 * @param value The desired texcoordset id. 
		 */
		virtual	void SetTexCoordsSetId( rid value ) = 0;

		/**
		 * The TexCoords field id to use for the tangent calculation. If set to -1, all 
		 * texture coordinates will get corresponding tangent fields. 
		 */
		virtual	rid GetTexCoordsSetId(  ) = 0;

		/**
		 * Sets/Gets the tangent calculator type, types listed in TangentSpaceMethod. 
		 * @param type The desired tangent calculator type. 
		 */
		virtual	void SetTangentCalculatorType( Simplygon::ETangentSpaceMethod type ) = 0;

		/**
		 * Sets/Gets the tangent calculator type, types listed in TangentSpaceMethod. 
		 *  
		 */
		virtual	Simplygon::ETangentSpaceMethod GetTangentCalculatorType(  ) = 0;

		/**
		 * Inverts the V component of the texcoords used for tangent calculation. This 
		 * essentially switches between right- and lefthanded, i.e. TangentCalculatorType 
		 * = OrthonormalRightHanded and InvertV = true generates equivalent tangents to 
		 *  TangentCalculatorType = OrthonormalLeftHanded. 
		 * @param value The desired value of InvertV. 
		 */
		virtual	void SetInvertV( bool value ) = 0;

		/**
		 * Inverts the V component of the texcoords used for tangent calculation. This 
		 * essentially switches between right- and lefthanded, i.e. TangentCalculatorType 
		 * = OrthonormalRightHanded and InvertV = true generates equivalent tangents to 
		 *  TangentCalculatorType = OrthonormalLeftHanded. 
		 */
		virtual	bool GetInvertV(  ) = 0;

	};

	/**
	 * Settings for handling unconnected parts and unwanted gaps in the geometry. It 
	 * consists of two parts, Welding and T-junction removal. Welding merges vertices 
	 * that are closer than a set distance from each other. T-junction removal finds 
	 * open edges that lies within a set distance from other open edges, but without 
	 * matching vertices. It then splits those triangles into smaller, matching triangles 
	 * and fuses them together. 
	 */
	class IRepairSettings : public ISettingsObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IRepairSettings is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IRepairSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IRepairSettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IRepairSettings pointer 
		 * @return a pointer to the IRepairSettings object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static IRepairSettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IRepairSettings") )
				return static_cast<IRepairSettings*>(ptr);
			return nullptr;
		}
		/**
		 * The T-Junction distance, below which, the T-Junctions will be welded. 
		 * @param value The value to which TJuncDist will be set. Value cannot be less 
		 * than 0. Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetTJuncDist( real value ) = 0;

		/**
		 * The T-Junction distance, below which, the T-Junctions will be welded. 
		 */
		virtual	real GetTJuncDist(  ) = 0;

		/**
		 * If set, t-junctions will be removed. If enabled, it also requires UseWelding 
		 * to be on. 
		 * @param value The bool to which UseTJunctionRemover will be set. 
		 */
		virtual	void SetUseTJunctionRemover( bool value ) = 0;

		/**
		 * If set, t-junctions will be removed. If enabled, it also requires UseWelding 
		 * to be on. 
		 */
		virtual	bool GetUseTJunctionRemover(  ) = 0;

		/**
		 * The welding distance below which the vertices will be welded. 
		 * @param value The value to which WeldDist will be set. Value cannot be less 
		 * than 0. Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetWeldDist( real value ) = 0;

		/**
		 * The welding distance below which the vertices will be welded. 
		 */
		virtual	real GetWeldDist(  ) = 0;

		/**
		 * If set, only vertices that are on the border (as reported by the VertexBorder 
		 * boolean field) are considered for the welding. 
		 * @param value The bool to which WeldOnlyBorderVertices will be set. 
		 */
		virtual	void SetWeldOnlyBorderVertices( bool value ) = 0;

		/**
		 * If set, only vertices that are on the border (as reported by the VertexBorder 
		 * boolean field) are considered for the welding. 
		 */
		virtual	bool GetWeldOnlyBorderVertices(  ) = 0;

		/**
		 * If set, only vertices that are within the same material are welded. Vertices 
		 * on material borders are locked. 
		 * @param value The bool to which WeldOnlyWithinMaterial will be set. 
		 */
		virtual	void SetWeldOnlyWithinMaterial( bool value ) = 0;

		/**
		 * If set, only vertices that are within the same material are welded. Vertices 
		 * on material borders are locked. 
		 */
		virtual	bool GetWeldOnlyWithinMaterial(  ) = 0;

		/**
		 * If set, only vertices that are within the same scene node are welded. 
		 * @param value The bool to which WeldOnlyWithinSceneNode will be set. 
		 */
		virtual	void SetWeldOnlyWithinSceneNode( bool value ) = 0;

		/**
		 * If set, only vertices that are within the same scene node are welded. 
		 */
		virtual	bool GetWeldOnlyWithinSceneNode(  ) = 0;

		/**
		 * If set, only vertices that belong to different scene nodes are considered for 
		 * the welding. Affects both welder and t-junction remover. 
		 * @param value The bool to which WeldOnlyBetweenSceneNode will be set. 
		 */
		virtual	void SetWeldOnlyBetweenSceneNodes( bool value ) = 0;

		/**
		 * If set, only vertices that belong to different scene nodes are considered for 
		 * the welding. Affects both welder and t-junction remover. 
		 */
		virtual	bool GetWeldOnlyBetweenSceneNodes(  ) = 0;

		/**
		 * If set, vertices within each others welding distance will be welded together. 
		 * @param value The bool to which UseWelding will be set. 
		 */
		virtual	void SetUseWelding( bool value ) = 0;

		/**
		 * If set, vertices within each others welding distance will be welded together. 
		 *  
		 */
		virtual	bool GetUseWelding(  ) = 0;

		/**
		 * The number of progressive passes. Minimum is 1, but higher numbers give a better 
		 * quality, at the expense of longer running time. 
		 * @param value The integer to which ProgressivePasses will be set. Value cannot 
		 * be less than 1. Value cannot be greater than 10. 
		 */
		virtual	void SetProgressivePasses( unsigned int value ) = 0;

		/**
		 * The number of progressive passes. Minimum is 1, but higher numbers give a better 
		 * quality, at the expense of longer running time. 
		 */
		virtual	unsigned int GetProgressivePasses(  ) = 0;

	};

	/**
	 * Settings for the Simplygon Reduction/Remeshing classes With the BoneSettings 
	 * object, the user can setup all the parameters for how the BoneLOD processor 
	 * should simplify the links between geometries and bones. Bones can be un-linked 
	 * from the geometry either with a set ratio or depending on a selected pixel size 
	 * on screen. 
	 */
	class IBoneSettings : public ISettingsObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IBoneSettings is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IBoneSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IBoneSettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IBoneSettings pointer 
		 * @return a pointer to the IBoneSettings object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static IBoneSettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IBoneSettings") )
				return static_cast<IBoneSettings*>(ptr);
			return nullptr;
		}
		/**
		 * Set bone reduction targets and stop condition used in the bone reduction. 
		 * @param stopCondition The value to which BoneReductionTargetStopCondition will 
		 * be set. 
		 * @param useBoneRatio The value to which BoneReductionTargetBoneRatioEnabled 
		 * will be set. 
		 * @param useBoneCount The value to which BoneReductionTargetBoneCountEnabled 
		 * will be set. 
		 * @param useMaxDeviation The value to which BoneReductionTargetMaxDeviationEnabled 
		 * will be set. 
		 * @param useOnScreenSize The value to which BoneReductionTargetOnScreenSizeEnabled 
		 * will be set. 
		 */
		virtual	void SetBoneReductionTargets( Simplygon::EStopCondition stopCondition , bool useBoneRatio , bool useBoneCount , bool useMaxDeviation , bool useOnScreenSize ) = 0;

		/**
		 * Enable bone ratio as a reduction target. The reducer will stop when the set 
		 * bone-ratio has been reached. 
		 * @param value The desired value of BoneRatioEnabled. 
		 */
		virtual	void SetBoneReductionTargetBoneRatioEnabled( bool value ) = 0;

		/**
		 * Enable bone ratio as a reduction target. The reducer will stop when the set 
		 * bone-ratio has been reached. 
		 */
		virtual	bool GetBoneReductionTargetBoneRatioEnabled(  ) = 0;

		/**
		 * Enable bone count as a reduction target. The reducer will stop when the set 
		 * bone count has been reached. 
		 * @param value The desired value of BoneCountEnabled. 
		 */
		virtual	void SetBoneReductionTargetBoneCountEnabled( bool value ) = 0;

		/**
		 * Enable bone count as a reduction target. The reducer will stop when the set 
		 * bone count has been reached. 
		 */
		virtual	bool GetBoneReductionTargetBoneCountEnabled(  ) = 0;

		/**
		 * Enable max deviation as a reduction target. The reducer will stop when the 
		 * set max deviation has been reached. 
		 * @param value The desired value of MaxDeviationEnabled. 
		 */
		virtual	void SetBoneReductionTargetMaxDeviationEnabled( bool value ) = 0;

		/**
		 * Enable max deviation as a reduction target. The reducer will stop when the 
		 * set max deviation has been reached. 
		 */
		virtual	bool GetBoneReductionTargetMaxDeviationEnabled(  ) = 0;

		/**
		 * Enable on screen size as a reduction target. The reducer will stop when the 
		 * set on screen size has been reached. 
		 * @param value Value to set if on screen size should be used in the reduction. 
		 *  
		 */
		virtual	void SetBoneReductionTargetOnScreenSizeEnabled( bool value ) = 0;

		/**
		 * Enable on screen size as a reduction target. The reducer will stop when the 
		 * set on screen size has been reached. 
		 */
		virtual	bool GetBoneReductionTargetOnScreenSizeEnabled(  ) = 0;

		/**
		 * The stop condition for the bone reducer. Any: the reducer will stop when any 
		 * single one of the set reduction targets have been reached. All: the reducer 
		 * will stop when all enabled reduction targets have been set. 
		 * @param value The flag to which StopCondition will be set. 
		 */
		virtual	void SetBoneReductionTargetStopCondition( Simplygon::EStopCondition value ) = 0;

		/**
		 * The stop condition for the bone reducer. Any: the reducer will stop when any 
		 * single one of the set reduction targets have been reached. All: the reducer 
		 * will stop when all enabled reduction targets have been set. 
		 */
		virtual	Simplygon::EStopCondition GetBoneReductionTargetStopCondition(  ) = 0;

		/**
		 * The desired bone reduction ratio. The range is 0->1. 
		 * @param value The value to which ReductionRatio will be set. Value cannot be 
		 * less than 0. Value cannot be greater than 1. 
		 */
		virtual	void SetBoneReductionTargetBoneRatio( real value ) = 0;

		/**
		 * The desired bone reduction ratio. The range is 0->1. 
		 */
		virtual	real GetBoneReductionTargetBoneRatio(  ) = 0;

		/**
		 * The desired bone count. The range is 0->inf. 
		 * @param value The value to which BoneCount will be set. Value cannot be less 
		 * than 0. Value cannot be greater than UINT_MAX. 
		 */
		virtual	void SetBoneReductionTargetBoneCount( unsigned int value ) = 0;

		/**
		 * The desired bone count. The range is 0->inf. 
		 */
		virtual	unsigned int GetBoneReductionTargetBoneCount(  ) = 0;

		/**
		 * The MaxDeviation value, the maximum surface-deviation between the reduced geometry 
		 * and the original. 
		 * @param value The value to which MaxDeviation will be set. Value cannot be less 
		 * than 0. Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetBoneReductionTargetMaxDeviation( real value ) = 0;

		/**
		 * The MaxDeviation value, the maximum surface-deviation between the reduced geometry 
		 * and the original. 
		 */
		virtual	real GetBoneReductionTargetMaxDeviation(  ) = 0;

		/**
		 * The OnScreenSize value, the maximum surface-deviation between the reduced geometry 
		 * and the original. 
		 * @param value The value to which OnScreenSize will be set. Value cannot be less 
		 * than 20. Value cannot be greater than 4000. 
		 */
		virtual	void SetBoneReductionTargetOnScreenSize( unsigned int value ) = 0;

		/**
		 * The OnScreenSize value, the maximum surface-deviation between the reduced geometry 
		 * and the original. 
		 */
		virtual	unsigned int GetBoneReductionTargetOnScreenSize(  ) = 0;

		/**
		 * Decides the maximum limit of how many bones can be connected to each vertex. 
		 * If for example set to 1, then each vertex will only be linked to 1 bone. 
		 * @param value The desired maximum bones per vertex. Value cannot be less than 
		 * 0. Value cannot be greater than UINT_MAX. 
		 */
		virtual	void SetMaxBonePerVertex( unsigned int value ) = 0;

		/**
		 * Decides the maximum limit of how many bones can be connected to each vertex. 
		 * If for example set to 1, then each vertex will only be linked to 1 bone. 
		 */
		virtual	unsigned int GetMaxBonePerVertex(  ) = 0;

		/**
		 * Decides whether unused bones should be removed. 
		 * @param value The desired flag value. 
		 */
		virtual	void SetRemoveUnusedBones( bool value ) = 0;

		/**
		 * Decides whether unused bones should be removed. 
		 */
		virtual	bool GetRemoveUnusedBones(  ) = 0;

		/**
		 * Decides whether unused bones should be removed. 
		 * @param value The desired flag value. 
		 */
		virtual	void SetLimitBonesPerVertex( bool value ) = 0;

		/**
		 * Decides whether unused bones should be removed. 
		 */
		virtual	bool GetLimitBonesPerVertex(  ) = 0;

		/**
		 * Enables or disables the bone reduction processing that actually removes bones. 
		 * Even with this flag off, the bones per vertex can still be limited. 
		 * @param value The desired flag value. 
		 */
		virtual	void SetUseBoneReducer( bool value ) = 0;

		/**
		 * Enables or disables the bone reduction processing that actually removes bones. 
		 * Even with this flag off, the bones per vertex can still be limited. 
		 */
		virtual	bool GetUseBoneReducer(  ) = 0;

		/**
		 * The ID of the selection set that contains all of the bones that will be locked, 
		 * and cannot be removed in the BoneLOD process. If a bone is locked, all its 
		 * ancestors will be locked also. If the ID is -1, then no bones are selected. 
		 * @param value The ID of the selection set. Value cannot be less than -1. 
		 */
		virtual	void SetLockBoneSelectionSetID( rid value ) = 0;

		/**
		 * The ID of the selection set that contains all of the bones that will be locked, 
		 * and cannot be removed in the BoneLOD process. If a bone is locked, all its 
		 * ancestors will be locked also. If the ID is -1, then no bones are selected. 
		 *  
		 */
		virtual	rid GetLockBoneSelectionSetID(  ) = 0;

		/**
		 * The name of the selection set that contains all of the bones that will be locked, 
		 * and cannot be removed in the BoneLOD process. If a bone is locked, all its 
		 * ancestors will be locked also. If both name and id are set for the locked selection 
		 * set, the name will be used. 
		 * @param value The name of the selection set. 
		 */
		virtual	void SetLockBoneSelectionSetName( const char * value ) = 0;

		/**
		 * The name of the selection set that contains all of the bones that will be locked, 
		 * and cannot be removed in the BoneLOD process. If a bone is locked, all its 
		 * ancestors will be locked also. If both name and id are set for the locked selection 
		 * set, the name will be used. 
		 */
		virtual	spString GetLockBoneSelectionSetName(  ) = 0;

		/**
		 * The ID of the selection set that contains all of the bones that will be forced 
		 * to be removed in the BoneLOD process, UNLESS they are locked. If a bone is 
		 * set to be removed, all its descendants will be removed also. If both name and 
		 * id are set for the remove selection set, the name will be used. 
		 * @param value The ID of the selection set. Value cannot be less than -1. 
		 */
		virtual	void SetRemoveBoneSelectionSetID( rid value ) = 0;

		/**
		 * The ID of the selection set that contains all of the bones that will be forced 
		 * to be removed in the BoneLOD process, UNLESS they are locked. If a bone is 
		 * set to be removed, all its descendants will be removed also. If both name and 
		 * id are set for the remove selection set, the name will be used. 
		 */
		virtual	rid GetRemoveBoneSelectionSetID(  ) = 0;

		/**
		 * The name of the selection set that contains all of the bones that will be forced 
		 * to be removed in the BoneLOD process, UNLESS they are locked. If a bone is 
		 * set to be removed, all its descendants will be removed also. If both name and 
		 * id are set for the remove selection set, the name will be used. 
		 * @param value The name of the selection set. 
		 */
		virtual	void SetRemoveBoneSelectionSetName( const char * value ) = 0;

		/**
		 * The name of the selection set that contains all of the bones that will be forced 
		 * to be removed in the BoneLOD process, UNLESS they are locked. If a bone is 
		 * set to be removed, all its descendants will be removed also. If both name and 
		 * id are set for the remove selection set, the name will be used. 
		 */
		virtual	spString GetRemoveBoneSelectionSetName(  ) = 0;

	};

	/**
	 * Settings for the ReductionProcessor class. Handles all the settings for Simplygons 
	 * simplification algorithms. The user can tell the reduction processor which features 
	 * are important by using the 'FeatureFlags' parameter, and also the relative importance 
	 * of these features using the Set{feature}Importance methods. Also settings for 
	 * things like symmetry are set here. 
	 */
	class IReductionSettings : public ISettingsObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IReductionSettings is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IReductionSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IReductionSettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IReductionSettings pointer 
		 * @return a pointer to the IReductionSettings object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IReductionSettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IReductionSettings") )
				return static_cast<IReductionSettings*>(ptr);
			return nullptr;
		}
		/**
		 * Set reduction targets and stop condition used in the reduction. 
		 * @param stopCondition The value to which ReductionTargetStopCondition will be 
		 * set. 
		 * @param useTriangleRatio The value to which ReductionTargetTriangleRatioEnabled 
		 * will be set. 
		 * @param useTriangleCount The value to which ReductionTargetTriangleCountEnabled 
		 * will be set. 
		 * @param useMaxDeviation The value to which ReductionTargetMaxDeviationEnabled 
		 * will be set. 
		 * @param useOnScreenSize The value to which ReductionTargetOnScreenSizeEnabled 
		 * will be set. 
		 */
		virtual	void SetReductionTargets( Simplygon::EStopCondition stopCondition , bool useTriangleRatio , bool useTriangleCount , bool useMaxDeviation , bool useOnScreenSize ) = 0;

		/**
		 * Enable triangle ratio as a reduction target. The reducer will stop when the 
		 * set triangle-ratio has been reached. 
		 * @param value Value to set if triangle ratio should be used in the reduction. 
		 *  
		 */
		virtual	void SetReductionTargetTriangleRatioEnabled( bool value ) = 0;

		/**
		 * Enable triangle ratio as a reduction target. The reducer will stop when the 
		 * set triangle-ratio has been reached. 
		 */
		virtual	bool GetReductionTargetTriangleRatioEnabled(  ) = 0;

		/**
		 * Enable triangle count as a reduction target. The reducer will stop when the 
		 * set triangle count has been reached. 
		 * @param value Value to set if triangle count should be used in the reduction. 
		 *  
		 */
		virtual	void SetReductionTargetTriangleCountEnabled( bool value ) = 0;

		/**
		 * Enable triangle count as a reduction target. The reducer will stop when the 
		 * set triangle count has been reached. 
		 */
		virtual	bool GetReductionTargetTriangleCountEnabled(  ) = 0;

		/**
		 * Enable max deviation as a reduction target. The reducer will stop when the 
		 * set max deviation has been reached. 
		 * @param value Value to set if max deviation should be used in the reduction. 
		 *  
		 */
		virtual	void SetReductionTargetMaxDeviationEnabled( bool value ) = 0;

		/**
		 * Enable max deviation as a reduction target. The reducer will stop when the 
		 * set max deviation has been reached. 
		 */
		virtual	bool GetReductionTargetMaxDeviationEnabled(  ) = 0;

		/**
		 * Enable on screen size as a reduction target. The reducer will stop when the 
		 * set on screen size has been reached. 
		 * @param value Value to set if on screen size should be used in the reduction. 
		 *  
		 */
		virtual	void SetReductionTargetOnScreenSizeEnabled( bool value ) = 0;

		/**
		 * Enable on screen size as a reduction target. The reducer will stop when the 
		 * set on screen size has been reached. 
		 */
		virtual	bool GetReductionTargetOnScreenSizeEnabled(  ) = 0;

		/**
		 * The stop condition for the reducer. Any -> the reducer will stop when any single 
		 * one of the set reduction targets have been reached. All -> the reducer will 
		 * stop when all enabled reduction targets have been set. 
		 * @param value The flag to which StopCondition will be set. 
		 */
		virtual	void SetReductionTargetStopCondition( Simplygon::EStopCondition value ) = 0;

		/**
		 * The stop condition for the reducer. Any -> the reducer will stop when any single 
		 * one of the set reduction targets have been reached. All -> the reducer will 
		 * stop when all enabled reduction targets have been set. 
		 */
		virtual	Simplygon::EStopCondition GetReductionTargetStopCondition(  ) = 0;

		/**
		 * The flag that decides how precise the reducer will be during the mesh reduction. 
		 * Fast -> Reducer will be faster, but onscreensize and trianglecount will not 
		 * match perfectly. Consistent -> Reducer will be slower, but onscreensize and 
		 * trianglecount will consistently give matching results. 
		 * @param value The ReductionHeuristics to use. 
		 * @return The current value of ReductionHeuristics. 
		 */
		virtual	void SetReductionHeuristics( Simplygon::EReductionHeuristics value ) = 0;

		/**
		 * The flag that decides how precise the reducer will be during the mesh reduction. 
		 * Fast -> Reducer will be faster, but onscreensize and trianglecount will not 
		 * match perfectly. Consistent -> Reducer will be slower, but onscreensize and 
		 * trianglecount will consistently give matching results. 
		 * @return The current value of ReductionHeuristics. Default value is Fast 
		 */
		virtual	Simplygon::EReductionHeuristics GetReductionHeuristics(  ) = 0;

		/**
		 * The wanted reduction ratio. The range is 0->1. 
		 * @param value The value to which ReductionRatio will be set. Value cannot be 
		 * less than 0. Value cannot be greater than 1. 
		 */
		virtual	void SetReductionTargetTriangleRatio( real value ) = 0;

		/**
		 * The wanted reduction ratio. The range is 0->1. 
		 */
		virtual	real GetReductionTargetTriangleRatio(  ) = 0;

		/**
		 * The wanted triangle count. The range is 0->inf. 
		 * @param value The value to which TriangleCount will be set. Value cannot be 
		 * less than 0. Value cannot be greater than UINT_MAX. 
		 */
		virtual	void SetReductionTargetTriangleCount( unsigned int value ) = 0;

		/**
		 * The wanted triangle count. The range is 0->inf. 
		 */
		virtual	unsigned int GetReductionTargetTriangleCount(  ) = 0;

		/**
		 * The MaxDeviation value, the maximum surface-deviation between the reduced geometry 
		 * and the original. 
		 * @param value The value to which MaxDeviation will be set. Value cannot be less 
		 * than 0. Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetReductionTargetMaxDeviation( real value ) = 0;

		/**
		 * The MaxDeviation value, the maximum surface-deviation between the reduced geometry 
		 * and the original. 
		 */
		virtual	real GetReductionTargetMaxDeviation(  ) = 0;

		/**
		 * The OnScreenSize value, used to calculate the maximum surface-deviation allowed, 
		 * by assuming errors less than 1 pixel onscreen will not be noticable. 
		 * @param value The value to which OnScreenSize will be set. Value cannot be less 
		 * than 20. Value cannot be greater than 100000. 
		 */
		virtual	void SetReductionTargetOnScreenSize( unsigned int value ) = 0;

		/**
		 * The OnScreenSize value, used to calculate the maximum surface-deviation allowed, 
		 * by assuming errors less than 1 pixel onscreen will not be noticable. 
		 */
		virtual	unsigned int GetReductionTargetOnScreenSize(  ) = 0;

		/**
		 * The importance value of the position of the vertices and triangles of the Geometry, 
		 * or the silhouette of the Geometry. The importance is relative to the values 
		 * of the other mesh features (or disabling an importance entirely by setting 
		 * it to 0). A higher number means higher importance. Default is 1.0 
		 * @param value The value to which the importance will be set. Value cannot be 
		 * less than 0. Value cannot be greater than SG_MAXIMUM_IMPORTANCE_VALUE. 
		 */
		virtual	void SetGeometryImportance( real value ) = 0;

		/**
		 * The importance value of the position of the vertices and triangles of the Geometry, 
		 * or the silhouette of the Geometry. The importance is relative to the values 
		 * of the other mesh features (or disabling an importance entirely by setting 
		 * it to 0). A higher number means higher importance. Default is 1.0 
		 */
		virtual	real GetGeometryImportance(  ) = 0;

		/**
		 * The importance value of the boundary between triangles with different materials. 
		 * For example, if triangles with a metallic material are connected to triangles 
		 * with a wood material, this setting will determine how important it is to keep 
		 * the border between them intact. The importance is relative to the values of 
		 * the other mesh features (or disabling an importance entirely by setting it 
		 * to 0). A higher number means higher importance. Default is 1.0 
		 * @param value The value to which the importance will be set. Value cannot be 
		 * less than 0. Value cannot be greater than SG_MAXIMUM_IMPORTANCE_VALUE. 
		 */
		virtual	void SetMaterialImportance( real value ) = 0;

		/**
		 * The importance value of the boundary between triangles with different materials. 
		 * For example, if triangles with a metallic material are connected to triangles 
		 * with a wood material, this setting will determine how important it is to keep 
		 * the border between them intact. The importance is relative to the values of 
		 * the other mesh features (or disabling an importance entirely by setting it 
		 * to 0). A higher number means higher importance. Default is 1.0 
		 */
		virtual	real GetMaterialImportance(  ) = 0;

		/**
		 * The importance value of the UV coordinates of the Geometry, both the boundary 
		 * of the UV charts, as well as the UV stretch across the triangles. The importance 
		 * is relative to the values of the other mesh features (or disabling an importance 
		 * entirely by setting it to 0). A higher number means higher importance. Default 
		 * is 1.0 
		 * @param value The value to which the importance will be set. Value cannot be 
		 * less than 0. Value cannot be greater than SG_MAXIMUM_IMPORTANCE_VALUE. 
		 */
		virtual	void SetTextureImportance( real value ) = 0;

		/**
		 * The importance value of the UV coordinates of the Geometry, both the boundary 
		 * of the UV charts, as well as the UV stretch across the triangles. The importance 
		 * is relative to the values of the other mesh features (or disabling an importance 
		 * entirely by setting it to 0). A higher number means higher importance. Default 
		 * is 1.0 
		 */
		virtual	real GetTextureImportance(  ) = 0;

		/**
		 * The importance value of the vertex-normals of the Geometry, both the sharp 
		 * edges, as well as how the normals interpolate over the surface of the triangles. 
		 * The importance is relative to the values of the other mesh features (or disabling 
		 * an importance entirely by setting it to 0). A higher number means higher importance. 
		 * Default is 1.0 
		 * @param value The value to which the importance will be set. Value cannot be 
		 * less than 0. Value cannot be greater than SG_MAXIMUM_IMPORTANCE_VALUE. 
		 */
		virtual	void SetShadingImportance( real value ) = 0;

		/**
		 * The importance value of the vertex-normals of the Geometry, both the sharp 
		 * edges, as well as how the normals interpolate over the surface of the triangles. 
		 * The importance is relative to the values of the other mesh features (or disabling 
		 * an importance entirely by setting it to 0). A higher number means higher importance. 
		 * Default is 1.0 
		 */
		virtual	real GetShadingImportance(  ) = 0;

		/**
		 * The importance value of the boundary between triangles from different sub-geometries. 
		 * The importance is relative to the values of the other mesh features (or disabling 
		 * an importance entirely by setting it to 0). A higher number means higher importance. 
		 * Default is 1.0 
		 * @param value The value to which the importance will be set. Value cannot be 
		 * less than 0. Value cannot be greater than SG_MAXIMUM_IMPORTANCE_VALUE. 
		 */
		virtual	void SetGroupImportance( real value ) = 0;

		/**
		 * The importance value of the boundary between triangles from different sub-geometries. 
		 * The importance is relative to the values of the other mesh features (or disabling 
		 * an importance entirely by setting it to 0). A higher number means higher importance. 
		 * Default is 1.0 
		 */
		virtual	real GetGroupImportance(  ) = 0;

		/**
		 * The importance value of the vertex-colors of the Geometry, both the boundary 
		 * between triangles with different colors, as well as how the colors interpolate 
		 * over the surface of the triangles. The importance is relative to the values 
		 * of the other mesh features (or disabling an importance entirely by setting 
		 * it to 0). A higher number means higher importance. Default is 1.0 
		 * @param value The value to which the importance will be set. Value cannot be 
		 * less than 0. Value cannot be greater than SG_MAXIMUM_IMPORTANCE_VALUE. 
		 */
		virtual	void SetVertexColorImportance( real value ) = 0;

		/**
		 * The importance value of the vertex-colors of the Geometry, both the boundary 
		 * between triangles with different colors, as well as how the colors interpolate 
		 * over the surface of the triangles. The importance is relative to the values 
		 * of the other mesh features (or disabling an importance entirely by setting 
		 * it to 0). A higher number means higher importance. Default is 1.0 
		 */
		virtual	real GetVertexColorImportance(  ) = 0;

		/**
		 * The importance value of user selected edges. Can be used when a Boolean UserCornerField 
		 * with the name SgEdgeSelectionSet is added to the Geometry. The importance is 
		 * relative to the values of the other mesh features (or disabling an importance 
		 * entirely by setting it to 0). A higher number means higher importance. Default 
		 * is 1.0 
		 * @param value The value to which the importance will be set. Value cannot be 
		 * less than 0. Value cannot be greater than SG_MAXIMUM_IMPORTANCE_VALUE. 
		 */
		virtual	void SetEdgeSetImportance( real value ) = 0;

		/**
		 * The importance value of user selected edges. Can be used when a Boolean UserCornerField 
		 * with the name SgEdgeSelectionSet is added to the Geometry. The importance is 
		 * relative to the values of the other mesh features (or disabling an importance 
		 * entirely by setting it to 0). A higher number means higher importance. Default 
		 * is 1.0 
		 */
		virtual	real GetEdgeSetImportance(  ) = 0;

		/**
		 * The importance value of the bone-weights of the vertices. The more impact a 
		 * vertex has on the skinning of the Geometry (for example, vertices close to 
		 * joints), the more likely it is to be kept. The importance is relative to the 
		 * values of the other mesh features (or disabling an importance entirely by setting 
		 * it to 0). A higher number means higher importance. Default is 1.0 
		 * @param value The value to which the importance will be set. Value cannot be 
		 * less than 0. Value cannot be greater than SG_MAXIMUM_IMPORTANCE_VALUE. 
		 */
		virtual	void SetSkinningImportance( real value ) = 0;

		/**
		 * The importance value of the bone-weights of the vertices. The more impact a 
		 * vertex has on the skinning of the Geometry (for example, vertices close to 
		 * joints), the more likely it is to be kept. The importance is relative to the 
		 * values of the other mesh features (or disabling an importance entirely by setting 
		 * it to 0). A higher number means higher importance. Default is 1.0 
		 */
		virtual	real GetSkinningImportance(  ) = 0;

		/**
		 * This importance is deprecated and disabled. 
		 * @param value The value to which the importance will be set. Value cannot be 
		 * less than 0. Value cannot be greater than SG_MAXIMUM_IMPORTANCE_VALUE. 
		 */
		virtual	void SetCurvatureImportance( real value ) = 0;

		/**
		 * This importance is deprecated and disabled. 
		 */
		virtual	real GetCurvatureImportance(  ) = 0;

		/**
		 * The CreateGeomorphGeometry value. If set, the reducer will create a GeometryData 
		 * object that is a morphed version of the original GeometryData, that can be 
		 * used to morph between the original geometry and the reduced geometry. Should 
		 * not be used together with TJunctionRemover, NormalRecalculation or Material 
		 * LOD. 
		 * @param value The bool to which CreateGeomorphGeometry will be set. 
		 */
		virtual	void SetCreateGeomorphGeometry( bool value ) = 0;

		/**
		 * The CreateGeomorphGeometry value. If set, the reducer will create a GeometryData 
		 * object that is a morphed version of the original GeometryData, that can be 
		 * used to morph between the original geometry and the reduced geometry. Should 
		 * not be used together with TJunctionRemover, NormalRecalculation or Material 
		 * LOD. 
		 */
		virtual	bool GetCreateGeomorphGeometry(  ) = 0;

		/**
		 * The AllowDegenerateTexCoords flag. If true, texture coordinates are allowed 
		 * to become degenerate (triangles can have 0 area in texture space). This may 
		 * sometimes look better, but if tangent space normals are used, tangent spaces 
		 * may become degenerate. 
		 * @param value The bool to which AllowDegenerateTexCoords will be set. 
		 */
		virtual	void SetAllowDegenerateTexCoords( bool value ) = 0;

		/**
		 * The AllowDegenerateTexCoords flag. If true, texture coordinates are allowed 
		 * to become degenerate (triangles can have 0 area in texture space). This may 
		 * sometimes look better, but if tangent space normals are used, tangent spaces 
		 * may become degenerate. 
		 */
		virtual	bool GetAllowDegenerateTexCoords(  ) = 0;

		/**
		 * The KeepSymmetry flag. If set, the reducer will detect symmetric features, 
		 * and retain symmetry during processing. Please note that for a geometry to be 
		 * considered symmetrical, also the texture coordinates must be mirrored. 
		 * @param value The bool to which KeepSymmetry will be set. 
		 */
		virtual	void SetKeepSymmetry( bool value ) = 0;

		/**
		 * The KeepSymmetry flag. If set, the reducer will detect symmetric features, 
		 * and retain symmetry during processing. Please note that for a geometry to be 
		 * considered symmetrical, also the texture coordinates must be mirrored. 
		 */
		virtual	bool GetKeepSymmetry(  ) = 0;

		/**
		 * The AutomaticSymmetryDetection flag. If set, and KeepSymmetry is on, the reducer 
		 * will detect any X,Y,Z symmetry plane and will override any user set symmetry 
		 * plane with the detected one. If no symmetry is found, KeepSymmetry will be 
		 * turned off before reduction. 
		 * @param value The bool to which AutomaticSymmetryDetection will be set. 
		 */
		virtual	void SetUseAutomaticSymmetryDetection( bool value ) = 0;

		/**
		 * The AutomaticSymmetryDetection flag. If set, and KeepSymmetry is on, the reducer 
		 * will detect any X,Y,Z symmetry plane and will override any user set symmetry 
		 * plane with the detected one. If no symmetry is found, KeepSymmetry will be 
		 * turned off before reduction. 
		 */
		virtual	bool GetUseAutomaticSymmetryDetection(  ) = 0;

		/**
		 * The UseSymmetryQuadRetriangulator flag. If true, and KeepSymmetry is on, any 
		 * triangles that have been triangulated from symmetrical quads into unsymmetrical 
		 * triangles are detected and fixed. The edges of said triangles are flipped across 
		 * the old quad so that the mesh becomes symmetrical again. 
		 * @param value The bool to which UseSymmetryQuadRetriangulator will be set. 
		 */
		virtual	void SetUseSymmetryQuadRetriangulator( bool value ) = 0;

		/**
		 * The UseSymmetryQuadRetriangulator flag. If true, and KeepSymmetry is on, any 
		 * triangles that have been triangulated from symmetrical quads into unsymmetrical 
		 * triangles are detected and fixed. The edges of said triangles are flipped across 
		 * the old quad so that the mesh becomes symmetrical again. 
		 */
		virtual	bool GetUseSymmetryQuadRetriangulator(  ) = 0;

		/**
		 * Set what axis to be used for symmetry calculations. 
		 * @param value The value to which SymmetryAxis will be set. 
		 */
		virtual	void SetSymmetryAxis( Simplygon::ESymmetryAxis value ) = 0;

		/**
		 * Set what axis to be used for symmetry calculations. 
		 */
		virtual	Simplygon::ESymmetryAxis GetSymmetryAxis(  ) = 0;

		/**
		 * Set SymmetryOffset, the position on the symmetry axis where the symmetry plane 
		 * is placed. 
		 * @param value The value to which SymmetryOffset will be set. Value cannot be 
		 * less than 0. Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetSymmetryOffset( real value ) = 0;

		/**
		 * Set SymmetryOffset, the position on the symmetry axis where the symmetry plane 
		 * is placed. 
		 */
		virtual	real GetSymmetryOffset(  ) = 0;

		/**
		 * The tolerance used when detecting symmetry. Values in the ranges 1e-5 to 1e-3 
		 * will usually produce good results. This specific tolerance corresponds to the 
		 * off-plane tolerance, ie. the tolerance of the coordinate components that are 
		 * not the symmetry axis. The in-plane tolerance is always 10 times the off-plane 
		 * tolerance. This value is relative to the size of the Geometry, so 0.01 would 
		 * mean 1% of the bounding box size of the Geometry. 
		 * @param value The value to which SymmetryDetectionTolerance will be set. Value 
		 * cannot be less than 0. Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetSymmetryDetectionTolerance( real value ) = 0;

		/**
		 * The tolerance used when detecting symmetry. Values in the ranges 1e-5 to 1e-3 
		 * will usually produce good results. This specific tolerance corresponds to the 
		 * off-plane tolerance, ie. the tolerance of the coordinate components that are 
		 * not the symmetry axis. The in-plane tolerance is always 10 times the off-plane 
		 * tolerance. This value is relative to the size of the Geometry, so 0.01 would 
		 * mean 1% of the bounding box size of the Geometry. 
		 */
		virtual	real GetSymmetryDetectionTolerance(  ) = 0;

		/**
		 * The flag that specifies how big "freedom" Simplygon has when it comes to altering 
		 * vertex/triangle data. Allowing more altered data means it will be easier to 
		 * create good looking LODs, but without altered data it will be easier to keep 
		 * the memory-usage in the LOD-chain more optimized. Note: When using OnlyUseOriginalData, 
		 * the geometry being reduced can not have a node transformation matrix other 
		 * than the identity matrix. 
		 * @param value The value to which the DataCreationPreferences flag will be set. 
		 *  
		 */
		virtual	void SetDataCreationPreferences( Simplygon::EDataCreationPreferences value ) = 0;

		/**
		 * The flag that specifies how big "freedom" Simplygon has when it comes to altering 
		 * vertex/triangle data. Allowing more altered data means it will be easier to 
		 * create good looking LODs, but without altered data it will be easier to keep 
		 * the memory-usage in the LOD-chain more optimized. Note: When using OnlyUseOriginalData, 
		 * the geometry being reduced can not have a node transformation matrix other 
		 * than the identity matrix. 
		 */
		virtual	Simplygon::EDataCreationPreferences GetDataCreationPreferences(  ) = 0;

		/**
		 * The flag for if the reduction process should store geomorph data in the processed 
		 * GeometryData object. This data is an array with same size as the vertexcount 
		 * was before the reduction process, and will have the coordinates for each vertex 
		 * on its corresponding position on the reduced GeometryData surface. Can be used 
		 * to give smooth transition from a highlevel LOD to a lowlevel LOD. This array 
		 * can be accessed with the GeometryData custom field "SgMappedVertexCoords". 
		 * @param value The bool to which GenerateGeomorphData will be set. 
		 */
		virtual	void SetGenerateGeomorphData( bool value ) = 0;

		/**
		 * The flag for if the reduction process should store geomorph data in the processed 
		 * GeometryData object. This data is an array with same size as the vertexcount 
		 * was before the reduction process, and will have the coordinates for each vertex 
		 * on its corresponding position on the reduced GeometryData surface. Can be used 
		 * to give smooth transition from a highlevel LOD to a lowlevel LOD. This array 
		 * can be accessed with the GeometryData custom field "SgMappedVertexCoords". 
		 *  
		 */
		virtual	bool GetGenerateGeomorphData(  ) = 0;

		/**
		 * The outward move multiplier, how much the mesh is allowed to grow its silhouette 
		 * perimeter. 
		 * @param value The value to which OutwardMoveMultiplier will be set. Value cannot 
		 * be less than 0. Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetOutwardMoveMultiplier( real value ) = 0;

		/**
		 * The outward move multiplier, how much the mesh is allowed to grow its silhouette 
		 * perimeter. 
		 */
		virtual	real GetOutwardMoveMultiplier(  ) = 0;

		/**
		 * The inward move multiplier, how much the mesh is allowed to shrink its silhouette 
		 * perimeter. 
		 * @param value The value to which InwardMoveMultiplier will be set. Value cannot 
		 * be less than 0. Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetInwardMoveMultiplier( real value ) = 0;

		/**
		 * The inward move multiplier, how much the mesh is allowed to shrink its silhouette 
		 * perimeter. 
		 */
		virtual	real GetInwardMoveMultiplier(  ) = 0;

		/**
		 * The maximum length of the triangles edges after reduction. Can be used to limit 
		 * output triangle size. 
		 * @param value The new value of MaxEdgeLength. Value cannot be less than 0. Value 
		 * cannot be greater than REAL_MAX. 
		 */
		virtual	void SetMaxEdgeLength( real value ) = 0;

		/**
		 * The maximum length of the triangles edges after reduction. Can be used to limit 
		 * output triangle size. 
		 */
		virtual	real GetMaxEdgeLength(  ) = 0;

		/**
		 * Set to true and the reducer will do a much more precise way of calculating 
		 * the vertex normals. It will however be slower. Set to false and it will do 
		 * a much more rough estimation of what the vertex normals will look like, but 
		 * faster. 
		 * @param value The value to which UseHighQualityNormalCalculation will be set. 
		 *  
		 */
		virtual	void SetUseHighQualityNormalCalculation( bool value ) = 0;

		/**
		 * Set to true and the reducer will do a much more precise way of calculating 
		 * the vertex normals. It will however be slower. Set to false and it will do 
		 * a much more rough estimation of what the vertex normals will look like, but 
		 * faster. 
		 */
		virtual	bool GetUseHighQualityNormalCalculation(  ) = 0;

		/**
		 * Which selection set should be processed. If set to -1, all geometries in the 
		 * scene will be processed. If both selection set name and ID are set, the name 
		 * will be used. 
		 * @param value The desired SelectionSet id. Value cannot be less than -1. 
		 */
		virtual	void SetProcessSelectionSetID( rid value ) = 0;

		/**
		 * Which selection set should be processed. If set to -1, all geometries in the 
		 * scene will be processed. If both selection set name and ID are set, the name 
		 * will be used. 
		 */
		virtual	rid GetProcessSelectionSetID(  ) = 0;

		/**
		 * Which selection set should be processed. If the name is not found, all geometries 
		 * in the scene will be processed. If both selection set name and ID are set, 
		 * the name will be used. 
		 * @param value The desired SelectionSet name. 
		 */
		virtual	void SetProcessSelectionSetName( const char * value ) = 0;

		/**
		 * Which selection set should be processed. If the name is not found, all geometries 
		 * in the scene will be processed. If both selection set name and ID are set, 
		 * the name will be used. 
		 */
		virtual	spString GetProcessSelectionSetName(  ) = 0;

		/**
		 * The processor will merge all the geometries in the scene into a single geometry 
		 * if MergeGeometries is enabled. 
		 * @param value The desired MergeGeometries flag. 
		 */
		virtual	void SetMergeGeometries( bool value ) = 0;

		/**
		 * The processor will merge all the geometries in the scene into a single geometry 
		 * if MergeGeometries is enabled. 
		 */
		virtual	bool GetMergeGeometries(  ) = 0;

		/**
		 * If false, the processor will remove all geometry and scene meshes which were 
		 * not selected for processing from the scene. If true, only the geometry in the 
		 * ProcessSelectionSet will be replaced or updated, while the rest of the scene 
		 * tree is kept intact. New geometry is always added as the last child of the 
		 * scene root. If generating a mappingimage to cast materials, new materialIds 
		 * will also be appended to the end of the old material table instead of replacing 
		 * the old ones. 
		 * @param value The desired KeepUnprocessedSceneMeshes flag. 
		 */
		virtual	void SetKeepUnprocessedSceneMeshes( bool value ) = 0;

		/**
		 * If false, the processor will remove all geometry and scene meshes which were 
		 * not selected for processing from the scene. If true, only the geometry in the 
		 * ProcessSelectionSet will be replaced or updated, while the rest of the scene 
		 * tree is kept intact. New geometry is always added as the last child of the 
		 * scene root. If generating a mappingimage to cast materials, new materialIds 
		 * will also be appended to the end of the old material table instead of replacing 
		 * the old ones. 
		 */
		virtual	bool GetKeepUnprocessedSceneMeshes(  ) = 0;

		/**
		 * If set, will lock the geometric border of the geometry, and not reduce at all. 
		 * This setting might be useful if the geometry needs to fit a neighbor geometry, 
		 * but will reduce overall reduction quality (geometric quality over reduction 
		 * ratio) 
		 * @param value The desired LockGeometricBorder flag. 
		 */
		virtual	void SetLockGeometricBorder( bool value ) = 0;

		/**
		 * If set, will lock the geometric border of the geometry, and not reduce at all. 
		 * This setting might be useful if the geometry needs to fit a neighbor geometry, 
		 * but will reduce overall reduction quality (geometric quality over reduction 
		 * ratio) 
		 */
		virtual	bool GetLockGeometricBorder(  ) = 0;

	};

	/**
	 * Settings for the normal recalculation 
	 */
	class INormalCalculationSettings : public ISettingsObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if INormalCalculationSettings is a or is 
		 * a descendant of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("INormalCalculationSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a INormalCalculationSettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a INormalCalculationSettings pointer 
		 * @return a pointer to the INormalCalculationSettings object, if the cast can 
		 * be made, and a NULL pointer otherwise 
		 */

		static INormalCalculationSettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("INormalCalculationSettings") )
				return static_cast<INormalCalculationSettings*>(ptr);
			return nullptr;
		}
		/**
		 * If set, it will generate new normals for the Geometry, and if not set, it will 
		 * keep the normals from the original normal set (or not add normals at all if 
		 * none were present). Please note that if the original geometry contains normals, 
		 * the normal repairer will replace invalid normals even if ReplaceNormals is 
		 * set to false. 
		 * @param value The value to which the ReplaceNormals bool is to be set. 
		 */
		virtual	void SetReplaceNormals( bool value ) = 0;

		/**
		 * If set, it will generate new normals for the Geometry, and if not set, it will 
		 * keep the normals from the original normal set (or not add normals at all if 
		 * none were present). Please note that if the original geometry contains normals, 
		 * the normal repairer will replace invalid normals even if ReplaceNormals is 
		 * set to false. 
		 */
		virtual	bool GetReplaceNormals(  ) = 0;

		/**
		 * If set, it will generate new tangents and bitangents for the Geometry, and 
		 * if not set, it will keep the new tangents and bitangents from the original 
		 * normal set (or not add tangents and bitangents at all if none were present). 
		 * @param value The value to which the ReplaceTangents bool is to be set. 
		 */
		virtual	void SetReplaceTangents( bool value ) = 0;

		/**
		 * If set, it will generate new tangents and bitangents for the Geometry, and 
		 * if not set, it will keep the new tangents and bitangents from the original 
		 * normal set (or not add tangents and bitangents at all if none were present). 
		 *  
		 */
		virtual	bool GetReplaceTangents(  ) = 0;

		/**
		 * Set HardEdgeAngle in degrees. If the angle between two triangles are above 
		 * this value, the normals will not be smooth over the edge between those two 
		 * triangles. 
		 * @param value The value to which HardEdgeAngle is to be set. Value cannot be 
		 * less than 0. Value cannot be greater than 180. 
		 */
		virtual	void SetHardEdgeAngle( real value ) = 0;

		/**
		 * Set HardEdgeAngle in degrees. If the angle between two triangles are above 
		 * this value, the normals will not be smooth over the edge between those two 
		 * triangles. 
		 */
		virtual	real GetHardEdgeAngle(  ) = 0;

		/**
		 * If set, normals that are invalid will be replaced. All others are left intact. 
		 * Bad normals are those that are either zero length, or simply points away from 
		 * the surface. 
		 * @param value The value to which RepairInvalidNormals is to be set. 
		 */
		virtual	void SetRepairInvalidNormals( bool value ) = 0;

		/**
		 * If set, normals that are invalid will be replaced. All others are left intact. 
		 * Bad normals are those that are either zero length, or simply points away from 
		 * the surface. 
		 */
		virtual	bool GetRepairInvalidNormals(  ) = 0;

		/**
		 * If set, the tangentspaces already existing in the scene will be readjusted 
		 * so that the tangent and binormal are both orthogonal to the normal. Will be 
		 * needed since most of the time the normals are changed in the reduction process. 
		 * @param value The desired flag value to reorthogonalize tangent space. 
		 */
		virtual	void SetReorthogonalizeTangentSpace( bool value ) = 0;

		/**
		 * If set, the tangentspaces already existing in the scene will be readjusted 
		 * so that the tangent and binormal are both orthogonal to the normal. Will be 
		 * needed since most of the time the normals are changed in the reduction process. 
		 *  
		 */
		virtual	bool GetReorthogonalizeTangentSpace(  ) = 0;

		/**
		 * If set, the influence of a triangle normal upon the vertex normals is scaled 
		 * by the area of the triangle. 
		 * @param value The value to which the ScaleByArea bool is to be set. 
		 */
		virtual	void SetScaleByArea( bool value ) = 0;

		/**
		 * If set, the influence of a triangle normal upon the vertex normals is scaled 
		 * by the area of the triangle. 
		 */
		virtual	bool GetScaleByArea(  ) = 0;

		/**
		 * If set, the influence of a triangle normal upon the vertex normals is scaled 
		 * by the angle of the corner at the vertex. 
		 * @param value The value to which the ScaleByAngle bool is to be set. 
		 */
		virtual	void SetScaleByAngle( bool value ) = 0;

		/**
		 * If set, the influence of a triangle normal upon the vertex normals is scaled 
		 * by the angle of the corner at the vertex. 
		 */
		virtual	bool GetScaleByAngle(  ) = 0;

		/**
		 * If set, perfectly flat shaded surfaces will be created, where possible. Normals 
		 * adjacent to perfectly geometrically flat surfaces will be recalculated to have 
		 * the same direction as for those of the adjacent flat surface. 
		 * @param value To use for SnapNormalsToFlatSurfaces. 
		 */
		virtual	void SetSnapNormalsToFlatSurfaces( bool value ) = 0;

		/**
		 * If set, perfectly flat shaded surfaces will be created, where possible. Normals 
		 * adjacent to perfectly geometrically flat surfaces will be recalculated to have 
		 * the same direction as for those of the adjacent flat surface. 
		 */
		virtual	bool GetSnapNormalsToFlatSurfaces(  ) = 0;

	};
	class IMappingImageInputMaterialSettings;
	class IMappingImageOutputMaterialSettings;
	class IChartAggregatorSettings;
	class IParameterizerSettings;

	/**
	 * Settings for the Simplygon mapping classes These settings control the properties 
	 * of the mapping image that will be generated in the current simplification processor 
	 * (reducer/remesher etc). The mapping image will be used when casting a new texture 
	 * on the simplified geometry. In the settings object, the user is able to set 
	 * the dimensions of the image (width/height) as well as whether the LOD should 
	 * have new texture coordinates and some parameters for how they should be generated 
	 * and all other settings regarding the mapping image. 
	 */
	class IMappingImageSettings : public ISettingsObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IMappingImageSettings is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IMappingImageSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IMappingImageSettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IMappingImageSettings pointer 
		 * @return a pointer to the IMappingImageSettings object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IMappingImageSettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IMappingImageSettings") )
				return static_cast<IMappingImageSettings*>(ptr);
			return nullptr;
		}
		/**
		 * The number of input materials used in the original geometry for mapping to 
		 * multiple output materials. This needs to be set before you can set any specific 
		 * in-out material mapping. 0 signifies that no in-out material mapping is used, 
		 * ie. the process will produce one resulting mapping image. 
		 * @param value The number of inputs. Value cannot be less than 0. Value cannot 
		 * be greater than SG_MAXIMUM_MAPPING_IMAGE_INPUT_MATERIAL_COUNT. 
		 */
		virtual	void SetInputMaterialCount( unsigned int value ) = 0;

		/**
		 * The number of input materials used in the original geometry for mapping to 
		 * multiple output materials. This needs to be set before you can set any specific 
		 * in-out material mapping. 0 signifies that no in-out material mapping is used, 
		 * ie. the process will produce one resulting mapping image. 
		 */
		virtual	unsigned int GetInputMaterialCount(  ) = 0;

		/**
		 * Get the input material settings for the given index. 
		 * @param index Input index Value cannot be less than 0. Value cannot be greater 
		 * than SG_MAXIMUM_MAPPING_IMAGE_INPUT_MATERIAL_COUNT. 
		 */
		virtual	spMappingImageInputMaterialSettings GetInputMaterialSettings( unsigned int index ) = 0;

		/**
		 * The number of output mapping images that are to be generated. If this is set 
		 * to more than 1, the material mapping also needs to be set. 
		 * @param value The number of outputs. Value cannot be less than 1. Value cannot 
		 * be greater than SG_MAXIMUM_MAPPING_IMAGE_OUTPUT_MATERIAL_COUNT. 
		 */
		virtual	void SetOutputMaterialCount( unsigned int value ) = 0;

		/**
		 * The number of output mapping images that are to be generated. If this is set 
		 * to more than 1, the material mapping also needs to be set. 
		 */
		virtual	unsigned int GetOutputMaterialCount(  ) = 0;

		/**
		 * Get the output material settings for the given index. 
		 * @param index Output index Value cannot be less than 0. Value cannot be greater 
		 * than SG_MAXIMUM_MAPPING_IMAGE_INPUT_MATERIAL_COUNT. 
		 */
		virtual	spMappingImageOutputMaterialSettings GetOutputMaterialSettings( unsigned int index ) = 0;

		/**
		 * Whether to replace already existing mapping images in the scene. 
		 * @param value The new value. 
		 */
		virtual	void SetReplaceMappingImages( bool value ) = 0;

		/**
		 * Whether to replace already existing mapping images in the scene. 
		 */
		virtual	bool GetReplaceMappingImages(  ) = 0;

		/**
		 * The maximum number of layers in the mapping image. If a remeshed geometry has 
		 * a lot of transparent triangles, use a higher number to be able to find intersections 
		 * on the inside of parts of the geometry. This setting only has effect in the 
		 * remeshing, when running reduction the number of layers is always 1. 
		 * @param value The desired number of layers in the mapping image. Value cannot 
		 * be less than 0. Value cannot be greater than UINT_MAX. 
		 */
		virtual	void SetMaximumLayers( unsigned int value ) = 0;

		/**
		 * The maximum number of layers in the mapping image. If a remeshed geometry has 
		 * a lot of transparent triangles, use a higher number to be able to find intersections 
		 * on the inside of parts of the geometry. This setting only has effect in the 
		 * remeshing, when running reduction the number of layers is always 1. 
		 */
		virtual	unsigned int GetMaximumLayers(  ) = 0;

		/**
		 * If true, the remeshing processor will allow mapped transparency in the generated 
		 * mapping image. This allows material casting where gaps filled by the remeshing 
		 * processor will be cast as transparent. 
		 * @param value The desired value of AllowTransparencyMapping. 
		 */
		virtual	void SetAllowTransparencyMapping( bool value ) = 0;

		/**
		 * If true, the remeshing processor will allow mapped transparency in the generated 
		 * mapping image. This allows material casting where gaps filled by the remeshing 
		 * processor will be cast as transparent. 
		 */
		virtual	bool GetAllowTransparencyMapping(  ) = 0;

		/**
		 * If set, the aggregation processor, reduction processor, or remeshing processor 
		 * will create a mapping image that maps triangles on the reduced geometry back 
		 * to triangles on the original geometry. The texture is insert into the MappingImage 
		 * object. The image data will contain two fields: * RidArray, "TriangleIds", 
		 * TupleSize:1, The id of the triangle * UnsignedShortArray, "BarycentricCoords", 
		 * TupleSize:2, Items A & B of the barycentric coordinate on the triangle. The 
		 * user can control the size of the mapped texture using the values MappingTextureWidth 
		 * and MappingTextureHeight. 
		 * @param value The desired GenerateMappingImage flag. 
		 */
		virtual	void SetGenerateMappingImage( bool value ) = 0;

		/**
		 * If set, the aggregation processor, reduction processor, or remeshing processor 
		 * will create a mapping image that maps triangles on the reduced geometry back 
		 * to triangles on the original geometry. The texture is insert into the MappingImage 
		 * object. The image data will contain two fields: * RidArray, "TriangleIds", 
		 * TupleSize:1, The id of the triangle * UnsignedShortArray, "BarycentricCoords", 
		 * TupleSize:2, Items A & B of the barycentric coordinate on the triangle. The 
		 * user can control the size of the mapped texture using the values MappingTextureWidth 
		 * and MappingTextureHeight. 
		 */
		virtual	bool GetGenerateMappingImage(  ) = 0;

		/**
		 * If true, generates a new texcoords field at the position specified by TexCoordLevel. 
		 * Will be ignored and always generate texcoords if none are available in the 
		 * Geometry if GenerateMappingImage is enabled. 
		 * @param value The desired GenerateTexCoords flag. 
		 */
		virtual	void SetGenerateTexCoords( bool value ) = 0;

		/**
		 * If true, generates a new texcoords field at the position specified by TexCoordLevel. 
		 * Will be ignored and always generate texcoords if none are available in the 
		 * Geometry if GenerateMappingImage is enabled. 
		 */
		virtual	bool GetGenerateTexCoords(  ) = 0;

		/**
		 * If true, generates a new tangent space fields at position specified by TexCoordLevel, 
		 * based on the vertex normals and texture coordinates. Tangent space fields will 
		 * always be created if missing, and GenerateMappingImage is enabled. If GenerateTexCoords 
		 * is enabled, new tangents will always be generated. 
		 * @param value The desired GenerateTangents flag. 
		 */
		virtual	void SetGenerateTangents( bool value ) = 0;

		/**
		 * If true, generates a new tangent space fields at position specified by TexCoordLevel, 
		 * based on the vertex normals and texture coordinates. Tangent space fields will 
		 * always be created if missing, and GenerateMappingImage is enabled. If GenerateTexCoords 
		 * is enabled, new tangents will always be generated. 
		 */
		virtual	bool GetGenerateTangents(  ) = 0;

		/**
		 * The texture coordinate level used for mapping image and texture generation. 
		 * If the TexCoordName has been set, the TexCoordLevel is not used. 
		 * @param value The desired texture coordinate level. Value cannot be less than 
		 * -1. Value cannot be greater than INT_MAX. 
		 */
		virtual	void SetTexCoordLevel( rid value ) = 0;

		/**
		 * The texture coordinate level used for mapping image and texture generation. 
		 * If the TexCoordName has been set, the TexCoordLevel is not used. 
		 */
		virtual	rid GetTexCoordLevel(  ) = 0;

		/**
		 * The texture coordinate level name used for mapping image and texture generation. 
		 * If new UVs are created, they will replace the old coordinates in the texture 
		 * channel with the TexCoordName. If no texture level with this name exists. It 
		 * will be created. If the TexCoordName is not set, the TexCoordLevel (index) 
		 * will be used instead. 
		 * @param value The TexCoord level name. 
		 * @return The current texture coordinate level name 
		 */
		virtual	void SetTexCoordName( const char * value ) = 0;

		/**
		 * The texture coordinate level name used for mapping image and texture generation. 
		 * If new UVs are created, they will replace the old coordinates in the texture 
		 * channel with the TexCoordName. If no texture level with this name exists. It 
		 * will be created. If the TexCoordName is not set, the TexCoordLevel (index) 
		 * will be used instead. 
		 * @return The current texture coordinate level name Default value is nullptr 
		 *  
		 */
		virtual	spString GetTexCoordName(  ) = 0;

		/**
		 * If set, all original texcoord sets are replaced by a single new one which will 
		 * be used for the mapping image. This means the output scene will be temporarily 
		 * invalid before the materialtable has been updated to reflect the new changes. 
		 * This flag has no effect on the remeshing, which always does a full retexturing. 
		 * @param value The desired UseFullRetexturing flag. 
		 */
		virtual	void SetUseFullRetexturing( bool value ) = 0;

		/**
		 * If set, all original texcoord sets are replaced by a single new one which will 
		 * be used for the mapping image. This means the output scene will be temporarily 
		 * invalid before the materialtable has been updated to reflect the new changes. 
		 * This flag has no effect on the remeshing, which always does a full retexturing. 
		 *  
		 */
		virtual	bool GetUseFullRetexturing(  ) = 0;

		/**
		 * If true, and also generating one or more mapping images for material casting, 
		 * the material IDs in the process geometry will be updated to reflect the new, 
		 * not yet cast output materials. This means the output scene will be temporarily 
		 * invalid before the materialtable has been updated to reflect the new changes. 
		 * @param value The desired ApplyNewMaterialIds flag. 
		 */
		virtual	void SetApplyNewMaterialIds( bool value ) = 0;

		/**
		 * If true, and also generating one or more mapping images for material casting, 
		 * the material IDs in the process geometry will be updated to reflect the new, 
		 * not yet cast output materials. This means the output scene will be temporarily 
		 * invalid before the materialtable has been updated to reflect the new changes. 
		 *  
		 */
		virtual	bool GetApplyNewMaterialIds(  ) = 0;

		/**
		 * The UseAutomaticTextureSize flag. If true, then texture sizes will be computed 
		 * for the reduced mesh depending on its pixel size on screen. 
		 * @param value The desired flag. 
		 */
		virtual	void SetUseAutomaticTextureSize( bool value ) = 0;

		/**
		 * The UseAutomaticTextureSize flag. If true, then texture sizes will be computed 
		 * for the reduced mesh depending on its pixel size on screen. 
		 */
		virtual	bool GetUseAutomaticTextureSize(  ) = 0;

		/**
		 * Texture dimension length multiplier for the automatic texture size. 
		 * @param value The desired multiplier. Value cannot be less than 0. Value cannot 
		 * be greater than REAL_MAX. 
		 */
		virtual	void SetAutomaticTextureSizeMultiplier( real value ) = 0;

		/**
		 * Texture dimension length multiplier for the automatic texture size. 
		 */
		virtual	real GetAutomaticTextureSizeMultiplier(  ) = 0;

		/**
		 * If automatic_texture_size is enabled, then force the texture sizes to be a 
		 * power of 2. 
		 * @param value The desired flag. 
		 */
		virtual	void SetForcePower2Texture( bool value ) = 0;

		/**
		 * If automatic_texture_size is enabled, then force the texture sizes to be a 
		 * power of 2. 
		 */
		virtual	bool GetForcePower2Texture(  ) = 0;

		/**
		 * Determines which method to use when generating the texture coordinates. Parameterizer 
		 * generate from scratch based on the geometry. ChartAggregator generate based 
		 * on the original texture coordinates. 
		 * @param value The TexCoordGeneratorType value to use. 
		 */
		virtual	void SetTexCoordGeneratorType( Simplygon::ETexcoordGeneratorType value ) = 0;

		/**
		 * Determines which method to use when generating the texture coordinates. Parameterizer 
		 * generate from scratch based on the geometry. ChartAggregator generate based 
		 * on the original texture coordinates. 
		 */
		virtual	Simplygon::ETexcoordGeneratorType GetTexCoordGeneratorType(  ) = 0;

		/**
		 * If enabled, will aggregate all the valid original UVs. If there are invalid 
		 * original UVs, those parts will receive new parameterized UVs. 
		 * @param value The new flag. 
		 */
		virtual	void SetOnlyParameterizeInvalidUVs( bool value ) = 0;

		/**
		 * If enabled, will aggregate all the valid original UVs. If there are invalid 
		 * original UVs, those parts will receive new parameterized UVs. 
		 */
		virtual	bool GetOnlyParameterizeInvalidUVs(  ) = 0;

		/**
		 * The settings for the chart aggregator. 
		 * @return The chart aggregator settings object associated with the mapping image 
		 *  
		 */
		virtual	spChartAggregatorSettings GetChartAggregatorSettings(  ) = 0;

		/**
		 * The settings for the parameterizer. 
		 * @return The parameterizer settings object associated with the mapping image 
		 *  
		 */
		virtual	spParameterizerSettings GetParameterizerSettings(  ) = 0;

	};

	/**
	 * Settings for the Simplygon mapping input. 
	 */
	class IMappingImageInputMaterialSettings : public ISettingsObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IMappingImageInputMaterialSettings is 
		 * a or is a descendant of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IMappingImageInputMaterialSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IMappingImageInputMaterialSettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IMappingImageInputMaterialSettings 
		 * pointer 
		 * @return a pointer to the IMappingImageInputMaterialSettings object, if the 
		 * cast can be made, and a NULL pointer otherwise 
		 */

		static IMappingImageInputMaterialSettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IMappingImageInputMaterialSettings") )
				return static_cast<IMappingImageInputMaterialSettings*>(ptr);
			return nullptr;
		}
		/**
		 * The material mapping for the input material this setting object corresponds 
		 * to, meaning what material of the generated LOD the corresponding input material 
		 * will be baked into. Both InputMaterialCount and OutputMaterialCount need to 
		 * be set for this mapping to work, and all original materials need to be mapped 
		 * to an existing output id. 
		 * @param value The output material id the corresponding input is to be mapped 
		 * to. Value cannot be less than -1. Value cannot be greater than INT_MAX. 
		 */
		virtual	void SetMaterialMapping( int value ) = 0;

		/**
		 * The material mapping for the input material this setting object corresponds 
		 * to, meaning what material of the generated LOD the corresponding input material 
		 * will be baked into. Both InputMaterialCount and OutputMaterialCount need to 
		 * be set for this mapping to work, and all original materials need to be mapped 
		 * to an existing output id. 
		 */
		virtual	int GetMaterialMapping(  ) = 0;

	};

	/**
	 * Settings for the Simplygon mapping output. 
	 */
	class IMappingImageOutputMaterialSettings : public ISettingsObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IMappingImageOutputMaterialSettings is 
		 * a or is a descendant of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IMappingImageOutputMaterialSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IMappingImageOutputMaterialSettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IMappingImageOutputMaterialSettings 
		 * pointer 
		 * @return a pointer to the IMappingImageOutputMaterialSettings object, if the 
		 * cast can be made, and a NULL pointer otherwise 
		 */

		static IMappingImageOutputMaterialSettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IMappingImageOutputMaterialSettings") )
				return static_cast<IMappingImageOutputMaterialSettings*>(ptr);
			return nullptr;
		}
		/**
		 * The width of the texture of the output mapping image. 
		 * @param value The value to which Width will be set. Value cannot be less than 
		 * 0. Value cannot be greater than UINT_MAX. 
		 */
		virtual	void SetTextureWidth( unsigned int value ) = 0;

		/**
		 * The width of the texture of the output mapping image. 
		 */
		virtual	unsigned int GetTextureWidth(  ) = 0;

		/**
		 * The height of the texture of the output mapping image. 
		 * @param value The value to which Height will be set. Value cannot be less than 
		 * 0. Value cannot be greater than UINT_MAX. 
		 */
		virtual	void SetTextureHeight( unsigned int value ) = 0;

		/**
		 * The height of the texture of the output mapping image. 
		 */
		virtual	unsigned int GetTextureHeight(  ) = 0;

		/**
		 * The multi-sampling level of the output mapping image. Values 1-8 are accepted. 
		 * @param value The value to which MultiSamplingLevel will be set. Value cannot 
		 * be less than 1. Value cannot be greater than 8. 
		 */
		virtual	void SetMultisamplingLevel( unsigned int value ) = 0;

		/**
		 * The multi-sampling level of the output mapping image. Values 1-8 are accepted. 
		 *  
		 */
		virtual	unsigned int GetMultisamplingLevel(  ) = 0;

		/**
		 * The minimum number of pixels between charts of the output mapping image. 
		 * @param value The value to which GutterSpace will be set. Value cannot be less 
		 * than 0. Value cannot be greater than UINT_MAX. 
		 */
		virtual	void SetGutterSpace( unsigned int value ) = 0;

		/**
		 * The minimum number of pixels between charts of the output mapping image. 
		 */
		virtual	unsigned int GetGutterSpace(  ) = 0;

	};

	/**
	 * Visibility settings contains the parameters for how to compute the visibility 
	 * of a scene and how to use it, both in the ReductionProcessor and the RemeshingProcessor. 
	 * The visibility information is computed for each part of the mesh determined 
	 * by the visibility from the selected SceneCamera objects. Cameras are selected 
	 * using the CameraSelectionSetID. The visibility can be used to guide the reducer 
	 * and/or texture coordinates generator (parameterizer) with the flags UseVisibilityWeightsInReducer 
	 * respective UseVisibilityWeightsInTexcoordGenerator. There is also an option 
	 * to completely throw away triangles that are deemed not visible, using the CullOccludedGeometry 
	 * flag. 
	 */
	class IVisibilitySettings : public ISettingsObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IVisibilitySettings is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IVisibilitySettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IVisibilitySettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IVisibilitySettings pointer 
		 * @return a pointer to the IVisibilitySettings object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IVisibilitySettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IVisibilitySettings") )
				return static_cast<IVisibilitySettings*>(ptr);
			return nullptr;
		}
		/**
		 * If set to true, visibility weights will be used in the reducer. 
		 * @param value The desired flag value. 
		 */
		virtual	void SetUseVisibilityWeightsInReducer( bool value ) = 0;

		/**
		 * If set to true, visibility weights will be used in the reducer. 
		 */
		virtual	bool GetUseVisibilityWeightsInReducer(  ) = 0;

		/**
		 * If set to true, visibility weights will be used when generating new texture 
		 * coordinates. 
		 * @param value The new UseVisibilityWeightsInTexcoordGenerator value. 
		 */
		virtual	void SetUseVisibilityWeightsInTexcoordGenerator( bool value ) = 0;

		/**
		 * If set to true, visibility weights will be used when generating new texture 
		 * coordinates. 
		 */
		virtual	bool GetUseVisibilityWeightsInTexcoordGenerator(  ) = 0;

		/**
		 * Set how aggressively reducer should handle low visibility weights. 
		 * @param value Power of influence (default 1.0). Value cannot be less than 0. 
		 * Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetVisibilityWeightsPower( real value ) = 0;

		/**
		 * Set how aggressively reducer should handle low visibility weights. 
		 */
		virtual	real GetVisibilityWeightsPower(  ) = 0;

		/**
		 * If set to true, geometry that is not visible will be removed. 
		 * @param value The new CullOccludedGeometry value. 
		 */
		virtual	void SetCullOccludedGeometry( bool value ) = 0;

		/**
		 * If set to true, geometry that is not visible will be removed. 
		 */
		virtual	bool GetCullOccludedGeometry(  ) = 0;

		/**
		 * Set the ForceVisibilityCalculation if true, visibility weights will definitely 
		 * be computed for the geometry, even if the visibility isn't specifically being 
		 * used for reduction/materialLOD/culling according to the VisibilitySettings. 
		 * @param value The new ForceVisibilityCalculation value. 
		 */
		virtual	void SetForceVisibilityCalculation( bool value ) = 0;

		/**
		 * Set the ForceVisibilityCalculation if true, visibility weights will definitely 
		 * be computed for the geometry, even if the visibility isn't specifically being 
		 * used for reduction/materialLOD/culling according to the VisibilitySettings. 
		 *  
		 */
		virtual	bool GetForceVisibilityCalculation(  ) = 0;

		/**
		 * Set whether triangles should be regarded visible when viewed from the back. 
		 * @param value The desired flag value. 
		 */
		virtual	void SetUseBackfaceCulling( bool value ) = 0;

		/**
		 * Set whether triangles should be regarded visible when viewed from the back. 
		 *  
		 */
		virtual	bool GetUseBackfaceCulling(  ) = 0;

		/**
		 * The ID of the selection set containing all the scene cameras and scene meshes 
		 * used when computing visibility. If scene meshes are added, all their vertices 
		 * will be used as omni-directional cameras. If set to -1, all cameras in the 
		 * scene will be used. If both selection set name and ID are set, the name will 
		 * be used. 
		 * @param value The desired SelectionSetID value. Value cannot be less than -1. 
		 *  
		 */
		virtual	void SetCameraSelectionSetID( rid value ) = 0;

		/**
		 * The ID of the selection set containing all the scene cameras and scene meshes 
		 * used when computing visibility. If scene meshes are added, all their vertices 
		 * will be used as omni-directional cameras. If set to -1, all cameras in the 
		 * scene will be used. If both selection set name and ID are set, the name will 
		 * be used. 
		 */
		virtual	rid GetCameraSelectionSetID(  ) = 0;

		/**
		 * The name of the selection set containing all the scene cameras and scene meshes 
		 * used when computing visibility. If scene meshes are added, all their vertices 
		 * will be used as omni-directional cameras. If set to null, all cameras in the 
		 * scene will be used. If both selection set name and ID are set, the name will 
		 * be used. 
		 * @param value The desired SelectionSet name. 
		 */
		virtual	void SetCameraSelectionSetName( const char * value ) = 0;

		/**
		 * The name of the selection set containing all the scene cameras and scene meshes 
		 * used when computing visibility. If scene meshes are added, all their vertices 
		 * will be used as omni-directional cameras. If set to null, all cameras in the 
		 * scene will be used. If both selection set name and ID are set, the name will 
		 * be used. 
		 */
		virtual	spString GetCameraSelectionSetName(  ) = 0;

		/**
		 * The ID of the selection set containing all the scene meshes that should occlude 
		 * the scene when calculating visibility. If set to -1, no occluders will be used. 
		 * If both selection set name and ID are set, the name will be used. 
		 * @param value The desired OccluderSelectionSetID value. Value cannot be less 
		 * than -1. 
		 */
		virtual	void SetOccluderSelectionSetID( rid value ) = 0;

		/**
		 * The ID of the selection set containing all the scene meshes that should occlude 
		 * the scene when calculating visibility. If set to -1, no occluders will be used. 
		 * If both selection set name and ID are set, the name will be used. 
		 */
		virtual	rid GetOccluderSelectionSetID(  ) = 0;

		/**
		 * The name of the selection set containing all the scene meshes used when computing 
		 * visibility. If set to null, no occluders in the scene will be used. If both 
		 * selection set name and ID are set, the name will be used. 
		 * @param value The desired SelectionSet name. 
		 */
		virtual	void SetOccluderSelectionSetName( const char * value ) = 0;

		/**
		 * The name of the selection set containing all the scene meshes used when computing 
		 * visibility. If set to null, no occluders in the scene will be used. If both 
		 * selection set name and ID are set, the name will be used. 
		 */
		virtual	spString GetOccluderSelectionSetName(  ) = 0;

		/**
		 * If a group of non-visible triangles (connected to visible triangles) has an 
		 * area below the FillNonVisibleAreaThreshold - it will receive the same visibility 
		 * as the neighboring visible triangles. Set to zero to skip filling nonvisible 
		 * regions. 
		 * @param value The new FillNonVisibleAreaThreshold value. Value cannot be less 
		 * than 0. Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetFillNonVisibleAreaThreshold( real value ) = 0;

		/**
		 * If a group of non-visible triangles (connected to visible triangles) has an 
		 * area below the FillNonVisibleAreaThreshold - it will receive the same visibility 
		 * as the neighboring visible triangles. Set to zero to skip filling nonvisible 
		 * regions. 
		 */
		virtual	real GetFillNonVisibleAreaThreshold(  ) = 0;

		/**
		 * If enabled, will remove all the visible triangles that are not occluding any 
		 * other triangle. It will also remove all non-visible triangles. 
		 * @param value The new RemoveTrianglesNotOccludingOtherTriangles value. 
		 */
		virtual	void SetRemoveTrianglesNotOccludingOtherTriangles( bool value ) = 0;

		/**
		 * If enabled, will remove all the visible triangles that are not occluding any 
		 * other triangle. It will also remove all non-visible triangles. 
		 */
		virtual	bool GetRemoveTrianglesNotOccludingOtherTriangles(  ) = 0;

		/**
		 * If enabled, will compute the visibility conservatively - meaning that triangles 
		 * that are visible will be tagged as visible but some non-visible triangles might 
		 * also be tagged as visible. If this is turned off, then it is no longer guaranteed 
		 * that all visible triangles are found - but more non-visible triangles will 
		 * be identified as non-visible. 
		 * @param value The new ConservativeMode value. 
		 */
		virtual	void SetConservativeMode( bool value ) = 0;

		/**
		 * If enabled, will compute the visibility conservatively - meaning that triangles 
		 * that are visible will be tagged as visible but some non-visible triangles might 
		 * also be tagged as visible. If this is turned off, then it is no longer guaranteed 
		 * that all visible triangles are found - but more non-visible triangles will 
		 * be identified as non-visible. 
		 */
		virtual	bool GetConservativeMode(  ) = 0;

		/**
		 * Specifies the renderer type when computing visibility. 
		 * @param value The new ComputeVisibilityMode value. 
		 */
		virtual	void SetComputeVisibilityMode( Simplygon::EComputeVisibilityMode value ) = 0;

		/**
		 * Specifies the renderer type when computing visibility. 
		 */
		virtual	Simplygon::EComputeVisibilityMode GetComputeVisibilityMode(  ) = 0;

	};
	class IScene;
	class IMappingImage;
	class IRepairSettings;
	class IReductionSettings;
	class IBoneSettings;
	class INormalCalculationSettings;
	class IMappingImageSettings;
	class IVisibilitySettings;
	class IVertexWeightSettings;

	/**
	 * ReductionProcessor welds, removes t-junctions, removes double-triangles and 
	 * reduces the triangle count of the Geometry. It also calculates new normals for 
	 * the reduced and optimized Geometry. 
	 */
	class IReductionProcessor : public IProcessingObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IReductionProcessor is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IReductionProcessor",type)==0 )
				return true;
			return IProcessingObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IReductionProcessor 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IReductionProcessor pointer 
		 * @return a pointer to the IReductionProcessor object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IReductionProcessor *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IReductionProcessor") )
				return static_cast<IReductionProcessor*>(ptr);
			return nullptr;
		}
		/**
		 * The scene object to reduce. Please note that internal refrences might be modified 
		 * by the processor. The caller should refresh any reference that is cached outside 
		 * the scene after running the processor. 
		 * @param value The scene to reduce. 
		 */
		virtual	void SetScene( spScene value ) = 0;

		/**
		 * The scene object to reduce. Please note that internal refrences might be modified 
		 * by the processor. The caller should refresh any reference that is cached outside 
		 * the scene after running the processor. 
		 */
		virtual	spScene GetScene(  ) = 0;

		/**
		 * The MappingImage object that is generated if GenerateMappingImage is set in 
		 * MappingImageSettings. This returns mapping image index 0, use GetMappingImageForImageIndex 
		 * to retrieve for a specific index. A new object is generated for each call to 
		 * RunProcessing(). 
		 * @return The generated mappingimage 
		 */
		virtual	spMappingImage GetMappingImage(  ) = 0;

		/**
		 * The MappingImage object that is generated if GenerateMappingImage is set in 
		 * MappingImageSettings. Called with an id, it will fetch that specific mapping 
		 * image if using multi-material output. A new object is generated for each call 
		 * to RunProcessing(). 
		 * @param OutputMaterialId The value for the OutputMaterialId. 
		 * @return The generated mappingimage 
		 */
		virtual	spMappingImage GetMappingImageForImageIndex( rid OutputMaterialId ) = 0;

		/**
		 * The settings for the repair process. 
		 * @return The repair settings object associated with the processor 
		 */
		virtual	spRepairSettings GetRepairSettings(  ) = 0;

		/**
		 * The settings for the reduction process. 
		 * @return The reduction settings object associated with the processor 
		 */
		virtual	spReductionSettings GetReductionSettings(  ) = 0;

		/**
		 * The settings for the bone removal process. 
		 * @return The bone settings object associated with the processor 
		 */
		virtual	spBoneSettings GetBoneSettings(  ) = 0;

		/**
		 * The settings for the normal repair process. 
		 * @return The normal repair settings object associated with the processor 
		 */
		virtual	spNormalCalculationSettings GetNormalCalculationSettings(  ) = 0;

		/**
		 * The settings for the image mapping process. 
		 * @return The mappingimage settings object associated with the processor 
		 */
		virtual	spMappingImageSettings GetMappingImageSettings(  ) = 0;

		/**
		 * The settings for handling visibility weights. 
		 * @return The visibility settings object associated with the processor 
		 */
		virtual	spVisibilitySettings GetVisibilitySettings(  ) = 0;

		/**
		 * The settings for handling visibility weights. 
		 * @return The vertex weight settings object associated with the processor 
		 */
		virtual	spVertexWeightSettings GetVertexWeightSettings(  ) = 0;

		/**
		 * Returns the max deviation reached for the last processing. 
		 * @return The max deviation of the last processing 
		 */
		virtual	real GetResultDeviation(  ) = 0;

	};

	/**
	 * Remeshing settings for the RemeshingLegacyProcessor class. The remesher creates 
	 * a completely new lightweight mesh from the input geometry, and is intended to 
	 * be viewed from the outside. Here you will set the OnScreenSize (larger numbers 
	 * means a more detailed mesh), merge distance (which fills in smaller gaps) and 
	 * a cutting plane (where all parts of the input mesh on the far side of that plane 
	 * will be culled). 
	 */
	class IRemeshingLegacySettings : public ISettingsObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IRemeshingLegacySettings is a or is a 
		 * descendant of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IRemeshingLegacySettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IRemeshingLegacySettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IRemeshingLegacySettings pointer 
		 * @return a pointer to the IRemeshingLegacySettings object, if the cast can be 
		 * made, and a NULL pointer otherwise 
		 */

		static IRemeshingLegacySettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IRemeshingLegacySettings") )
				return static_cast<IRemeshingLegacySettings*>(ptr);
			return nullptr;
		}
		/**
		 * The on-screen rendering size of the geometry. Allowed values are in the range 
		 * 20 to 4000 pixels. 
		 * @param value The value OnScreenSize will be set to. Value cannot be less than 
		 * 20. Value cannot be greater than 4000. 
		 */
		virtual	void SetOnScreenSize( unsigned int value ) = 0;

		/**
		 * The on-screen rendering size of the geometry. Allowed values are in the range 
		 * 20 to 4000 pixels. 
		 */
		virtual	unsigned int GetOnScreenSize(  ) = 0;

		/**
		 * The on-screen merge distance in pixels. Smaller cavities will be removed. This 
		 * will be capped to the on-screen size of the remeshing. 
		 * @param value The value MergeDistance will be set to. Value cannot be less than 
		 * 0. Value cannot be greater than 4000. 
		 */
		virtual	void SetMergeDistance( unsigned int value ) = 0;

		/**
		 * The on-screen merge distance in pixels. Smaller cavities will be removed. This 
		 * will be capped to the on-screen size of the remeshing. 
		 */
		virtual	unsigned int GetMergeDistance(  ) = 0;

		/**
		 * The merge boldness. Defined from 0 to 1, low values will only merge deep cavities 
		 * while high values will merge anything that falls under the merge distance. 
		 * @param value The value MergeBoldness will be set to. Value cannot be less than 
		 * 0. Value cannot be greater than 1. 
		 */
		virtual	void SetMergeBoldness( real value ) = 0;

		/**
		 * The merge boldness. Defined from 0 to 1, low values will only merge deep cavities 
		 * while high values will merge anything that falls under the merge distance. 
		 *  
		 */
		virtual	real GetMergeBoldness(  ) = 0;

		/**
		 * The maximum size in pixels of a generated triangle Any value from 5 pixels 
		 * and above is allowed. If set to 0, there will be no restriction. 
		 * @param value The value MaxTriangleSize will be set to. Value cannot be less 
		 * than 0. Value cannot be greater than UINT_MAX. 
		 */
		virtual	void SetMaxTriangleSize( unsigned int value ) = 0;

		/**
		 * The maximum size in pixels of a generated triangle Any value from 5 pixels 
		 * and above is allowed. If set to 0, there will be no restriction. 
		 */
		virtual	unsigned int GetMaxTriangleSize(  ) = 0;

		/**
		 * The surface transfer mode. 
		 * @param value The new surface transfer mode. 
		 */
		virtual	void SetSurfaceTransferMode( Simplygon::ESurfaceTransferMode value ) = 0;

		/**
		 * The surface transfer mode. 
		 */
		virtual	Simplygon::ESurfaceTransferMode GetSurfaceTransferMode(  ) = 0;

		/**
		 * Set to true to cap the mesh with user defined cutting planes. 
		 * @param value The bool UseCuttingPlanes will be set to. 
		 */
		virtual	void SetUseCuttingPlanes( bool value ) = 0;

		/**
		 * Set to true to cap the mesh with user defined cutting planes. 
		 */
		virtual	bool GetUseCuttingPlanes(  ) = 0;

		/**
		 * The normal hard angle cutoff in degrees. 
		 * @param value The value to which HardEdgeAngle will be set. Value cannot be 
		 * less than 0. Value cannot be greater than 180. 
		 */
		virtual	void SetHardEdgeAngle( real value ) = 0;

		/**
		 * The normal hard angle cutoff in degrees. 
		 */
		virtual	real GetHardEdgeAngle(  ) = 0;

		/**
		 * If true, the vertex normals channel will be sampled from the original mesh. 
		 * @param value The value to which TransferNormals will be set. 
		 */
		virtual	void SetTransferNormals( bool value ) = 0;

		/**
		 * If true, the vertex normals channel will be sampled from the original mesh. 
		 *  
		 */
		virtual	bool GetTransferNormals(  ) = 0;

		/**
		 * If true, vertex color channels will be sampled from the original mesh. 
		 * @param value The bool to which TransferColors will be set. 
		 */
		virtual	void SetTransferColors( bool value ) = 0;

		/**
		 * If true, vertex color channels will be sampled from the original mesh. 
		 */
		virtual	bool GetTransferColors(  ) = 0;

		/**
		 * If true, the terrain selection set along with the terrain empty space override 
		 * will be used to clip the remeshed geometry, like a clipping plane. 
		 * @param value The bool to which UseClippingGeometry will be set. 
		 */
		virtual	void SetUseClippingGeometry( bool value ) = 0;

		/**
		 * If true, the terrain selection set along with the terrain empty space override 
		 * will be used to clip the remeshed geometry, like a clipping plane. 
		 */
		virtual	bool GetUseClippingGeometry(  ) = 0;

		/**
		 * If true, a coordinate in the area that will be considered "outside" can be 
		 * overridden by the user, allowing the remesher to be used for things like interiors 
		 * of caves and rooms. 
		 * @param value The value to which UseEmptySpaceOverride will be set. 
		 */
		virtual	void SetUseEmptySpaceOverride( bool value ) = 0;

		/**
		 * If true, a coordinate in the area that will be considered "outside" can be 
		 * overridden by the user, allowing the remesher to be used for things like interiors 
		 * of caves and rooms. 
		 */
		virtual	bool GetUseEmptySpaceOverride(  ) = 0;

		/**
		 * The empty space override coordinate. 
		 * @param value_realInputDataPtr Is a pointer to a 3-tuple real which will be 
		 * copied and used as a marker designating empty space. 
		 */
		virtual	void SetEmptySpaceOverride( const real *value_realInputDataPtr ) = 0;

		/**
		 * The empty space override coordinate. 
		 * @return The returned data array. The array contains 3 items. 
		 */
		virtual	spRealData GetEmptySpaceOverride(  ) = 0;

		/**
		 * Selects which SelectionSet should be processed. If set to -1, all geometries 
		 * in the scene will be processed. 
		 * @param value The desired SelectionSet id. Value cannot be less than -1. 
		 */
		virtual	void SetProcessSelectionSetID( rid value ) = 0;

		/**
		 * Selects which SelectionSet should be processed. If set to -1, all geometries 
		 * in the scene will be processed. 
		 */
		virtual	rid GetProcessSelectionSetID(  ) = 0;

		/**
		 * Which selection set should be processed. If the name is not found, all geometries 
		 * in the scene will be processed. If both selection set name and ID are set, 
		 * the name will be used. 
		 * @param value The desired SelectionSet name. 
		 */
		virtual	void SetProcessSelectionSetName( const char * value ) = 0;

		/**
		 * Which selection set should be processed. If the name is not found, all geometries 
		 * in the scene will be processed. If both selection set name and ID are set, 
		 * the name will be used. 
		 */
		virtual	spString GetProcessSelectionSetName(  ) = 0;

		/**
		 * The ID of the selection set containing all the cutting planes that should be 
		 * used. If set to -1, all cutting planes are selected. Cutting planes will only 
		 * be used if UseCuttingPlanes is true. If both selection set name and ID are 
		 * set, the name will be used. 
		 * @param value The ID of the selection set containing the cutting planes. Value 
		 * cannot be less than -1. 
		 */
		virtual	void SetCuttingPlaneSelectionSetID( rid value ) = 0;

		/**
		 * The ID of the selection set containing all the cutting planes that should be 
		 * used. If set to -1, all cutting planes are selected. Cutting planes will only 
		 * be used if UseCuttingPlanes is true. If both selection set name and ID are 
		 * set, the name will be used. 
		 */
		virtual	rid GetCuttingPlaneSelectionSetID(  ) = 0;

		/**
		 * The name of the selection set containing all the cutting planes that should 
		 * be used. If the name is not found, all cutting planes are selected. If both 
		 * selection set name and ID are set, the name will be used. 
		 * @param value The desired SelectionSet name. 
		 */
		virtual	void SetCuttingPlaneSelectionSetName( const char * value ) = 0;

		/**
		 * The name of the selection set containing all the cutting planes that should 
		 * be used. If the name is not found, all cutting planes are selected. If both 
		 * selection set name and ID are set, the name will be used. 
		 */
		virtual	spString GetCuttingPlaneSelectionSetName(  ) = 0;

		/**
		 * The ID of the selection set containing the terrain for clipping. If both selection 
		 * set name and ID are set, the name will be used. 
		 * @param value The ID of the selection set containing the clipping terrain. Value 
		 * cannot be less than -1. 
		 */
		virtual	void SetClippingGeometrySelectionSetID( rid value ) = 0;

		/**
		 * The ID of the selection set containing the terrain for clipping. If both selection 
		 * set name and ID are set, the name will be used. 
		 */
		virtual	rid GetClippingGeometrySelectionSetID(  ) = 0;

		/**
		 * The name of the selection set containing the terrain for clipping. If both 
		 * selection set name and ID are set, the name will be used. 
		 * @param value The desired SelectionSet name. 
		 */
		virtual	void SetClippingGeometrySelectionSetName( const char * value ) = 0;

		/**
		 * The name of the selection set containing the terrain for clipping. If both 
		 * selection set name and ID are set, the name will be used. 
		 */
		virtual	spString GetClippingGeometrySelectionSetName(  ) = 0;

		/**
		 * If true, a coordinate in the area that will be considered "outside" for the 
		 * clipping geometry can be overridden by the user. 
		 * @param value The value to which UseClippingGeometryEmptySpaceOverride will 
		 * be set. 
		 */
		virtual	void SetUseClippingGeometryEmptySpaceOverride( bool value ) = 0;

		/**
		 * If true, a coordinate in the area that will be considered "outside" for the 
		 * clipping geometry can be overridden by the user. 
		 */
		virtual	bool GetUseClippingGeometryEmptySpaceOverride(  ) = 0;

		/**
		 * If true, an alternate algorithm is used for the remeshing which is significantly 
		 * faster, but supports smaller sizes ( up to 1000 OnScreenSize ), does not include 
		 * any advanced features, and may be less precise. 
		 * @param value The value to which UsePreviewMode will be set. 
		 */
		virtual	void SetUsePreviewMode( bool value ) = 0;

		/**
		 * If true, an alternate algorithm is used for the remeshing which is significantly 
		 * faster, but supports smaller sizes ( up to 1000 OnScreenSize ), does not include 
		 * any advanced features, and may be less precise. 
		 */
		virtual	bool GetUsePreviewMode(  ) = 0;

		/**
		 * If true, the remeshing processor will not map backfacing triangles. 
		 * @param value The desired value of RespectWindingDirection. 
		 */
		virtual	void SetRespectWindingDirection( bool value ) = 0;

		/**
		 * If true, the remeshing processor will not map backfacing triangles. 
		 */
		virtual	bool GetRespectWindingDirection(  ) = 0;

		/**
		 * The clipping geometry empty space override coordinate. 
		 * @param value_realInputDataPtr Is a pointer to a 3-tuple real which will be 
		 * copied and used as a marker designating empty space. 
		 */
		virtual	void SetClippingGeometryEmptySpaceOverride( const real *value_realInputDataPtr ) = 0;

		/**
		 * The clipping geometry empty space override coordinate. 
		 * @return The returned data array. The array contains 3 items. 
		 */
		virtual	spRealData GetClippingGeometryEmptySpaceOverride(  ) = 0;

		/**
		 * The name of the scene node in the output Scene containing the remeshed geometry. 
		 * @param value The desired OutputSceneNodeName. 
		 */
		virtual	void SetOutputSceneNodeName( const char * value ) = 0;

		/**
		 * The name of the scene node in the output Scene containing the remeshed geometry. 
		 *  
		 */
		virtual	spString GetOutputSceneNodeName(  ) = 0;

	};

	/**
	 * Remeshing settings for the RemeshingProcessor class. 
	 */
	class IRemeshingSettings : public ISettingsObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IRemeshingSettings is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IRemeshingSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IRemeshingSettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IRemeshingSettings pointer 
		 * @return a pointer to the IRemeshingSettings object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IRemeshingSettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IRemeshingSettings") )
				return static_cast<IRemeshingSettings*>(ptr);
			return nullptr;
		}
		/**
		 * The on-screen rendering size of the geometry. Allowed values are in the range 
		 * 20 to 10000 pixels. 
		 * @param value The value OnScreenSize will be set to. Value cannot be less than 
		 * 20. Value cannot be greater than 10000. 
		 */
		virtual	void SetOnScreenSize( unsigned int value ) = 0;

		/**
		 * The on-screen rendering size of the geometry. Allowed values are in the range 
		 * 20 to 10000 pixels. 
		 */
		virtual	unsigned int GetOnScreenSize(  ) = 0;

		/**
		 * The remeshing mode, options are Outside, Inside and Manual. RemeshingMode defines 
		 * if the remeshing processor remeshes the outside or the inside of the input 
		 * geometry. Manual needs the user to define a position in space that will be 
		 * considered as outside for the purposes of the remeshing. Position is set with 
		 * RemeshingModeManualPosition. Hole filling only works with the mode Outside. 
		 * @param value The new remeshing mode. 
		 */
		virtual	void SetRemeshingMode( Simplygon::ERemeshingMode value ) = 0;

		/**
		 * The remeshing mode, options are Outside, Inside and Manual. RemeshingMode defines 
		 * if the remeshing processor remeshes the outside or the inside of the input 
		 * geometry. Manual needs the user to define a position in space that will be 
		 * considered as outside for the purposes of the remeshing. Position is set with 
		 * RemeshingModeManualPosition. Hole filling only works with the mode Outside. 
		 *  
		 */
		virtual	Simplygon::ERemeshingMode GetRemeshingMode(  ) = 0;

		/**
		 * HoleFillling defines how aggresively the remesher will fill holes and cavities. 
		 * What this does is to measure the volume and hole opening sizes of concavities 
		 * in the input geometry and fill them in in the remeshing if the concavity is 
		 * large enough with a small enough opening. This removes a lot of unnessecary 
		 * geometry and is recommended to be kept at it's default rather than turning 
		 * it off, it will in the vast majority of cases have a positive effect on the 
		 * result. 
		 * @param value The new hole fill mode. 
		 */
		virtual	void SetHoleFilling( Simplygon::EHoleFilling value ) = 0;

		/**
		 * HoleFillling defines how aggresively the remesher will fill holes and cavities. 
		 * What this does is to measure the volume and hole opening sizes of concavities 
		 * in the input geometry and fill them in in the remeshing if the concavity is 
		 * large enough with a small enough opening. This removes a lot of unnessecary 
		 * geometry and is recommended to be kept at it's default rather than turning 
		 * it off, it will in the vast majority of cases have a positive effect on the 
		 * result. 
		 */
		virtual	Simplygon::EHoleFilling GetHoleFilling(  ) = 0;

		/**
		 * The surface transfer mode. 
		 * @param value The new surface transfer mode. 
		 */
		virtual	void SetSurfaceTransferMode( Simplygon::ESurfaceTransferMode value ) = 0;

		/**
		 * The surface transfer mode. 
		 */
		virtual	Simplygon::ESurfaceTransferMode GetSurfaceTransferMode(  ) = 0;

		/**
		 * The normal hard angle cutoff in degrees. 
		 * @param value The value to which HardEdgeAngle will be set. Value cannot be 
		 * less than 0. Value cannot be greater than 180. 
		 */
		virtual	void SetHardEdgeAngle( real value ) = 0;

		/**
		 * The normal hard angle cutoff in degrees. 
		 */
		virtual	real GetHardEdgeAngle(  ) = 0;

		/**
		 * If set, the vertex normals channel will be sampled from the original mesh. 
		 * @param value The value to which TransferNormals will be set. 
		 */
		virtual	void SetTransferNormals( bool value ) = 0;

		/**
		 * If set, the vertex normals channel will be sampled from the original mesh. 
		 *  
		 */
		virtual	bool GetTransferNormals(  ) = 0;

		/**
		 * If set, vertex color channels will be sampled from the original mesh. 
		 * @param value The bool to which TransferColors will be set. 
		 */
		virtual	void SetTransferColors( bool value ) = 0;

		/**
		 * If set, vertex color channels will be sampled from the original mesh. 
		 */
		virtual	bool GetTransferColors(  ) = 0;

		/**
		 * Selects which SelectionSet should be processed. If set to -1, all geometries 
		 * in the scene will be processed. 
		 * @param value The desired SelectionSet id. Value cannot be less than -1. 
		 */
		virtual	void SetProcessSelectionSetID( rid value ) = 0;

		/**
		 * Selects which SelectionSet should be processed. If set to -1, all geometries 
		 * in the scene will be processed. 
		 */
		virtual	rid GetProcessSelectionSetID(  ) = 0;

		/**
		 * Selects which selection set should be processed. If the selection set is not 
		 * found, all geometries in the scene will be processed. If both selection set 
		 * name and ID are set, the name will be used. 
		 * @param value The desired SelectionSet name. 
		 */
		virtual	void SetProcessSelectionSetName( const char * value ) = 0;

		/**
		 * Selects which selection set should be processed. If the selection set is not 
		 * found, all geometries in the scene will be processed. If both selection set 
		 * name and ID are set, the name will be used. 
		 */
		virtual	spString GetProcessSelectionSetName(  ) = 0;

		/**
		 * If false, the processor will remove all geometry and scene nodes which was 
		 * not selected for processing from the scene. If true, only the geometry in the 
		 * ProcessSelectionSet will be replaced or updated. If old nodes are kept and 
		 * a new geometry is added to the scene, it will always be the last child of the 
		 * scene root. If generating a mappingimage to cast materials, new materialIds 
		 * will also be appended to the end of the old material table instead of replacing 
		 * the old ones. 
		 * @param value The desired KeepUnprocessedSceneMeshes flag. 
		 */
		virtual	void SetKeepUnprocessedSceneMeshes( bool value ) = 0;

		/**
		 * If false, the processor will remove all geometry and scene nodes which was 
		 * not selected for processing from the scene. If true, only the geometry in the 
		 * ProcessSelectionSet will be replaced or updated. If old nodes are kept and 
		 * a new geometry is added to the scene, it will always be the last child of the 
		 * scene root. If generating a mappingimage to cast materials, new materialIds 
		 * will also be appended to the end of the old material table instead of replacing 
		 * the old ones. 
		 */
		virtual	bool GetKeepUnprocessedSceneMeshes(  ) = 0;

	};
	class IScene;
	class IMappingImage;
	class IRemeshingLegacySettings;
	class IMappingImageSettings;
	class IBoneSettings;
	class IVisibilitySettings;

	/**
	 * RemeshingLegacyProcessor creates a new geometry that is based on the input geometry, 
	 * but that is topologically based on the size of the input geometry rendered at 
	 * a specific screen size, and allowed pixel error. The remesher will on demand 
	 * also add texture coordinates and a mapping texture to the output remeshed geometry. 
	 * The geometry that is to be remeshed can be defined either using an in-memory 
	 * geometry data object, or using a geometry file placed on disk, the latter being 
	 * the preferred method, if the source geometry is very large as it can be swapped 
	 * in/out of memory as needed. 
	 */
	class IRemeshingLegacyProcessor : public IProcessingObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IRemeshingLegacyProcessor is a or is 
		 * a descendant of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IRemeshingLegacyProcessor",type)==0 )
				return true;
			return IProcessingObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IRemeshingLegacyProcessor 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IRemeshingLegacyProcessor pointer 
		 * @return a pointer to the IRemeshingLegacyProcessor object, if the cast can 
		 * be made, and a NULL pointer otherwise 
		 */

		static IRemeshingLegacyProcessor *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IRemeshingLegacyProcessor") )
				return static_cast<IRemeshingLegacyProcessor*>(ptr);
			return nullptr;
		}
		/**
		 * The scene used for remeshing processing. All mesh nodes in the whole scene 
		 * tree will be replaced by one proxy mesh. Please note that internal refrences 
		 * might be modified by the processor. The caller should refresh any reference 
		 * that is cached outside the scene after running the processor. 
		 * @param value The scene to process. 
		 */
		virtual	void SetScene( spScene value ) = 0;

		/**
		 * The scene used for remeshing processing. All mesh nodes in the whole scene 
		 * tree will be replaced by one proxy mesh. Please note that internal refrences 
		 * might be modified by the processor. The caller should refresh any reference 
		 * that is cached outside the scene after running the processor. 
		 */
		virtual	spScene GetScene(  ) = 0;

		/**
		 * The MappingImage object that is generated if GenerateMappingImage is set in 
		 * the MappingImageSettings. This returns mapping image index 0, use GetMappingImageForImageIndex 
		 * to retrieve for a specific index. A new object is generated for each call to 
		 * RunProcessing(). 
		 * @return The current mappingimage 
		 */
		virtual	spMappingImage GetMappingImage(  ) = 0;

		/**
		 * The MappingImage object that is generated if GenerateMappingImage is set in 
		 * the MappingImageSettings. Called with an id, it will fetch that specific mapping 
		 * image if using multi-material output. A new object is generated for each call 
		 * to RunProcessing(). 
		 * @param value The ID of the mapping image. 
		 * @return The current mappingimage 
		 */
		virtual	spMappingImage GetMappingImageForImageIndex( rid value ) = 0;

		/**
		 * The settings for the remeshing process. 
		 * @return The remeshing settings object. 
		 */
		virtual	spRemeshingLegacySettings GetRemeshingLegacySettings(  ) = 0;

		/**
		 * The settings for the image mapping process. 
		 * @return The mapping image settings object. 
		 */
		virtual	spMappingImageSettings GetMappingImageSettings(  ) = 0;

		/**
		 * The settings for the bone removal process. 
		 * @return The bone settings object. 
		 */
		virtual	spBoneSettings GetBoneSettings(  ) = 0;

		/**
		 * The settings for handling visibility weights. 
		 * @return The visibility settings object associated with the processor 
		 */
		virtual	spVisibilitySettings GetVisibilitySettings(  ) = 0;

		/**
		 * When called after processing, this returns the id of a new selection set in 
		 * the scene which contains the mesh node and geometry created in the remeshing 
		 * processing. 
		 * @return The remeshed geometry selection set id 
		 */
		virtual	rid GetResultSelectionSetId(  ) = 0;

	};
	class IScene;
	class IMappingImage;
	class IRemeshingSettings;
	class IMappingImageSettings;
	class IBoneSettings;
	class IGeometryCullingSettings;
	class IVisibilitySettings;

	/**
	 * The RemeshingProcessor takes an input scene and replaces it with a lightweight 
	 * proxy geometry that resembles the original, but does not share vertex data or 
	 * parts of the original mesh data. The remeshed object is created and optimized 
	 * for a certain on-screen pixel size - which means that holes and parts that are 
	 * close to each other will have their gaps filled if the distance is below a pixel. 
	 * At default settings, the proxy mesh is assumed to be viewed from the outside. 
	 * Any interior mesh that cannot be seen is removed. The result is a very light-weight 
	 * mesh that is highly optimized for real-time viewing, or to speed up off-line 
	 * rendering of small objects. Simplygon is capable of remeshing arbitrary geometry, 
	 * including non-manifold surfaces. 
	 */
	class IRemeshingProcessor : public IProcessingObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IRemeshingProcessor is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IRemeshingProcessor",type)==0 )
				return true;
			return IProcessingObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IRemeshingProcessor 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IRemeshingProcessor pointer 
		 * @return a pointer to the IRemeshingProcessor object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IRemeshingProcessor *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IRemeshingProcessor") )
				return static_cast<IRemeshingProcessor*>(ptr);
			return nullptr;
		}
		/**
		 * The scene used for remeshing processing. All mesh nodes in the whole scene 
		 * tree will be replaced by one proxy mesh. Please note that internal refrences 
		 * might be modified by the processor. The caller should refresh any reference 
		 * that is cached outside the scene after running the processor. 
		 * @param value The scene to process. 
		 */
		virtual	void SetScene( spScene value ) = 0;

		/**
		 * The scene used for remeshing processing. All mesh nodes in the whole scene 
		 * tree will be replaced by one proxy mesh. Please note that internal refrences 
		 * might be modified by the processor. The caller should refresh any reference 
		 * that is cached outside the scene after running the processor. 
		 */
		virtual	spScene GetScene(  ) = 0;

		/**
		 * The MappingImage object that is generated if GenerateMappingImage is set in 
		 * the MappingImageSettings. This returns mapping image index 0, use GetMappingImageForImageIndex 
		 * to retrieve for a specific index. A new object is generated for each call to 
		 * RunProcessing(). 
		 * @return The generated mappingimage 
		 */
		virtual	spMappingImage GetMappingImage(  ) = 0;

		/**
		 * The MappingImage object that is generated if GenerateMappingImage is set in 
		 * the MappingImageSettings. Called with an id, it will fetch that specific mapping 
		 * image if using multi-material output. A new object is generated for each call 
		 * to RunProcessing(). 
		 * @param OutputMaterialId The value for the OutputMaterialId. 
		 * @return The generated mappingimage 
		 */
		virtual	spMappingImage GetMappingImageForImageIndex( rid OutputMaterialId ) = 0;

		/**
		 * The settings for the remeshing process. 
		 * @return The remeshing settings object. 
		 */
		virtual	spRemeshingSettings GetRemeshingSettings(  ) = 0;

		/**
		 * The settings for the image mapping process. 
		 * @return The mapping image settings object. 
		 */
		virtual	spMappingImageSettings GetMappingImageSettings(  ) = 0;

		/**
		 * The settings for the bone removal process. 
		 * @return The bone settings object. 
		 */
		virtual	spBoneSettings GetBoneSettings(  ) = 0;

		/**
		 * The settings for handling visibility weights. 
		 * @return The geometry culling settings object associated with the processor 
		 *  
		 */
		virtual	spGeometryCullingSettings GetGeometryCullingSettings(  ) = 0;

		/**
		 * The settings for handling visibility weights. 
		 * @return The visibility settings object associated with the processor 
		 */
		virtual	spVisibilitySettings GetVisibilitySettings(  ) = 0;

	};
	class ISceneNode;
	class IMaterialTable;
	class ISceneBoneTable;
	class ISelectionSetTable;
	class ITextureTable;
	class IMappingImage;
	class IMatrix4x4;
	class IValueArray;
	class IGeometryData;
	class IStringArray;

	/**
	 * Scene is the main keeper of a scene and scene graph in simplygon. The scene 
	 * is self-contained, with materials, textures, etc. to describe a full scene. 
	 */
	class IScene : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IScene is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IScene",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IScene 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IScene pointer 
		 * @return a pointer to the IScene object, if the cast can be made, and a NULL 
		 * pointer otherwise 
		 */

		static IScene *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IScene") )
				return static_cast<IScene*>(ptr);
			return nullptr;
		}
		/**
		 * The root node of the scene. 
		 * @return The root node 
		 */
		virtual	spSceneNode GetRootNode(  ) = 0;

		/**
		 * The material table of the scene. 
		 * @return The material table 
		 */
		virtual	spMaterialTable GetMaterialTable(  ) = 0;

		/**
		 * The bone table of the scene. 
		 * @return The bone table 
		 */
		virtual	spSceneBoneTable GetBoneTable(  ) = 0;

		/**
		 * The selection set table of the scene. 
		 * @return The selection set table 
		 */
		virtual	spSelectionSetTable GetSelectionSetTable(  ) = 0;

		/**
		 * The texture table of the scene. 
		 * @return The texture table 
		 */
		virtual	spTextureTable GetTextureTable(  ) = 0;

		/**
		 * The MappingImage object for the scene. 
		 */
		virtual	spMappingImage GetMappingImage(  ) = 0;

		/**
		 * Removes all scene nodes listed in a selection set. 
		 * @param selectionSetID The ID of the selection set containing the nodes to remove. 
		 *  
		 */
		virtual	void RemoveSceneNodesInSelectionSet( int selectionSetID ) = 0;

		/**
		 * Removes all scene nodes. 
		 */
		virtual	void RemoveSceneNodes(  ) = 0;

		/**
		 * Removes all scene nodes of a specific type. 
		 * @param nodeType The type of object to remove from the scene (i.e. ISceneMesh) 
		 *  
		 */
		virtual	void RemoveSceneNodesOfType( const char * nodeType ) = 0;

		/**
		 * Returns a scene containing the axis aligned bounding boxes of either the entire 
		 * scene or per mesh in the scene. 
		 * @param perMesh Selects whether to generate an AABB per mesh or only one for 
		 * the entire scene. 
		 */
		virtual	spScene CreateAABB( bool perMesh ) = 0;

		/**
		 * Clears the whole scene and releases all items in the graph. 
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Loads a scene from file. 
		 * @param path The path of the scene file. 
		 * @return True on success, false if file was not found 
		 */
		virtual	bool LoadFromFile( const char * path ) = 0;

		/**
		 * Saves a scene to file. 
		 * @param path The path to which the scene file will be saved. 
		 * @return True on success, false if file could not be written to 
		 */
		virtual	bool SaveToFile( const char * path ) = 0;

		/**
		 * Evaluates the global transformation of the specified node at a specific time. 
		 * EvaluateDefaultGlobalTransformation is used to evaluate the default transformation, 
		 * regardless of node animation. 
		 * @param node The node to evaluate. 
		 * @param global_transform The transformation matrix that receives the global 
		 * transformation. 
		 */
		virtual	void EvaluateDefaultGlobalTransformation( spSceneNode node , spMatrix4x4 global_transform ) = 0;

		/**
		 * The inferior (minimum) extent of the scene. 
		 * @return The returned data array. The array contains 3 items. 
		 * @return The minimum extent of the scene 
		 */
		virtual	spRealData GetInf(  ) = 0;

		/**
		 * The superior (maximum) extent of the scene. 
		 * @return The returned data array. The array contains 3 items. 
		 * @return The maximum extent of the scene 
		 */
		virtual	spRealData GetSup(  ) = 0;

		/**
		 * The scene radius. 
		 * @return The radius of the scene 
		 */
		virtual	real GetRadius(  ) = 0;

		/**
		 * Calculates the axis-aligned bounding box of the whole scene. If the node tree 
		 * contains no geometric data, or all data is hidden, the bounding box is not 
		 * calculated, and the method returns false. 
		 * @return True if the calculation succeeded 
		 */
		virtual	bool CalculateExtents(  ) = 0;

		/**
		 * Gets a node defined by a path. Please note that the path must contain names 
		 * for each level to be able to find the specified node. 
		 * @param path The path of the node to get. 
		 * @return The node associated with path 
		 */
		virtual	spSceneNode GetNodeFromPath( const char * path ) = 0;

		/**
		 * Gets a node defined by an id. 
		 * @param node_id The id of the node to get. 
		 * @return The node associated with the id 
		 */
		virtual	spSceneNode GetNodeByGUID( const char * node_id ) = 0;

		/**
		 * Gets a node defined by an id from the specified node tree. 
		 * @param node_id The id of the node to get. 
		 * @param node Id is the id of the node to get. 
		 * @return The node associated with the id 
		 */
		virtual	spSceneNode GetSubNodeByGUID( const char * node_id , spSceneNode node ) = 0;

		/**
		 * Adds a custom data field. To be able to add a field, it must have a name that 
		 * does not conflict with the existing custom fields. 
		 * @param base_type The is the type of the field to be added. 
		 * @param name The name of the new field. 
		 * @param tuple_size The tuple size of the new field. 
		 */
		virtual	spValueArray AddCustomField( Simplygon::EBaseTypes base_type , const char * name , unsigned int tuple_size ) = 0;

		/**
		 * Removes a custom data field. 
		 * @param name The name of the field to be removed. 
		 */
		virtual	void RemoveCustomField( const char * name ) = 0;

		/**
		 * Adds/Removes/Gets a custom data field. 
		 * @param name The name of the field to be fetched. 
		 * @return an array containing the field data 
		 */
		virtual	spValueArray GetCustomField( const char * name ) = 0;

		/**
		 * Checks if a custom field is present in the scene. 
		 * @param name The name of the field to be checked. 
		 * @return True is the field exists, false otherwise 
		 */
		virtual	bool HasCustomField( const char * name ) = 0;

		/**
		 * Removes all bones in the scene that are not linked by any SceneMesh geometry 
		 * data. Note that the removal only removes leaf nodes in the scene. 
		 */
		virtual	void RemoveUnlinkedBones(  ) = 0;

		/**
		 * Will remove mesh nodes that consist of empty geometry. The node transformation 
		 * will be added to all child transformations. If the root node is a sceneMesh 
		 * with empty geometry, it will be replaced with a generic sceneNode having the 
		 * same transformation. 
		 */
		virtual	void Compact(  ) = 0;

		/**
		 * Appends another scene to this scene. All materials, textures etc. 
		 * @param otherScene The scene object to merge into current scene. 
		 */
		virtual	void Append( spScene otherScene ) = 0;

		/**
		 * Combines all the geometries from the selection set and returns a copy. If the 
		 * selection set ID is -1, then all the geometries will be copied. 
		 * @param selectionSetID The ID of the selection set containing node ids to combine. 
		 *  
		 * @return a copy of all geometries combined 
		 */
		virtual	spGeometryData NewCombinedGeometryFromSelectionSet( int selectionSetID ) = 0;

		/**
		 * Combines all the geometries from the scene and returns a copy. 
		 * @return a copy of all geometries combined 
		 */
		virtual	spGeometryData NewCombinedGeometry(  ) = 0;

		/**
		 * Selects all nodes of the type specified in the parameter and returns the selection 
		 * set ID. If no types were found, it returns -1. 
		 * @param nodeTypeName The type of node to select, for example "ISceneMesh". 
		 * @return The selection set ID with the selection 
		 */
		virtual	int SelectNodes( const char * nodeTypeName ) = 0;

		/**
		 * Deep copies the source scene, and all things assigned to it, including all 
		 * nodes, geometry data, materials and tables. 
		 * @param src Is source scene to copy. 
		 */
		virtual	void DeepCopy( spScene src ) = 0;

		/**
		 * Creates a new deep copy of the scene, and all things assigned to it, including 
		 * all nodes, geometry data, materials and tables. 
		 * @return a deep copy of the scene object. 
		 */
		virtual	spScene NewCopy(  ) = 0;

		/**
		 * Traverses the scene meshes in the scene and returns the total triangle count. 
		 *  
		 */
		virtual	unsigned int GetTriangleCount(  ) = 0;

		/**
		 * Clears all previous data in both the material and texture tables and creates 
		 * new, empty materials for every material id referenced by the MaterialIds field 
		 * in the scenes geometrydata objects. Useful for cleaning up scenes containing 
		 * invalid material references and making them exportable when you are primarily 
		 * interested in the geometry and not the materials. 
		 */
		virtual	void StandardizeMaterials(  ) = 0;

		/**
		 * Get the number of cascaded child scenes. 
		 */
		virtual	unsigned int GetCascadedSceneCount(  ) = 0;

		/**
		 * Get the scene for the given cascaded child scene index, which must be less 
		 * than the number of cascaded child scenes. 
		 * @param index The cascaded child scene index. 
		 * @return The cascaded child scene object. 
		 */
		virtual	spScene GetCascadedSceneForIndex( unsigned int index ) = 0;

		/**
		 * Get all unique material channel names for all materials used in scene. 
		 * @param channels The array receiving unique channel names. 
		 */
		virtual	void GetMaterialChannels( spStringArray channels ) = 0;

		/**
		 * Get all unique material channel names having texture inputs for all materials 
		 * used in scene. 
		 * @param channels The array receiving unique channel names. 
		 */
		virtual	void GetMaterialChannelsWithTextureInputs( spStringArray channels ) = 0;

	};
	class IScene;
	class IMatrix4x4;
	class ISceneMesh;
	class IGeometryData;
	class IScenePlane;

	/**
	 * SceneNode is the base class for all scene graph nodes in simplygon. It has relative 
	 * transformation to its parent, and functions to add children to the node. 
	 */
	class ISceneNode : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if ISceneNode is a or is a descendant of 
		 * the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("ISceneNode",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a ISceneNode 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ISceneNode pointer 
		 * @return a pointer to the ISceneNode object, if the cast can be made, and a 
		 * NULL pointer otherwise 
		 */

		static ISceneNode *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("ISceneNode") )
				return static_cast<ISceneNode*>(ptr);
			return nullptr;
		}
		/**
		 * The scene object of the node. 
		 * @return The scene object. 
		 */
		virtual	spScene GetScene(  ) = 0;

		/**
		 * The parent node of this node. 
		 * @return The parent node 
		 */
		virtual	spSceneNode GetParent(  ) = 0;

		/**
		 * The relative transformation of this node. 
		 * @return The relative transformation as a 4x4 matrix 
		 */
		virtual	spMatrix4x4 GetRelativeTransform(  ) = 0;

		/**
		 * The OriginalName parameter which can be used to specify the original name of 
		 * a node, for debugging of merging purposes. This parameter is not copied or 
		 * cloned, and is not used internally by Simplygon. 
		 * @param value Is a string the name is to be set to. 
		 */
		virtual	void SetOriginalName( const char * value ) = 0;

		/**
		 * The OriginalName parameter which can be used to specify the original name of 
		 * a node, for debugging of merging purposes. This parameter is not copied or 
		 * cloned, and is not used internally by Simplygon. 
		 */
		virtual	spString GetOriginalName(  ) = 0;

		/**
		 * The IsVisible flag. If set, the node is visible. 
		 * @param value The bool that isVisible is to be set to. 
		 */
		virtual	void SetIsVisible( bool value ) = 0;

		/**
		 * The IsVisible flag. If set, the node is visible. 
		 */
		virtual	bool GetIsVisible(  ) = 0;

		/**
		 * The IsFrozen flag. If set, the node will not be modified by processing modules. 
		 * @param value The bool that isFrozen is to be set to. 
		 */
		virtual	void SetIsFrozen( bool value ) = 0;

		/**
		 * The IsFrozen flag. If set, the node will not be modified by processing modules. 
		 *  
		 */
		virtual	bool GetIsFrozen(  ) = 0;

		/**
		 * If set, the node is new, copied, or modified by processing modules. This can 
		 * be useful to track modifications in the scene graph. 
		 * @param value The bool that IsModified is to be set to. 
		 */
		virtual	void SetIsModified( bool value ) = 0;

		/**
		 * If set, the node is new, copied, or modified by processing modules. This can 
		 * be useful to track modifications in the scene graph. 
		 */
		virtual	bool GetIsModified(  ) = 0;

		/**
		 * The unique id for this node. 
		 * @param value The node id of type string. 
		 */
		virtual	void SetNodeGUID( const char * value ) = 0;

		/**
		 * The unique id for this node. 
		 */
		virtual	spString GetNodeGUID(  ) = 0;

		/**
		 * The inferior (minimum) extent of the node. 
		 * @return The returned data array. The array contains 3 items. 
		 */
		virtual	spRealData GetInf(  ) = 0;

		/**
		 * The superior (maximum) extent of the node. 
		 * @return The returned data array. The array contains 3 items. 
		 */
		virtual	spRealData GetSup(  ) = 0;

		/**
		 * The number of direct children of this node. 
		 * @return The number of direct children of this node 
		 */
		virtual	unsigned int GetChildCount(  ) = 0;

		/**
		 * Get a pointer to the i:th child of this node. 
		 * @param index The local index of the child (0->GetChildCount()-1) 
		 */
		virtual	spSceneNode GetChild( rid index ) = 0;

		/**
		 * Finds the first child that has the name. 
		 * @param name The name of the child to look for. 
		 */
		virtual	spSceneNode FindNamedChild( const char * name ) = 0;

		/**
		 * Adds a child node to this node. If the child is already a child of another 
		 * node, it is removed from this node. 
		 * @param child The child object. 
		 */
		virtual	void AddChild( spSceneNode child ) = 0;

		/**
		 * Creates a SceneMesh node as a child node to this node. 
		 * @param geom The GeometryData object to associate with this node. 
		 */
		virtual	spSceneMesh CreateChildMesh( spGeometryData geom ) = 0;

		/**
		 * Creates a ScenePlane node as a child node to this node. 
		 * @param position_realInputDataPtr The point on the plane. 
		 * @param normal_realInputDataPtr The normal to the plane. 
		 */
		virtual	spScenePlane CreateChildPlane( const real *position_realInputDataPtr , const real *normal_realInputDataPtr ) = 0;

		/**
		 * Removes a child from the node. 
		 * @param child The child to be removed. 
		 */
		virtual	void RemoveChild( spSceneNode child ) = 0;

		/**
		 * Removes all children of this node. 
		 */
		virtual	void RemoveChildren(  ) = 0;

		/**
		 * Removes this node from its parent. 
		 */
		virtual	void RemoveFromParent(  ) = 0;

		/**
		 * Returns true if the node has the specified child. 
		 * @param child The child node to look for. 
		 * @return True if child exists in the scene, otherwise false 
		 */
		virtual	bool HasChild( spSceneNode child ) = 0;

		/**
		 * Deep copies this node tree (this node and all the descendants of this node) 
		 * and returns the copy top node. Please note that the copy is not added to any 
		 * scene, and can be added anywhere. 
		 * @return a new copy of the ISceneNode 
		 */
		virtual	spSceneNode NewCopy(  ) = 0;

		/**
		 * Clones this node tree (this node and all the descendants of this node) and 
		 * returns the cloned top node. Please note that the copy is not added to any 
		 * scene, and can be added anywhere. Also note that the clone shares all data 
		 * pointers with the original nodes, such as geometry data objects. 
		 * @return a new clone of the ISceneNode 
		 */
		virtual	spSceneNode NewClone(  ) = 0;

		/**
		 * Evaluates the default global transformation of the node, regardless of node 
		 * animation. 
		 * @param global_transform The transformation matrix that receives the global 
		 * transformation. 
		 */
		virtual	void EvaluateDefaultGlobalTransformation( spMatrix4x4 global_transform ) = 0;

		/**
		 * Calculates the axis-aligned bounding box of the node and all its children. 
		 * If the node tree contains no geometric data, or all data is hidden, the bounding 
		 * box is not calcluated, and the method returns false. 
		 * @return True if the calculation succeeded 
		 */
		virtual	bool CalculateExtents(  ) = 0;

		/**
		 * The path to this node in the scene. Please note that only paths where each 
		 * node has a name can be used to get to the node using the path. 
		 * @return The path to this node in the scene 
		 */
		virtual	spString GetPath(  ) = 0;

	};
	class ISceneNode;

	/**
	 * SceneNodeCollection holds a number of SceneNode objects. The objects can be 
	 * looked up by their names (if they have been named through SetName()). 
	 */
	class ISceneNodeCollection : public IObjectCollection
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if ISceneNodeCollection is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("ISceneNodeCollection",type)==0 )
				return true;
			return IObjectCollection::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a ISceneNodeCollection 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ISceneNodeCollection pointer 
		 * @return a pointer to the ISceneNodeCollection object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static ISceneNodeCollection *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("ISceneNodeCollection") )
				return static_cast<ISceneNodeCollection*>(ptr);
			return nullptr;
		}
		/**
		 * Adds an object object to the collection. The handle refers to the object until 
		 * it is removed from the collection again. 
		 * @param obj The node that is to be added to the collection. 
		 * @return The handle of the added node in the collection 
		 */
		virtual	rhandle AddSceneNode( spSceneNode obj ) = 0;

		/**
		 * The object the handle is referring to. 
		 * @param objhandle The handle of the node. 
		 * @return The node associated with the handle 
		 */
		virtual	spSceneNode GetSceneNode( rhandle objhandle ) = 0;

		/**
		 * Removes an object from the collection. Only the first occurrence of the object 
		 * is removed. 
		 * @param pobj The node to be be removed. 
		 */
		virtual	void RemoveSceneNode( spSceneNode pobj ) = 0;

		/**
		 * Finds a named object. 
		 * @param name The name of the searched for object. 
		 * @return The found node, or null if no matching node is found 
		 */
		virtual	spSceneNode FindSceneNode( const char * name ) = 0;

		/**
		 * Returns the object of the next item. 
		 * @param phandle_rhandleInputDataPtr The handle of a node in the collection. 
		 *  
		 * @return The node after phandle 
		 */
		virtual	spSceneNode GetNextItemAsSceneNode( rhandle *phandle_rhandleInputDataPtr ) = 0;

		/**
		 * Returns true if the object is in the collection. 
		 * @param pobj Is an arbitrary node. 
		 * @return True if pobj is in the current collection, false otherwise 
		 */
		virtual	bool IsSceneNodeInCollection( spSceneNode pobj ) = 0;

	};
	class IGeometryData;

	/**
	 * SceneMesh is the mesh node in the simplygon scene graph 
	 */
	class ISceneMesh : public ISceneNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if ISceneMesh is a or is a descendant of 
		 * the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("ISceneMesh",type)==0 )
				return true;
			return ISceneNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a ISceneMesh 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ISceneMesh pointer 
		 * @return a pointer to the ISceneMesh object, if the cast can be made, and a 
		 * NULL pointer otherwise 
		 */

		static ISceneMesh *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("ISceneMesh") )
				return static_cast<ISceneMesh*>(ptr);
			return nullptr;
		}
		/**
		 * The geometry data of the mesh node. 
		 * @param value The geometry that is to be set. 
		 */
		virtual	void SetGeometry( spGeometryData value ) = 0;

		/**
		 * The geometry data of the mesh node. 
		 */
		virtual	spGeometryData GetGeometry(  ) = 0;

	};
	class IRealArray;
	class ISceneNode;

	/**
	 * SceneLodGroup is a LOD grouping for the scene graph 
	 */
	class ISceneLodGroup : public ISceneNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if ISceneLodGroup is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("ISceneLodGroup",type)==0 )
				return true;
			return ISceneNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a ISceneLodGroup 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ISceneLodGroup pointer 
		 * @return a pointer to the ISceneLodGroup object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static ISceneLodGroup *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("ISceneLodGroup") )
				return static_cast<ISceneLodGroup*>(ptr);
			return nullptr;
		}
		/**
		 * The threshold distances associated with the LODs of the LOD group. 
		 * @return The thresholds of the LODs as a realarray 
		 */
		virtual	spRealArray GetThresholds(  ) = 0;

		/**
		 * Returns the child node to use for rendering based on the distance parameter 
		 * and the current threshold values. 
		 * @param distance The distance in units. 
		 * @return The LOD with the thresholds that contain distance 
		 */
		virtual	spSceneNode GetLodForDistance( real distance ) = 0;

	};
	class IRidArray;

	/**
	 * SceneBone is the bone node in the simplygon scene graph 
	 */
	class ISceneBone : public ISceneNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if ISceneBone is a or is a descendant of 
		 * the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("ISceneBone",type)==0 )
				return true;
			return ISceneNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a ISceneBone 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ISceneBone pointer 
		 * @return a pointer to the ISceneBone object, if the cast can be made, and a 
		 * NULL pointer otherwise 
		 */

		static ISceneBone *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("ISceneBone") )
				return static_cast<ISceneBone*>(ptr);
			return nullptr;
		}
		/**
		 * Looks through the hierarchy and fetches the previous BoneNode. If none is found, 
		 * this is a Root-Bone-Node. -1 means it has no parent, otherwise, the ID is the 
		 * parent ID. 
		 * @return The id of the parent bone, or -1 if no parent exists 
		 */
		virtual	rid GetParentBone(  ) = 0;

		/**
		 * Looks through the sub-tree and collects the IDs of the bones found. 
		 * @param child_bones The array to which the ids of found child bones will be 
		 * written. 
		 */
		virtual	void CollectAllChildBones( spRidArray child_bones ) = 0;

		/**
		 * The BoneId. 
		 * @return The id of the current scene bone 
		 */
		virtual	rid GetBoneId(  ) = 0;

	};
	class ISceneBone;

	/**
	 * SceneBoneTable keeps information on bones used while rendering. 
	 */
	class ISceneBoneTable : public ITable
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if ISceneBoneTable is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("ISceneBoneTable",type)==0 )
				return true;
			return ITable::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a ISceneBoneTable 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ISceneBoneTable pointer 
		 * @return a pointer to the ISceneBoneTable object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static ISceneBoneTable *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("ISceneBoneTable") )
				return static_cast<ISceneBoneTable*>(ptr);
			return nullptr;
		}
		/**
		 * Adds a bone to the table. The returned value is the id of the bone within the 
		 * table. 
		 * @param bone The scenebone to be added. 
		 * @return The id of the added bone within the table 
		 */
		virtual	rid AddBone( spSceneBone bone ) = 0;

		/**
		 * Finds a bone in the table, using the bone name. If multiple bones have the 
		 * same name, the first will be returned. If the bone was not found, null is returned. 
		 * @param name The string to be searched for. 
		 * @return The first matching bone, or null if no matches are found 
		 */
		virtual	spSceneBone FindBone( const char * name ) = 0;

		/**
		 * Finds the id of a bone in the table, using the bone name. If multiple bones 
		 * have the same name, the first will be returned. If the bone was not found, 
		 * -1 is returned. 
		 * @param name The string to be searched for. 
		 * @return The id of the first matching bone, or -1 if no matches are found 
		 */
		virtual	rid FindBoneId( const char * name ) = 0;

		/**
		 * Returns the i:th bone, using the id of the bone. 
		 * @param id The id of the wanted bone. 
		 * @return The bone corresponding to the id 
		 */
		virtual	spSceneBone GetBone( rid id ) = 0;

		/**
		 * Removes a bone. If GetBone is called with the bone id, the value returned will 
		 * be null. 
		 * @param id The id of the bone that is to be removed. 
		 */
		virtual	void RemoveBone( rid id ) = 0;

		/**
		 * Returns the number of bones in the table. 
		 * @return The number of bones in the table 
		 */
		virtual	unsigned int GetBonesCount(  ) = 0;

	};

	/**
	 * ScenePlane is the plane node in the simplygon scene graph that can be used in 
	 * various processes, for example as a cutting plane in the RemeshingProcessor. 
	 */
	class IScenePlane : public ISceneNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IScenePlane is a or is a descendant of 
		 * the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IScenePlane",type)==0 )
				return true;
			return ISceneNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IScenePlane 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IScenePlane pointer 
		 * @return a pointer to the IScenePlane object, if the cast can be made, and a 
		 * NULL pointer otherwise 
		 */

		static IScenePlane *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IScenePlane") )
				return static_cast<IScenePlane*>(ptr);
			return nullptr;
		}
		/**
		 * The position (translation) of the plane. 
		 * @return The returned data array. The array contains 3 items. 
		 */
		virtual	spRealData GetPosition(  ) = 0;

		/**
		 * The position (translation) of the plane. 
		 * @param vec_realInputDataPtr The new position. 
		 */
		virtual	void SetPosition( const real *vec_realInputDataPtr ) = 0;

		/**
		 * The normal of the plane. 
		 * @return The returned data array. The array contains 3 items. 
		 */
		virtual	spRealData GetNormal(  ) = 0;

		/**
		 * The normal of the plane. 
		 * @param vec_realInputDataPtr The new normal. 
		 */
		virtual	void SetNormal( const real *vec_realInputDataPtr ) = 0;

	};
	class IRealArray;

	/**
	 * SceneCamera is the camera node in the Simplygon scene graph. SceneCamera contains 
	 * settings that specify how the camera works and it contains a number of views 
	 * for that type of camera. A view is a combination of a CameraPosition and a TargetPosition. 
	 * The SceneCamera can contain any number of views but every element in TargetPositions 
	 * has to correspond to a tuple element in CameraPosition. TargetPositions is not 
	 * needed if the camera is set to being omni directional. 
	 */
	class ISceneCamera : public ISceneNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if ISceneCamera is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("ISceneCamera",type)==0 )
				return true;
			return ISceneNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a ISceneCamera 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ISceneCamera pointer 
		 * @return a pointer to the ISceneCamera object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static ISceneCamera *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("ISceneCamera") )
				return static_cast<ISceneCamera*>(ptr);
			return nullptr;
		}
		/**
		 * The camera type. Perspective - A regular camera that uses the FieldOfView. 
		 * Omnidirectional - An omni directional camera view all directions from its position 
		 * and ignores the TargetPositions and FieldOfView. Orthographic - Orthographic 
		 * cameras render the scene in a direction determined by the vector from CameraPositions 
		 * to TargetPositions, it uses OrthographicCameraPixelSize and ignores the FieldOfView 
		 * and UseNormalizedCoordinates. 
		 * @param value The desired CameraType. 
		 */
		virtual	void SetCameraType( Simplygon::ECameraType value ) = 0;

		/**
		 * The camera type. Perspective - A regular camera that uses the FieldOfView. 
		 * Omnidirectional - An omni directional camera view all directions from its position 
		 * and ignores the TargetPositions and FieldOfView. Orthographic - Orthographic 
		 * cameras render the scene in a direction determined by the vector from CameraPositions 
		 * to TargetPositions, it uses OrthographicCameraPixelSize and ignores the FieldOfView 
		 * and UseNormalizedCoordinates. 
		 */
		virtual	Simplygon::ECameraType GetCameraType(  ) = 0;

		/**
		 * CameraPositions is an IRealArray (with tuple size 3) where each tuple is a 
		 * 3d camera position. 
		 * @return The current array of camera positions 
		 */
		virtual	spRealArray GetCameraPositions(  ) = 0;

		/**
		 * TargetPositions is an IRealArray (with tuple size 3) where each tuple is a 
		 * 3d camera target position. 
		 * @return The current array of target positions 
		 */
		virtual	spRealArray GetTargetPositions(  ) = 0;

		/**
		 * Normalized coordinates means that the coordinates are relative to the scene: 
		 * the origin is in the center of the scene and 1 unit length is the distance 
		 * of the scene radius. This can be used to have cameras in front of or above 
		 * the scene for instance without having to know the coordinates of the scene. 
		 * If set to false, then absolute coordinates will be used instead. 
		 * @param value The desired UseNormalizedCoordinates flag. 
		 */
		virtual	void SetUseNormalizedCoordinates( bool value ) = 0;

		/**
		 * Normalized coordinates means that the coordinates are relative to the scene: 
		 * the origin is in the center of the scene and 1 unit length is the distance 
		 * of the scene radius. This can be used to have cameras in front of or above 
		 * the scene for instance without having to know the coordinates of the scene. 
		 * If set to false, then absolute coordinates will be used instead. 
		 */
		virtual	bool GetUseNormalizedCoordinates(  ) = 0;

		/**
		 * Specifies/Gets the length of the side of a square pixel if the camera type 
		 * is Orthographic. 
		 * @param value The desired OrthographicCameraPixelSize value. 
		 */
		virtual	void SetOrthographicCameraPixelSize( real value ) = 0;

		/**
		 * Specifies/Gets the length of the side of a square pixel if the camera type 
		 * is Orthographic. 
		 */
		virtual	real GetOrthographicCameraPixelSize(  ) = 0;

		/**
		 * The field of view (in radians) of the camera. 
		 * @param value The desired FieldOfView value. 
		 */
		virtual	void SetFieldOfView( real value ) = 0;

		/**
		 * The field of view (in radians) of the camera. 
		 */
		virtual	real GetFieldOfView(  ) = 0;

		/**
		 * Determines the resolution by specifying the field of view per pixel (both vertically 
		 * and horizontally) if the camera type is Perspective or Omnidirectional. For 
		 * instance, if the camera type is Perspective and has PI/2 radians field of view 
		 * (for the entire camera) and the pixel field of view is (PI/2)/512 the camera 
		 * will have 512x512 pixels. 
		 * @param value The desired PixelFieldOfView value. 
		 */
		virtual	void SetPixelFieldOfView( real value ) = 0;

		/**
		 * Determines the resolution by specifying the field of view per pixel (both vertically 
		 * and horizontally) if the camera type is Perspective or Omnidirectional. For 
		 * instance, if the camera type is Perspective and has PI/2 radians field of view 
		 * (for the entire camera) and the pixel field of view is (PI/2)/512 the camera 
		 * will have 512x512 pixels. 
		 */
		virtual	real GetPixelFieldOfView(  ) = 0;

		/**
		 * Returns the number of views. 
		 * @return The number of views. 
		 */
		virtual	unsigned int GetNumberOfViews(  ) = 0;

		/**
		 * Validates the camera properties. Asserts on invalid properties. 
		 * @return True if the ISceneCamera is valid. 
		 */
		virtual	bool ValidateCamera(  ) = 0;

		/**
		 * Creates a set of camera views placed on a custom sphere around the center of 
		 * the scene. 
		 * @param fidelity Determines both the resolution and the amount of cameras and 
		 * should be between 0 and 10. 
		 * @param pitch_angle Amount of degrees the sphere should be pitch rotated. 
		 * @param yaw_angle Amount of degrees the sphere should be yaw rotated. 
		 * @param coverage_angle 360 would be entire sphere, 180 would be hemisphere, 
		 * 0 would be no sphere. 
		 */
		virtual	void SetCustomSphereCameraPath( int fidelity , real pitch_angle , real yaw_angle , real coverage_angle ) = 0;

	};
	class IScene;

	/**
	 * Class for saving scene data to different file formats depending on the extension 
	 * of the set file name. 
	 */
	class ISceneExporter : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if ISceneExporter is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("ISceneExporter",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a ISceneExporter 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ISceneExporter pointer 
		 * @return a pointer to the ISceneExporter object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static ISceneExporter *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("ISceneExporter") )
				return static_cast<ISceneExporter*>(ptr);
			return nullptr;
		}
		/**
		 * The main export file path. This must always be set. 
		 * @param value The desired main export file path. 
		 */
		virtual	void SetExportFilePath( const char * value ) = 0;

		/**
		 * The main export file path. This must always be set. 
		 */
		virtual	spString GetExportFilePath(  ) = 0;

		/**
		 * The primary texture coordinate layer name. Used by file formats that only support 
		 * one texture coordinate layer (like .obj) 
		 * @param value The desired primary texture coordinate layer name. 
		 */
		virtual	void SetPrimaryTexCoordName( const char * value ) = 0;

		/**
		 * The primary texture coordinate layer name. Used by file formats that only support 
		 * one texture coordinate layer (like .obj) 
		 */
		virtual	spString GetPrimaryTexCoordName(  ) = 0;

		/**
		 * The scene to export. 
		 * @param value The scene object to export. 
		 */
		virtual	void SetScene( spScene value ) = 0;

		/**
		 * Runs the export. Note that all parameters must be setup before importing. 
		 */
		virtual	bool RunExport(  ) = 0;

		/**
		 * Close any open file or stream, release any allocated data. 
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Flag to control if output file formats that support embedding referenced resources 
		 * (like textures) should do so. 
		 * @param value Embed flag. 
		 */
		virtual	void SetEmbedReferences( bool value ) = 0;

		/**
		 * Flag to control if output file formats that support embedding referenced resources 
		 * (like textures) should do so. 
		 */
		virtual	bool GetEmbedReferences(  ) = 0;

		/**
		 * Flag to control if cascaded scenes should be included in the export. 
		 * @param value Export cascaded scenes flag. 
		 */
		virtual	void SetExportCascadedScenes( bool value ) = 0;

		/**
		 * Flag to control if cascaded scenes should be included in the export. 
		 */
		virtual	bool GetExportCascadedScenes(  ) = 0;

	};
	class IScene;

	/**
	 * Class for loading scene data from different file formats. 
	 */
	class ISceneImporter : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if ISceneImporter is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("ISceneImporter",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a ISceneImporter 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ISceneImporter pointer 
		 * @return a pointer to the ISceneImporter object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static ISceneImporter *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("ISceneImporter") )
				return static_cast<ISceneImporter*>(ptr);
			return nullptr;
		}
		/**
		 * The main import file path. This must always be set. 
		 * @param value The desired main import file path. 
		 */
		virtual	void SetImportFilePath( const char * value ) = 0;

		/**
		 * The main import file path. This must always be set. 
		 */
		virtual	spString GetImportFilePath(  ) = 0;

		/**
		 * The imported scene data. 
		 * @return The imported scene data 
		 */
		virtual	spScene GetScene(  ) = 0;

		/**
		 * Runs the import. Note that all parameters must be setup before importing. 
		 */
		virtual	bool RunImport(  ) = 0;

		/**
		 * Close any open file or stream, release any allocated data. 
		 */
		virtual	void Clear(  ) = 0;

	};
	class ISceneNode;

	/**
	 * SelectionSet is a set of scene node GUIDs referencing scene nodes in a scene. 
	 */
	class ISelectionSet : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if ISelectionSet is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("ISelectionSet",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a ISelectionSet 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ISelectionSet pointer 
		 * @return a pointer to the ISelectionSet object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static ISelectionSet *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("ISelectionSet") )
				return static_cast<ISelectionSet*>(ptr);
			return nullptr;
		}
		/**
		 * Adds a node id to the set. 
		 * @param NodeId The node id that is to be added to the set. 
		 */
		virtual	void AddItem( const char * NodeId ) = 0;

		/**
		 * Removes an node id from the set. 
		 * @param NodeId The node id that is to be removed from to the set. 
		 */
		virtual	void RemoveItem( const char * NodeId ) = 0;

		/**
		 * Adds the ids of this node and its children from this selectionset recursively. 
		 * @param node The top node in the hierarchy to add. 
		 */
		virtual	void AddHierarchy( spSceneNode node ) = 0;

		/**
		 * Removes the ids of this node and its children from this selectionset recursively. 
		 * @param node The top node in the hierarchy to remove. 
		 */
		virtual	void RemoveHierarchy( spSceneNode node ) = 0;

		/**
		 * Clears the set. 
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * The number of items in the set. 
		 * @return The number of items in the set. 
		 */
		virtual	unsigned int GetItemCount(  ) = 0;

		/**
		 * Returns the node id in the i:th place in the set. 
		 * @param index The index of the node id to get from the set. 
		 * @return The node id at the specified index. 
		 */
		virtual	spString GetItem( unsigned int index ) = 0;

	};
	class ISelectionSet;

	/**
	 * SelectionSetTable keeps a table of SelectionSet. 
	 */
	class ISelectionSetTable : public ITable
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if ISelectionSetTable is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("ISelectionSetTable",type)==0 )
				return true;
			return ITable::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a ISelectionSetTable 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ISelectionSetTable pointer 
		 * @return a pointer to the ISelectionSetTable object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static ISelectionSetTable *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("ISelectionSetTable") )
				return static_cast<ISelectionSetTable*>(ptr);
			return nullptr;
		}
		/**
		 * Adds a selection set to the table. The returned value is the id of the selection 
		 * set within the table. 
		 * @param selectionSet The selection set to be added. 
		 * @return The id of the added selection set within the table 
		 */
		virtual	rid AddSelectionSet( spSelectionSet selectionSet ) = 0;

		/**
		 * Finds a selection set in the table, using the name. If multiple selection sets 
		 * have the same name, the first match will be returned. If the selection set 
		 * was not found, null will be returned. 
		 * @param name The string to be searched for. 
		 * @return The first matching selection set, or null if no matches are found 
		 */
		virtual	spSelectionSet FindSelectionSet( const char * name ) = 0;

		/**
		 * Finds the id of a selection set in the table, using the name. If multiple selection 
		 * sets have the same name, the first will be returned. If the selection set was 
		 * not found, the return will be -1. 
		 * @param name The string to be searched for. 
		 * @return The id of the first matching selection set, or -1 if no matches are 
		 * found 
		 */
		virtual	rid FindSelectionSetId( const char * name ) = 0;

		/**
		 * Returns the i:th selection set, using the id of the selection set. 
		 * @param id The id of the selection set in the table. 
		 * @return The selection set corresponding to the id 
		 */
		virtual	spSelectionSet GetSelectionSet( rid id ) = 0;

		/**
		 * Removes a selection set from the table by set ID. 
		 * @param id The id of the selection set that is to be removed. 
		 */
		virtual	void RemoveSelectionSet( rid id ) = 0;

		/**
		 * Removes a selection set from the table by name. 
		 * @param name The name of the set to be removed from to the table. 
		 */
		virtual	void RemoveNamedSelectionSet( const char * name ) = 0;

		/**
		 * Returns the number of selection sets in the table. 
		 * @return The number of selection sets in the table 
		 */
		virtual	unsigned int GetSelectionSetCount(  ) = 0;

	};
	class IImageData;

	/**
	 * Texture describes a texture object, containing either image data or a path that 
	 * is referenced by texture nodes in materials. 
	 */
	class ITexture : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if ITexture is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("ITexture",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a ITexture 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ITexture pointer 
		 * @return a pointer to the ITexture object, if the cast can be made, and a NULL 
		 * pointer otherwise 
		 */

		static ITexture *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("ITexture") )
				return static_cast<ITexture*>(ptr);
			return nullptr;
		}
		/**
		 * The file path of the texture. This path has two meanings: It can point to an 
		 * existing file to use as image data for the texture if the image data object 
		 * is not set. If the image data object is set on the texture, it is the path 
		 * to where the image should be saved if the owning scene is exported. If you 
		 * run a pipeline through the batch tool and Simplygon Grid, the returned texture 
		 * object will have the image data embedded in the texture objects and this path 
		 * indicates where it should be saved if the texture are to be stored separately. 
		 * Use ExportImageData() to write out embedded data to the file path, then use 
		 * GetFilePath() to get the final path for the texture image file. 
		 * @param value The path of the texture image data file. 
		 */
		virtual	void SetFilePath( const char * value ) = 0;

		/**
		 * The file path of the texture. This path has two meanings: It can point to an 
		 * existing file to use as image data for the texture if the image data object 
		 * is not set. If the image data object is set on the texture, it is the path 
		 * to where the image should be saved if the owning scene is exported. If you 
		 * run a pipeline through the batch tool and Simplygon Grid, the returned texture 
		 * object will have the image data embedded in the texture objects and this path 
		 * indicates where it should be saved if the texture are to be stored separately. 
		 * Use ExportImageData() to write out embedded data to the file path, then use 
		 * GetFilePath() to get the final path for the texture image file. 
		 */
		virtual	spString GetFilePath(  ) = 0;

		/**
		 * Set/Get a named texture image data. If this is defined, it will be used instead 
		 * of the texture file defined in GetFilePath/SetFilePath(). See the help for 
		 * GetFilePath() for additional information regarding the file path meaning in 
		 * conjunction with embedded image data objects. 
		 * @param value The image data object containing the texture data. 
		 */
		virtual	void SetImageData( spImageData value ) = 0;

		/**
		 * Set/Get a named texture image data. If this is defined, it will be used instead 
		 * of the texture file defined in GetFilePath/SetFilePath(). See the help for 
		 * GetFilePath() for additional information regarding the file path meaning in 
		 * conjunction with embedded image data objects. 
		 */
		virtual	spImageData GetImageData(  ) = 0;

		/**
		 * Changes the prefix path (drive, directory) in the texture, with the new one, 
		 * if the current path matches the current_path_prefix. This method is useful 
		 * when external textures are placed in a specific folder, which needs to be moved. 
		 * @param current_path_prefix The current prefix path, either relative or absolute. 
		 *  
		 * @param new_path_prefix The new prefix path. 
		 */
		virtual	void ChangeTexturePrefixPath( const char * current_path_prefix , const char * new_path_prefix ) = 0;

		/**
		 * Write out the embedded image data to the file indicated by the set file path. 
		 * Once this method returns, use GetFilePath() to get the potentially updated 
		 * final file path used to write the image data file. 
		 * @return true if the export was successful, false if not. 
		 */
		virtual	bool ExportImageData(  ) = 0;

	};
	class ITexture;

	/**
	 * TextureTable keeps information on textures used while rendering. 
	 */
	class ITextureTable : public ITable
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if ITextureTable is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("ITextureTable",type)==0 )
				return true;
			return ITable::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a ITextureTable 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ITextureTable pointer 
		 * @return a pointer to the ITextureTable object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static ITextureTable *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("ITextureTable") )
				return static_cast<ITextureTable*>(ptr);
			return nullptr;
		}
		/**
		 * Adds a texture to the table. The returned value is the id of the texture within 
		 * the table. 
		 * @param texture The texture to add into the table. 
		 * @return the texture id of the texture in the table 
		 */
		virtual	rid AddTexture( spTexture texture ) = 0;

		/**
		 * Finds a texture in the table, using the texture name. If multiple textures 
		 * have the same name, the first will be returned. If the texture was not found, 
		 * null will be returned. 
		 * @param name The texture name to look for. 
		 * @return the texture if found, null otherwise 
		 */
		virtual	spTexture FindTexture( const char * name ) = 0;

		/**
		 * Finds a texture in the table, using the texture path. If multiple textures 
		 * have the same path, the first will be returned. If the texture was not found, 
		 * null will be returned. 
		 * @param path Is the texture path. 
		 * @return the texture if found, null otherwise 
		 */
		virtual	spTexture FindTextureUsingPath( const char * path ) = 0;

		/**
		 * Finds the id of a texture in the table, using the texture name. If multiple 
		 * textures have the same name, the first will be returned. If the texture was 
		 * not found, -1 will be returned. 
		 * @param name The texture name to look for. 
		 * @return the texture id if found, -1 otherwise 
		 */
		virtual	rid FindTextureId( const char * name ) = 0;

		/**
		 * Sets a texture in the table. 
		 * @param id The id of the texture in the table. 
		 * @param texture The texture to set into the table. 
		 */
		virtual	void SetTexture( rid id , spTexture texture ) = 0;

		/**
		 * Returns the i:th texture, using the id of the texture. 
		 * @param id The id of the texture in the table. 
		 * @return the the texture in the table 
		 */
		virtual	spTexture GetTexture( rid id ) = 0;

		/**
		 * Removes a texture. If GetTexture is called with the texture id, the value returned 
		 * will be null. 
		 * @param id The id of the texture in the table. 
		 */
		virtual	void RemoveTexture( rid id ) = 0;

		/**
		 * Returns the number of textures in the table. 
		 */
		virtual	unsigned int GetTexturesCount(  ) = 0;

		/**
		 * Changes the prefix path (drive, directory) of all matching texture paths in 
		 * all the textures in the table, with the new one. This method is useful when 
		 * external textures are placed in a specific folder, which needs to be moved. 
		 * @param current_path_prefix The current prefix path, either relative or absolute. 
		 *  
		 * @param new_path_prefix The new prefix path. 
		 */
		virtual	void ChangeTexturePrefixPath( const char * current_path_prefix , const char * new_path_prefix ) = 0;

	};

	/**
	 * Settings for volumetric triangle culling functionality. These settings control 
	 * the clipping planes and geometries that are used for triangle culling the output 
	 * of Simplygon scene processors. 
	 */
	class IGeometryCullingSettings : public ISettingsObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IGeometryCullingSettings is a or is a 
		 * descendant of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IGeometryCullingSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IGeometryCullingSettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IGeometryCullingSettings pointer 
		 * @return a pointer to the IGeometryCullingSettings object, if the cast can be 
		 * made, and a NULL pointer otherwise 
		 */

		static IGeometryCullingSettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IGeometryCullingSettings") )
				return static_cast<IGeometryCullingSettings*>(ptr);
			return nullptr;
		}
		/**
		 * If true the ScenePlanes in the input scene (or the planes selected by the selection 
		 * set settings) will be used to clip the mesh. 
		 * @param value The bool UseClippingPlanes will be set to. 
		 */
		virtual	void SetUseClippingPlanes( bool value ) = 0;

		/**
		 * If true the ScenePlanes in the input scene (or the planes selected by the selection 
		 * set settings) will be used to clip the mesh. 
		 */
		virtual	bool GetUseClippingPlanes(  ) = 0;

		/**
		 * If set, the geometries defined in the matching selection set will be used to 
		 * clip the process geometry. What side of the geometry that will be culled is 
		 * determined by the triangle facing, so make sure your winding is correct and 
		 * that triangles point "up" toward the space you want to keep. Inconsistent triangle 
		 * winding or meshes that do not have a clear local inside and outside will cause 
		 * inconsistent results when used as clipping geometries. 
		 * @param value The bool UseClippingGeometry will be set to. 
		 */
		virtual	void SetUseClippingGeometry( bool value ) = 0;

		/**
		 * If set, the geometries defined in the matching selection set will be used to 
		 * clip the process geometry. What side of the geometry that will be culled is 
		 * determined by the triangle facing, so make sure your winding is correct and 
		 * that triangles point "up" toward the space you want to keep. Inconsistent triangle 
		 * winding or meshes that do not have a clear local inside and outside will cause 
		 * inconsistent results when used as clipping geometries. 
		 */
		virtual	bool GetUseClippingGeometry(  ) = 0;

		/**
		 * Which SelectionSet containing sceneplanes will be used for clipping. Set name 
		 * is prioritized over id if both are set. 
		 * @param value The desired SelectionSet id. Value cannot be less than -1. 
		 */
		virtual	void SetClippingPlaneSelectionSetID( rid value ) = 0;

		/**
		 * Which SelectionSet containing sceneplanes will be used for clipping. Set name 
		 * is prioritized over id if both are set. 
		 */
		virtual	rid GetClippingPlaneSelectionSetID(  ) = 0;

		/**
		 * Which SelectionSet containing sceneplanes will be used for clipping. Set name 
		 * is prioritized over id if both are set. 
		 * @param value The desired SelectionSet name. 
		 */
		virtual	void SetClippingPlaneSelectionSetName( const char * value ) = 0;

		/**
		 * Which SelectionSet containing sceneplanes will be used for clipping. Set name 
		 * is prioritized over id if both are set. 
		 */
		virtual	spString GetClippingPlaneSelectionSetName(  ) = 0;

		/**
		 * Which SelectionSet containing geometries will be used for clipping. Set name 
		 * is prioritized over id if both are set. 
		 * @param value The desired SelectionSet id. Value cannot be less than -1. 
		 */
		virtual	void SetClippingGeometrySelectionSetID( rid value ) = 0;

		/**
		 * Which SelectionSet containing geometries will be used for clipping. Set name 
		 * is prioritized over id if both are set. 
		 */
		virtual	rid GetClippingGeometrySelectionSetID(  ) = 0;

		/**
		 * Which SelectionSet containing geometries will be used for clipping. Set name 
		 * is prioritized over id if both are set. 
		 * @param value The desired SelectionSet name. 
		 */
		virtual	void SetClippingGeometrySelectionSetName( const char * value ) = 0;

		/**
		 * Which SelectionSet containing geometries will be used for clipping. Set name 
		 * is prioritized over id if both are set. 
		 */
		virtual	spString GetClippingGeometrySelectionSetName(  ) = 0;

	};
	class IImageData;

	/**
	 * Class for loading image data from different file formats. 
	 */
	class IImageDataImporter : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IImageDataImporter is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IImageDataImporter",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IImageDataImporter 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IImageDataImporter pointer 
		 * @return a pointer to the IImageDataImporter object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IImageDataImporter *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IImageDataImporter") )
				return static_cast<IImageDataImporter*>(ptr);
			return nullptr;
		}
		/**
		 * The main import file path. This must always be set. 
		 * @param value The desired main import file path. 
		 */
		virtual	void SetImportFilePath( const char * value ) = 0;

		/**
		 * The main import file path. This must always be set. 
		 */
		virtual	spString GetImportFilePath(  ) = 0;

		/**
		 * The override file extension. This is specified including the dot, eg ".tga". 
		 * @param value The desired override file extension. 
		 */
		virtual	void SetExtensionOverride( const char * value ) = 0;

		/**
		 * The override file extension. This is specified including the dot, eg ".tga". 
		 *  
		 */
		virtual	spString GetExtensionOverride(  ) = 0;

		/**
		 * The imported image data. 
		 * @return The imported image data 
		 */
		virtual	spImageData GetImage(  ) = 0;

		/**
		 * Set/Get CapToPowerOfTwo. If set, the width and height of the loaded image will 
		 * be capped to the closest power of two below the size of the image. 
		 * @param value The desired CapToPowerOfTwo flag. 
		 */
		virtual	void SetCapToPowerOfTwo( bool value ) = 0;

		/**
		 * Set/Get CapToPowerOfTwo. If set, the width and height of the loaded image will 
		 * be capped to the closest power of two below the size of the image. 
		 */
		virtual	bool GetCapToPowerOfTwo(  ) = 0;

		/**
		 * Set/Get MaxWidth. If set to a value above 0, the image that is wider will be 
		 * rescaled to MaxWidth. 
		 * @param value The desired MaxWidth. 
		 */
		virtual	void SetMaxWidth( unsigned int value ) = 0;

		/**
		 * Set/Get MaxWidth. If set to a value above 0, the image that is wider will be 
		 * rescaled to MaxWidth. 
		 */
		virtual	unsigned int GetMaxWidth(  ) = 0;

		/**
		 * Set/Get MaxHeight. If set to a value above 0, the image that is higher will 
		 * be rescaled to MaxHeight. 
		 * @param value The desired MaxHeight. 
		 */
		virtual	void SetMaxHeight( unsigned int value ) = 0;

		/**
		 * Set/Get MaxHeight. If set to a value above 0, the image that is higher will 
		 * be rescaled to MaxHeight. 
		 */
		virtual	unsigned int GetMaxHeight(  ) = 0;

		/**
		 * Set/Get ImportOnlyHeader. If set to true only gets header information from 
		 * the image, and does not load the actual file into memory. 
		 * @param value The desired ImportOnlyHeader value. 
		 */
		virtual	void SetImportOnlyHeader( bool value ) = 0;

		/**
		 * Set/Get ImportOnlyHeader. If set to true only gets header information from 
		 * the image, and does not load the actual file into memory. 
		 */
		virtual	bool GetImportOnlyHeader(  ) = 0;

		/**
		 * After RunImport(), returns the NumberOfChannels (1, 3, 4) in the source image. 
		 * @return The current NumberOfChannels 
		 */
		virtual	unsigned int GetNumberOfChannels(  ) = 0;

		/**
		 * After RunImport(), returns the BitsPerPixel (8bpp-64bpp). If divided by NumberOfChannels, 
		 * will give the number of bits per channel. 
		 * @return The current BitsPerPixel 
		 */
		virtual	unsigned int GetBitsPerPixel(  ) = 0;

		/**
		 * Return the format of the image. 
		 * @return The current image file format 
		 */
		virtual	Simplygon::EImageInputFormat GetImageFileFormat(  ) = 0;

		/**
		 * Runs the import. Note that all parameters must be setup before importing. 
		 */
		virtual	bool RunImport(  ) = 0;

		/**
		 * Close any open file or stream, release any allocated data. 
		 */
		virtual	void Clear(  ) = 0;

	};

	/**
	 * MappingImageMeshData stores the mapped meshes and their paths in the original 
	 * scene. This can be used to find a specific triangle on the original mesh in 
	 * the scene from the combined id in the mapping image. 
	 */
	class IMappingImageMeshData : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IMappingImageMeshData is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IMappingImageMeshData",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IMappingImageMeshData 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IMappingImageMeshData pointer 
		 * @return a pointer to the IMappingImageMeshData object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IMappingImageMeshData *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IMappingImageMeshData") )
				return static_cast<IMappingImageMeshData*>(ptr);
			return nullptr;
		}
		/**
		 * The MappedGeometriesCount, the number of mapped geometries. 
		 * @return The number of mapped geometries in the mapping image 
		 */
		virtual	unsigned int GetMappedGeometriesCount(  ) = 0;

		/**
		 * The Id of the first triangle of the geometry at the specified index. 
		 * @param GeometryIndex The index of the geometry in the list of mapped geometries. 
		 *  
		 * @return The start triangle id of the geometry 
		 */
		virtual	rid GetStartTriangleIdOfGeometry( rid GeometryIndex ) = 0;

		/**
		 * The mesh path in the scene of the geometry at the specified index. 
		 * @param GeometryIndex The index of the geometry in the list of mapped geometries. 
		 *  
		 * @return The path in the scene of the mesh that has this geometry 
		 */
		virtual	spString GetScenePathOfGeometry( rid GeometryIndex ) = 0;

		/**
		 * The node guid containing the original geometry. 
		 * @param GeometryIndex Is index of the geometry in the list of mapped geometries. 
		 *  
		 * @return The guid 
		 */
		virtual	spString GetNodeGuidOfGeometry( rid GeometryIndex ) = 0;

		/**
		 * Clear the MappingImageMeshData. 
		 */
		virtual	void Clear(  ) = 0;

	};

	/**
	 * ShadingNode is the parent of all nodes in a shading network. 
	 */
	class IShadingNode : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShadingNode is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShadingNode",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingNode 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingNode pointer 
		 * @return a pointer to the IShadingNode object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static IShadingNode *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShadingNode") )
				return static_cast<IShadingNode*>(ptr);
			return nullptr;
		}
		/**
		 * The input count. 
		 * @return The input count 
		 */
		virtual	unsigned int GetParameterCount(  ) = 0;

		/**
		 * The name of a parameter. 
		 * @param parameter_id The id of the input to fetch the name of. 
		 * @return The name of the parameter 
		 */
		virtual	spString GetParameterName( rid parameter_id ) = 0;

		/**
		 * The default parameter values. 
		 * @param parameter_id The id of the input to be set. 
		 * @param r The value of red to which the default input will be set. 
		 * @param g The value of green to which the default input will be set. 
		 * @param b The value of blue to which the default input will be set. 
		 * @param a The value of alpha to which the default input will be set. 
		 */
		virtual	void SetDefaultParameter( rid parameter_id , real r , real g , real b , real a ) = 0;

		/**
		 * The default parameter values. 
		 * @param parameter_id The id of the input to be fetched. 
		 * @return The Red default parameter value 
		 */
		virtual	real GetDefaultParameterRed( rid parameter_id ) = 0;

		/**
		 * The default parameter values. 
		 * @param parameter_id The id of the input to be fetched. 
		 * @return The Green default parameter value 
		 */
		virtual	real GetDefaultParameterGreen( rid parameter_id ) = 0;

		/**
		 * The default parameter values. 
		 * @param parameter_id The id of the input to be fetched. 
		 * @return The Blue default parameter value 
		 */
		virtual	real GetDefaultParameterBlue( rid parameter_id ) = 0;

		/**
		 * The default parameter values. 
		 * @param parameter_id The id of the input to be fetched. 
		 * @return The Alpha default parameter value 
		 */
		virtual	real GetDefaultParameterAlpha( rid parameter_id ) = 0;

	};
	class IShadingNode;

	/**
	 * FilterNode is the parent of all non-source nodes in a shading network. 
	 */
	class IShadingFilterNode : public IShadingNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShadingFilterNode is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShadingFilterNode",type)==0 )
				return true;
			return IShadingNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingFilterNode 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingFilterNode pointer 
		 * @return a pointer to the IShadingFilterNode object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IShadingFilterNode *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShadingFilterNode") )
				return static_cast<IShadingFilterNode*>(ptr);
			return nullptr;
		}
		/**
		 * The default node inputs. 
		 * @param input_id The id of the input to be set. 
		 * @param input_node The node to be set as input. 
		 */
		virtual	bool SetInput( rid input_id , spShadingNode input_node ) = 0;

		/**
		 * The default node inputs. 
		 * @param input_id The id of the input to be fetched. 
		 * @return The input node 
		 */
		virtual	spShadingNode GetInput( rid input_id ) = 0;

		/**
		 * Get if the parameter is inputable. If true, a different node can be set as 
		 * this parameters value. If false, the parameter can only be set manually and 
		 * not through a node input. 
		 * @param param_id The id of the parameter to be checked. 
		 * @return True if parameter is inputable, false if it is not 
		 */
		virtual	bool GetParameterIsInputable( rid param_id ) = 0;

	};

	/**
	 * TextureNode describes a texture source node in a shading network. 
	 */
	class IShadingTextureNode : public IShadingNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShadingTextureNode is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShadingTextureNode",type)==0 )
				return true;
			return IShadingNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingTextureNode 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingTextureNode pointer 
		 * @return a pointer to the IShadingTextureNode object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IShadingTextureNode *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShadingTextureNode") )
				return static_cast<IShadingTextureNode*>(ptr);
			return nullptr;
		}
		/**
		 * The name of the texture in the texture table used for casting. If both this 
		 * and texture image is set, the casting uses the texture image. 
		 * @param value The path the texture will be read from. 
		 */
		virtual	void SetTextureName( const char * value ) = 0;

		/**
		 * The name of the texture in the texture table used for casting. If both this 
		 * and texture image is set, the casting uses the texture image. 
		 */
		virtual	spString GetTextureName(  ) = 0;

		/**
		 * The name of the texture coordinate. If not set, the material uses the texture 
		 * level (index) instead. The TexCoordName is required when generating shader 
		 * data. 
		 * @param value The desired texture level name. 
		 */
		virtual	void SetTexCoordName( const char * value ) = 0;

		/**
		 * The name of the texture coordinate. If not set, the material uses the texture 
		 * level (index) instead. The TexCoordName is required when generating shader 
		 * data. 
		 */
		virtual	spString GetTexCoordName(  ) = 0;

		/**
		 * The texture texture coordinate level. The texture level is used during casting 
		 * if the TexCoordName has not been set. Setting the TexCoordName is still required 
		 * for generating shader code. 
		 * @param value The desired texture level. 
		 */
		virtual	void SetTexCoordLevel( int value ) = 0;

		/**
		 * The texture texture coordinate level. The texture level is used during casting 
		 * if the TexCoordName has not been set. Setting the TexCoordName is still required 
		 * for generating shader code. 
		 */
		virtual	int GetTexCoordLevel(  ) = 0;

		/**
		 * The use of sRGB when decoding the texture into an RGBA value. 
		 * @param value The flag to use sRGB. 
		 */
		virtual	void SetUseSRGB( bool value ) = 0;

		/**
		 * The use of sRGB when decoding the texture into an RGBA value. 
		 */
		virtual	bool GetUseSRGB(  ) = 0;

		/**
		 * The TileU value, which is multiplied into the U-coordinate when sampling. 
		 * @param value The new value. 
		 */
		virtual	void SetTileU( real value ) = 0;

		/**
		 * The TileU value, which is multiplied into the U-coordinate when sampling. 
		 */
		virtual	real GetTileU(  ) = 0;

		/**
		 * The TileV value, which is multiplied into the U-coordinate when sampling. 
		 * @param value The new value. 
		 */
		virtual	void SetTileV( real value ) = 0;

		/**
		 * The TileV value, which is multiplied into the U-coordinate when sampling. 
		 */
		virtual	real GetTileV(  ) = 0;

		/**
		 * The OffsetU value, which is will be added to the U-coordinate when sampling. 
		 * @param value The new value. 
		 */
		virtual	void SetOffsetU( real value ) = 0;

		/**
		 * The OffsetU value, which is will be added to the U-coordinate when sampling. 
		 *  
		 */
		virtual	real GetOffsetU(  ) = 0;

		/**
		 * The OffsetV value, which is will be added to the V-coordinate when sampling. 
		 * @param value The new value. 
		 */
		virtual	void SetOffsetV( real value ) = 0;

		/**
		 * The OffsetV value, which is will be added to the V-coordinate when sampling. 
		 *  
		 */
		virtual	real GetOffsetV(  ) = 0;

		/**
		 * The texture wrap mode in both U and V direction, which determines what happens 
		 * to texture samples outside the 0-1 range. Setting this property affects both 
		 * U and V direction, and getting this property returns the wrap mode in U direction 
		 * in the case when they are different. 
		 * @param value The new texture wrap mode. 
		 */
		virtual	void SetTextureWrapMode( Simplygon::ETextureWrapMode value ) = 0;

		/**
		 * The texture wrap mode in both U and V direction, which determines what happens 
		 * to texture samples outside the 0-1 range. Setting this property affects both 
		 * U and V direction, and getting this property returns the wrap mode in U direction 
		 * in the case when they are different. 
		 */
		virtual	Simplygon::ETextureWrapMode GetTextureWrapMode(  ) = 0;

		/**
		 * The texture wrap mode in U direction, which determines what happens to texture 
		 * samples outside the 0-1 range. 
		 * @param value The new texture wrap mode in U direction. 
		 */
		virtual	void SetTextureWrapModeU( Simplygon::ETextureWrapMode value ) = 0;

		/**
		 * The texture wrap mode in U direction, which determines what happens to texture 
		 * samples outside the 0-1 range. 
		 */
		virtual	Simplygon::ETextureWrapMode GetTextureWrapModeU(  ) = 0;

		/**
		 * The texture wrap mode in V direction, which determines what happens to texture 
		 * samples outside the 0-1 range. 
		 * @param value The new texture wrap mode in V direction. 
		 */
		virtual	void SetTextureWrapModeV( Simplygon::ETextureWrapMode value ) = 0;

		/**
		 * The texture wrap mode in V direction, which determines what happens to texture 
		 * samples outside the 0-1 range. 
		 */
		virtual	Simplygon::ETextureWrapMode GetTextureWrapModeV(  ) = 0;

		/**
		 * The rotation value, which is used to rotate the UV coordinates when sampling. 
		 * @param value The rotation value. 
		 */
		virtual	void SetRotation( real value ) = 0;

		/**
		 * The rotation value, which is used to rotate the UV coordinates when sampling. 
		 *  
		 */
		virtual	real GetRotation(  ) = 0;

	};

	/**
	 * SwizzlingNode describes a node that can remap the input to the specified output. 
	 */
	class IShadingSwizzlingNode : public IShadingFilterNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShadingSwizzlingNode is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShadingSwizzlingNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingSwizzlingNode 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingSwizzlingNode pointer 
		 * @return a pointer to the IShadingSwizzlingNode object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IShadingSwizzlingNode *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShadingSwizzlingNode") )
				return static_cast<IShadingSwizzlingNode*>(ptr);
			return nullptr;
		}
		/**
		 * The component index in the input color that Red component will be copied from. 
		 * @param value The input component index. Allowed values are 0:R 1:G 2:B 3:A. 
		 * Value cannot be less than 0. Value cannot be greater than 3. 
		 */
		virtual	void SetRedComponent( unsigned int value ) = 0;

		/**
		 * The component index in the input color that Red component will be copied from. 
		 *  
		 */
		virtual	unsigned int GetRedComponent(  ) = 0;

		/**
		 * The component index in the input color that Green component will be copied 
		 * from. 
		 * @param value The input component index. Allowed values are 0:R 1:G 2:B 3:A. 
		 * Value cannot be less than 0. Value cannot be greater than 3. 
		 */
		virtual	void SetGreenComponent( unsigned int value ) = 0;

		/**
		 * The component index in the input color that Green component will be copied 
		 * from. 
		 */
		virtual	unsigned int GetGreenComponent(  ) = 0;

		/**
		 * The component index in the input color that Blue component will be copied from. 
		 * @param value The input component index. Allowed values are 0:R 1:G 2:B 3:A. 
		 * Value cannot be less than 0. Value cannot be greater than 3. 
		 */
		virtual	void SetBlueComponent( unsigned int value ) = 0;

		/**
		 * The component index in the input color that Blue component will be copied from. 
		 *  
		 */
		virtual	unsigned int GetBlueComponent(  ) = 0;

		/**
		 * The component index in the input color that Alpha component will be copied 
		 * from. 
		 * @param value The input component index. Allowed values are 0:R 1:G 2:B 3:A. 
		 * Value cannot be less than 0. Value cannot be greater than 3. 
		 */
		virtual	void SetAlphaComponent( unsigned int value ) = 0;

		/**
		 * The component index in the input color that Alpha component will be copied 
		 * from. 
		 */
		virtual	unsigned int GetAlphaComponent(  ) = 0;

	};

	/**
	 * ColorNode describes a single color source node in a shading network 
	 */
	class IShadingColorNode : public IShadingNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShadingColorNode is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShadingColorNode",type)==0 )
				return true;
			return IShadingNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingColorNode 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingColorNode pointer 
		 * @return a pointer to the IShadingColorNode object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IShadingColorNode *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShadingColorNode") )
				return static_cast<IShadingColorNode*>(ptr);
			return nullptr;
		}
		/**
		 * The color value. 
		 * @param r The desired value of the red channel. 
		 * @param g The desired value of the green channel. 
		 * @param b The desired value of the blue channel. 
		 * @param a The desired value of the alpha channel. 
		 */
		virtual	void SetColor( real r , real g , real b , real a ) = 0;

	};

	/**
	 * AddNode describes a single addition shading node in a shading network. Input 
	 * 1 and 2 are added per-component to produce the output. 
	 */
	class IShadingAddNode : public IShadingFilterNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShadingAddNode is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShadingAddNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingAddNode 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingAddNode pointer 
		 * @return a pointer to the IShadingAddNode object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static IShadingAddNode *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShadingAddNode") )
				return static_cast<IShadingAddNode*>(ptr);
			return nullptr;
		}
	};

	/**
	 * SubtractNode describes a single subtracting shading node in a shading network. 
	 * Input 2 is subtracted from input 1 per-component. 
	 */
	class IShadingSubtractNode : public IShadingFilterNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShadingSubtractNode is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShadingSubtractNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingSubtractNode 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingSubtractNode pointer 
		 * @return a pointer to the IShadingSubtractNode object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IShadingSubtractNode *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShadingSubtractNode") )
				return static_cast<IShadingSubtractNode*>(ptr);
			return nullptr;
		}
	};

	/**
	 * MultiplyNode describes a single multiplying shading node in a shading network. 
	 * Input 1 and Input 2 is multiplied per-component. 
	 */
	class IShadingMultiplyNode : public IShadingFilterNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShadingMultiplyNode is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShadingMultiplyNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingMultiplyNode 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingMultiplyNode pointer 
		 * @return a pointer to the IShadingMultiplyNode object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IShadingMultiplyNode *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShadingMultiplyNode") )
				return static_cast<IShadingMultiplyNode*>(ptr);
			return nullptr;
		}
	};

	/**
	 * This node describes an exponentiation. The output will be Input 1 to the power 
	 * of Input 2, and it is calculated per-component. 
	 */
	class IShadingPowNode : public IShadingFilterNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShadingPowNode is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShadingPowNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingPowNode 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingPowNode pointer 
		 * @return a pointer to the IShadingPowNode object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static IShadingPowNode *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShadingPowNode") )
				return static_cast<IShadingPowNode*>(ptr);
			return nullptr;
		}
	};

	/**
	 * DivideNode describes a single division shading node node in a shading network. 
	 * Input 1 is divided by Input 2 per-component to produce the output. 
	 */
	class IShadingDivideNode : public IShadingFilterNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShadingDivideNode is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShadingDivideNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingDivideNode 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingDivideNode pointer 
		 * @return a pointer to the IShadingDivideNode object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IShadingDivideNode *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShadingDivideNode") )
				return static_cast<IShadingDivideNode*>(ptr);
			return nullptr;
		}
	};

	/**
	 * ClampNode describes a single clamp shading node in a shading network. Input 
	 * 1 is clamped per-component between Input 2 and 3. 
	 */
	class IShadingClampNode : public IShadingFilterNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShadingClampNode is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShadingClampNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingClampNode 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingClampNode pointer 
		 * @return a pointer to the IShadingClampNode object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IShadingClampNode *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShadingClampNode") )
				return static_cast<IShadingClampNode*>(ptr);
			return nullptr;
		}
	};

	/**
	 * MaxNode describes a single max shading node in a shading network. The output 
	 * has the per-channel max values of the two inputs. 
	 */
	class IShadingMaxNode : public IShadingFilterNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShadingMaxNode is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShadingMaxNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingMaxNode 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingMaxNode pointer 
		 * @return a pointer to the IShadingMaxNode object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static IShadingMaxNode *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShadingMaxNode") )
				return static_cast<IShadingMaxNode*>(ptr);
			return nullptr;
		}
	};

	/**
	 * MinNode describes a single min shading node in a shading network. The output 
	 * has the per-channel min values of the two inputs. 
	 */
	class IShadingMinNode : public IShadingFilterNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShadingMinNode is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShadingMinNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingMinNode 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingMinNode pointer 
		 * @return a pointer to the IShadingMinNode object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static IShadingMinNode *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShadingMinNode") )
				return static_cast<IShadingMinNode*>(ptr);
			return nullptr;
		}
	};

	/**
	 * StepNode describes a single step shading node, where the per-component output 
	 * is either 1 or 0 depending on if input0 is larger or smaller than input1. Basically, 
	 * (Input0 >= Input1) ? 1 : 0 
	 */
	class IShadingStepNode : public IShadingFilterNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShadingStepNode is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShadingStepNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingStepNode 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingStepNode pointer 
		 * @return a pointer to the IShadingStepNode object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IShadingStepNode *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShadingStepNode") )
				return static_cast<IShadingStepNode*>(ptr);
			return nullptr;
		}
	};

	/**
	 * ShadingEqualNode describes an "is equal to" operator, where the per-component 
	 * output is either 1 or 0 depending on if input0 is equal to input1. Basically, 
	 * (Input0 == Input1) ? 1 : 0 
	 */
	class IShadingEqualNode : public IShadingFilterNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShadingEqualNode is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShadingEqualNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingEqualNode 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingEqualNode pointer 
		 * @return a pointer to the IShadingEqualNode object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IShadingEqualNode *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShadingEqualNode") )
				return static_cast<IShadingEqualNode*>(ptr);
			return nullptr;
		}
	};

	/**
	 * NotEqualNode describes the "is not equal" operator, where the per-component 
	 * output is either 1 or 0 depending on if input0 is equal to input1. Basically, 
	 * (Input0 != Input1) ? 1 : 0 
	 */
	class IShadingNotEqualNode : public IShadingFilterNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShadingNotEqualNode is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShadingNotEqualNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingNotEqualNode 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingNotEqualNode pointer 
		 * @return a pointer to the IShadingNotEqualNode object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IShadingNotEqualNode *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShadingNotEqualNode") )
				return static_cast<IShadingNotEqualNode*>(ptr);
			return nullptr;
		}
	};

	/**
	 * VertexColorNode describes a vertex color source node in a shading network. 
	 */
	class IShadingVertexColorNode : public IShadingNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShadingVertexColorNode is a or is a 
		 * descendant of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShadingVertexColorNode",type)==0 )
				return true;
			return IShadingNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingVertexColorNode 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingVertexColorNode pointer 
		 * @return a pointer to the IShadingVertexColorNode object, if the cast can be 
		 * made, and a NULL pointer otherwise 
		 */

		static IShadingVertexColorNode *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShadingVertexColorNode") )
				return static_cast<IShadingVertexColorNode*>(ptr);
			return nullptr;
		}
		/**
		 * The vertex color index. This is the vertex color field in the geometry which 
		 * will be used for casting with this node. 
		 * @param value Vertex color index which will be used. 
		 */
		virtual	void SetVertexColorIndex( rid value ) = 0;

		/**
		 * The vertex color index. This is the vertex color field in the geometry which 
		 * will be used for casting with this node. 
		 */
		virtual	rid GetVertexColorIndex(  ) = 0;

		/**
		 * The vertex color set. This is the vertex color field in the geometry which 
		 * will be used for casting with this node. 
		 * @param value Vertex color set which will be used. 
		 */
		virtual	void SetVertexColorSet( const char * value ) = 0;

		/**
		 * The vertex color set. This is the vertex color field in the geometry which 
		 * will be used for casting with this node. 
		 */
		virtual	spString GetVertexColorSet(  ) = 0;

	};

	/**
	 * InterpolateNode describes a single interpolating shading node node in a shading 
	 * network. Input 1 and Input 2 is interpolated per-component using Input 3. Blend 
	 * values below 0 and over 1 will be clamped. 
	 */
	class IShadingInterpolateNode : public IShadingFilterNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShadingInterpolateNode is a or is a 
		 * descendant of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShadingInterpolateNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingInterpolateNode 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingInterpolateNode pointer 
		 * @return a pointer to the IShadingInterpolateNode object, if the cast can be 
		 * made, and a NULL pointer otherwise 
		 */

		static IShadingInterpolateNode *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShadingInterpolateNode") )
				return static_cast<IShadingInterpolateNode*>(ptr);
			return nullptr;
		}
	};
	class IShadingColor;

	/**
	 * CustomNode describes a custom shading node in a shading network. The output 
	 * is produced based on customizable user specified operations. The custom node 
	 * has a user specified amount of input parameters. Use SetInputCount() to specify 
	 * the number of inputs. The user has to assign and implement event handlers (called 
	 * observers) for the custom node to be able to evaluate to colors. See CustomNodeExample 
	 * and API documentation for further explanations and code samples. 
	 */
	class IShadingCustomNode : public IShadingFilterNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShadingCustomNode is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShadingCustomNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingCustomNode 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingCustomNode pointer 
		 * @return a pointer to the IShadingCustomNode object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IShadingCustomNode *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShadingCustomNode") )
				return static_cast<IShadingCustomNode*>(ptr);
			return nullptr;
		}
		/**
		 * The number of inputs for this custom node. 
		 * @param value The number of inputs for this custom node. 
		 */
		virtual	void SetInputCount( unsigned int value ) = 0;

		/**
		 * The number of inputs for this custom node. 
		 */
		virtual	unsigned int GetInputCount(  ) = 0;

		/**
		 * Get color value from node input index. 
		 * @param value Index of node inputs. 
		 */
		virtual	ShadingColor GetInputValue( unsigned int value ) = 0;

		/**
		 * Set custom shader code from OnShadingCustomNodeGenerateShaderCode observer 
		 * method. 
		 * @param value Custom shader code. 
		 */
		virtual	void SetCustomShaderCode( const char * value ) = 0;

	};

	/**
	 * LayeredBlendNode is a node with an arbitrary number of inputs that can be blended 
	 * differently. 
	 */
	class IShadingLayeredBlendNode : public IShadingFilterNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShadingLayeredBlendNode is a or is a 
		 * descendant of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShadingLayeredBlendNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingLayeredBlendNode 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingLayeredBlendNode pointer 
		 * @return a pointer to the IShadingLayeredBlendNode object, if the cast can be 
		 * made, and a NULL pointer otherwise 
		 */

		static IShadingLayeredBlendNode *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShadingLayeredBlendNode") )
				return static_cast<IShadingLayeredBlendNode*>(ptr);
			return nullptr;
		}
		/**
		 * The number of inputs for this node. 
		 * @param value The number of inputs for this node. Value cannot be less than 
		 * 0. Value cannot be greater than SG_NUM_SUPPORTED_CUSTOM_NODE_INPUTS. 
		 */
		virtual	void SetInputCount( unsigned int value ) = 0;

		/**
		 * The number of inputs for this node. 
		 */
		virtual	unsigned int GetInputCount(  ) = 0;

		/**
		 * The blend type per input connection. 
		 * @param _input The input index. 
		 * @param _blendType The blend type to use. 
		 */
		virtual	void SetPerInputBlendType( int _input , Simplygon::ETextureBlendType _blendType ) = 0;

		/**
		 * The blend type per input connection. 
		 * @param _input The input index. 
		 * @return The input blend type 
		 */
		virtual	Simplygon::ETextureBlendType GetPerInputBlendType( int _input ) = 0;

	};

	/**
	 * This node describes an normalization of the x,y,z components of the input. 
	 */
	class IShadingNormalize3Node : public IShadingFilterNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShadingNormalize3Node is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShadingNormalize3Node",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingNormalize3Node 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingNormalize3Node pointer 
		 * @return a pointer to the IShadingNormalize3Node object, if the cast can be 
		 * made, and a NULL pointer otherwise 
		 */

		static IShadingNormalize3Node *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShadingNormalize3Node") )
				return static_cast<IShadingNormalize3Node*>(ptr);
			return nullptr;
		}
	};

	/**
	 * This node describes a square root calculation. The output will be the per-component 
	 * square root of input 1 
	 */
	class IShadingSqrtNode : public IShadingFilterNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShadingSqrtNode is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShadingSqrtNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingSqrtNode 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingSqrtNode pointer 
		 * @return a pointer to the IShadingSqrtNode object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IShadingSqrtNode *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShadingSqrtNode") )
				return static_cast<IShadingSqrtNode*>(ptr);
			return nullptr;
		}
	};

	/**
	 * This node describes an dot of the x,y,z components of the inputs. 
	 */
	class IShadingDot3Node : public IShadingFilterNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShadingDot3Node is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShadingDot3Node",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingDot3Node 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingDot3Node pointer 
		 * @return a pointer to the IShadingDot3Node object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IShadingDot3Node *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShadingDot3Node") )
				return static_cast<IShadingDot3Node*>(ptr);
			return nullptr;
		}
	};

	/**
	 * This node describes the cross of the x,y,z components of the input. 
	 */
	class IShadingCross3Node : public IShadingFilterNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShadingCross3Node is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShadingCross3Node",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingCross3Node 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingCross3Node pointer 
		 * @return a pointer to the IShadingCross3Node object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IShadingCross3Node *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShadingCross3Node") )
				return static_cast<IShadingCross3Node*>(ptr);
			return nullptr;
		}
	};

	/**
	 * This node describes cosine of the x,y,z,w components of the input. 
	 */
	class IShadingCosNode : public IShadingFilterNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShadingCosNode is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShadingCosNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingCosNode 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingCosNode pointer 
		 * @return a pointer to the IShadingCosNode object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static IShadingCosNode *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShadingCosNode") )
				return static_cast<IShadingCosNode*>(ptr);
			return nullptr;
		}
	};

	/**
	 * This node describes Sin of the x,y,z components of the input. 
	 */
	class IShadingSinNode : public IShadingFilterNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShadingSinNode is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShadingSinNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingSinNode 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingSinNode pointer 
		 * @return a pointer to the IShadingSinNode object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static IShadingSinNode *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShadingSinNode") )
				return static_cast<IShadingSinNode*>(ptr);
			return nullptr;
		}
	};

	/**
	 * GreaterThanNode describes the "is greater than" operator, where the per-component 
	 * output is either 1 or 0 depending on if input0 is greater than input1. Basically, 
	 * (Input0 > Input1) ? 1 : 0 
	 */
	class IShadingGreaterThanNode : public IShadingFilterNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShadingGreaterThanNode is a or is a 
		 * descendant of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShadingGreaterThanNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingGreaterThanNode 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingGreaterThanNode pointer 
		 * @return a pointer to the IShadingGreaterThanNode object, if the cast can be 
		 * made, and a NULL pointer otherwise 
		 */

		static IShadingGreaterThanNode *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShadingGreaterThanNode") )
				return static_cast<IShadingGreaterThanNode*>(ptr);
			return nullptr;
		}
	};

	/**
	 * LessThanNode describes the "is less than" operator, where the per-component 
	 * output is either 1 or 0 depending on if input0 is LessThan to input1. Basically, 
	 * (Input0 < Input1) ? 1 : 0 
	 */
	class IShadingLessThanNode : public IShadingFilterNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShadingLessThanNode is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShadingLessThanNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingLessThanNode 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingLessThanNode pointer 
		 * @return a pointer to the IShadingLessThanNode object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IShadingLessThanNode *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShadingLessThanNode") )
				return static_cast<IShadingLessThanNode*>(ptr);
			return nullptr;
		}
	};

	/**
	 * Geometry field node describes a source node for geometry field data in a shading 
	 * network, such as normals and tangents. 
	 */
	class IShadingGeometryFieldNode : public IShadingNode
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShadingGeometryFieldNode is a or is 
		 * a descendant of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShadingGeometryFieldNode",type)==0 )
				return true;
			return IShadingNode::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingGeometryFieldNode 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingGeometryFieldNode pointer 
		 * @return a pointer to the IShadingGeometryFieldNode object, if the cast can 
		 * be made, and a NULL pointer otherwise 
		 */

		static IShadingGeometryFieldNode *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShadingGeometryFieldNode") )
				return static_cast<IShadingGeometryFieldNode*>(ptr);
			return nullptr;
		}
		/**
		 * The geometry field type to sample. 
		 * @param value Field type to sample. 
		 */
		virtual	void SetFieldType( rid value ) = 0;

		/**
		 * The geometry field type to sample. 
		 */
		virtual	Simplygon::EGeometryDataFieldType GetFieldType(  ) = 0;

		/**
		 * The geometry field index, for those fields that have multiple layers. If both 
		 * name and index is set, the name has priority. 
		 * @param value Field index which will be used. 
		 */
		virtual	void SetFieldIndex( rid value ) = 0;

		/**
		 * The geometry field index, for those fields that have multiple layers. If both 
		 * name and index is set, the name has priority. 
		 */
		virtual	rid GetFieldIndex(  ) = 0;

		/**
		 * The geometry field name, for those fields that have multiple layers. If both 
		 * name and index is set, the name has priority. 
		 * @param value Field name which will be used. 
		 */
		virtual	void SetFieldName( const char * value ) = 0;

		/**
		 * The geometry field name, for those fields that have multiple layers. If both 
		 * name and index is set, the name has priority. 
		 */
		virtual	spString GetFieldName(  ) = 0;

	};
	class IMaterial;

	/**
	 * Given a material, the shader data class keeps the relevant shader data and is 
	 * able to generate a GLSL/HLSL shader. 
	 */
	class IShaderGenerator : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IShaderGenerator is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IShaderGenerator",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShaderGenerator 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShaderGenerator pointer 
		 * @return a pointer to the IShaderGenerator object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IShaderGenerator *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IShaderGenerator") )
				return static_cast<IShaderGenerator*>(ptr);
			return nullptr;
		}
		/**
		 * The material, for which to create a shader. 
		 * @param value The material object. 
		 */
		virtual	void SetMaterial( spMaterial value ) = 0;

		/**
		 * The material, for which to create a shader. 
		 */
		virtual	spMaterial GetMaterial(  ) = 0;

		/**
		 * The prefix for all global identifiers. 
		 * @param value The prefix string. 
		 */
		virtual	void SetIdentifersPrefix( const char * value ) = 0;

		/**
		 * The prefix for all global identifiers. 
		 */
		virtual	spString GetIdentifersPrefix(  ) = 0;

		/**
		 * The GenerateFullShader flag value. If set, the shader generator will generate 
		 * a full shader, and not just the material shader tree. If false, the generator 
		 * will define the basic samplers, the per-fragment information and all the sampling 
		 * tree functions, but not the vertex and fragment shaders, that the user will 
		 * have to generate manually. This is useful for custom shader integration. 
		 * @param value The desired flag value. 
		 */
		virtual	void SetGenerateFullShader( bool value ) = 0;

		/**
		 * The GenerateFullShader flag value. If set, the shader generator will generate 
		 * a full shader, and not just the material shader tree. If false, the generator 
		 * will define the basic samplers, the per-fragment information and all the sampling 
		 * tree functions, but not the vertex and fragment shaders, that the user will 
		 * have to generate manually. This is useful for custom shader integration. 
		 */
		virtual	bool GetGenerateFullShader(  ) = 0;

		/**
		 * The GenerateTextureSamplerData flag value. If set, the shader generator will 
		 * generate sampler registers and uniforms (HLSL: map_[x] values, state_[x]). 
		 * If not set, the user will need to define them manually. As a help, the code 
		 * is still generated, but commented out. This flag only applies to when the shader 
		 * only generates the shading sampling tree, and is ignored if the GenerateFullShader 
		 * is set. 
		 * @param value The desired flag value. 
		 */
		virtual	void SetGenerateTextureSamplerData( bool value ) = 0;

		/**
		 * The GenerateTextureSamplerData flag value. If set, the shader generator will 
		 * generate sampler registers and uniforms (HLSL: map_[x] values, state_[x]). 
		 * If not set, the user will need to define them manually. As a help, the code 
		 * is still generated, but commented out. This flag only applies to when the shader 
		 * only generates the shading sampling tree, and is ignored if the GenerateFullShader 
		 * is set. 
		 */
		virtual	bool GetGenerateTextureSamplerData(  ) = 0;

		/**
		 * Generates a shader, given a material that uses shading node networks. To generate 
		 * the actual shader code, use GetHLSLCode, GetGLSLVertexCode and GetGLSLFragmentCode. 
		 * @return will return true if the shader could be generated from the material 
		 *  
		 */
		virtual	bool GenerateShaderData(  ) = 0;

		/**
		 * Returns a string containing the HLSL shader code. GenerateShader must have 
		 * been called prior to this call. 
		 */
		virtual	spString GetHLSLCode(  ) = 0;

		/**
		 * Returns a string containing the GLSL vertex shader GenerateShader must have 
		 * been called prior to this call. Note: If GenerateFullShader is set to false, 
		 * this code will be empty, as the code generated is only used by the fragment 
		 * shader. 
		 */
		virtual	spString GetGLSLVertexCode(  ) = 0;

		/**
		 * Returns a string containing the GLSL fragment shader GenerateShader must have 
		 * been called prior to this call. 
		 */
		virtual	spString GetGLSLFragmentCode(  ) = 0;

		/**
		 * The number of unique texture paths used in the material. For the shader to 
		 * use these textures, they are required to be uploaded to the texture channel 
		 * corresponding to their position in the array. The shader will generate these 
		 * sampler variables with the naming convention "map_i" (i : the array index of 
		 * the texture). GenerateShader must have been called prior to this call. Enumerate 
		 * 0 to Count, and use GetShaderInputTexturePath to retrieve a specific path. 
		 * @return The number of unique texture paths 
		 */
		virtual	unsigned int GetShaderInputTexturePathsCount(  ) = 0;

		/**
		 * Get a specific path from the list of unique paths. See notes of GetShaderInputTexturePathsCountfor 
		 * more documentation on usage. 
		 * @param index The index of the path to retrieve. 
		 * @return The texture path 
		 */
		virtual	spString GetShaderInputTexturePath( rid index ) = 0;

		/**
		 * The number of unique UV sets used in the material. For the shader to use these 
		 * UV sets, they are required to be uploaded as texture coordinates corresponding 
		 * to their position in the array. The shader will generate the texcoords variables 
		 * with the naming convention "tex_i" (i : the array index of the UV set). GenerateShader 
		 * must have been called prior to this call. 
		 * @return The number of unique UV sets 
		 */
		virtual	unsigned int GetShaderInputUVSetsCount(  ) = 0;

		/**
		 * Get a specific set from the list of unique sets. See notes of GetShaderInputUVSetsCountfor 
		 * more documentation on usage. 
		 * @param index The index of the set to retrieve. 
		 * @return The set name 
		 */
		virtual	spString GetShaderInputUVSet( rid index ) = 0;

		/**
		 * Returns the index that is set for the specific input UV set. If the UV set 
		 * is not used by the generated shader, the returned value is -1. Note that the 
		 * UV set name must match exactly, including case. 
		 * @param uvset The uv set name. 
		 * @return The index of the uv set, if used, or -1 if not used. 
		 */
		virtual	rid GetShaderInputUVIndex( const char * uvset ) = 0;

		/**
		 * The number of unique vertex colors used in the material. For the shader to 
		 * use these vertex colors, they are required to be uploaded as vertex color corresponding 
		 * to their position in the array. The shader will generate the vertex color variables 
		 * with the naming convention "vertexcolor_i" (i : the array index of the vertex 
		 * color). GenerateShader must have been called prior to this call. 
		 * @return The number of unique color sets 
		 */
		virtual	unsigned int GetShaderInputVertexColorsCount(  ) = 0;

		/**
		 * Get a specific set from the list of unique sets. See notes of GetShaderInputVertexColorsCountfor 
		 * more documentation on usage. 
		 * @param index The index of the set to retrieve. 
		 * @return The set name 
		 */
		virtual	spString GetShaderInputVertexColor( rid index ) = 0;

		/**
		 * Returns the index that is set for the specific input vertex color set. If the 
		 * vertex color set is not used by the generated shader, the returned value is 
		 * -1. Note that the vertex color set name must match exactly, including case. 
		 * @param colorset The name of the color set. 
		 * @return The index of the vertex color set, if used, or -1 if not used. 
		 */
		virtual	rid GetShaderInputVertexColorsIndex( const char * colorset ) = 0;

		/**
		 * Unloads all shader data and resets it. 
		 */
		virtual	void UnloadData(  ) = 0;

	};
	class IScene;
	class IMappingImage;
	class IAggregationSettings;
	class IMappingImageSettings;
	class IVisibilitySettings;
	class IGeometryCullingSettings;
	class IVertexWeightSettings;

	/**
	 * AggregationProcessor combines all specified geometries in the scene into one 
	 * geometry. All materials are combined and receive a new shared texture atlas. 
	 */
	class IAggregationProcessor : public IProcessingObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IAggregationProcessor is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IAggregationProcessor",type)==0 )
				return true;
			return IProcessingObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IAggregationProcessor 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IAggregationProcessor pointer 
		 * @return a pointer to the IAggregationProcessor object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IAggregationProcessor *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IAggregationProcessor") )
				return static_cast<IAggregationProcessor*>(ptr);
			return nullptr;
		}
		/**
		 * The scene that will be aggregated. Please note that internal refrences might 
		 * be modified by the processor. The caller should refresh any reference that 
		 * is cached outside the scene after running the processor. 
		 * @param value The scene to process. 
		 */
		virtual	void SetScene( spScene value ) = 0;

		/**
		 * The scene that will be aggregated. Please note that internal refrences might 
		 * be modified by the processor. The caller should refresh any reference that 
		 * is cached outside the scene after running the processor. 
		 */
		virtual	spScene GetScene(  ) = 0;

		/**
		 * The MappingImage object that is generated if MappingImageSettings::GenerateMappingImage 
		 * is set. This returns mapping image index 0, use GetMappingImageForImageIndex 
		 * to retrieve for a specific index. A new object is generated for each call to 
		 * RunProcessing(). 
		 * @return The generated mappingimage. 
		 */
		virtual	spMappingImage GetMappingImage(  ) = 0;

		/**
		 * The MappingImage object that is generated if MappingImageSettings::GenerateMappingImage 
		 * is set. Called with an id, it will fetch that specific mapping image if using 
		 * multi-material output. A new object is generated for each call to RunProcessing(). 
		 * @param OutputMaterialId The value for the OutputMaterialId. 
		 * @return The generated mappingimage. 
		 */
		virtual	spMappingImage GetMappingImageForImageIndex( rid OutputMaterialId ) = 0;

		/**
		 * The settings for the combining process. 
		 */
		virtual	spAggregationSettings GetAggregationSettings(  ) = 0;

		/**
		 * The settings for the image mapping process. 
		 */
		virtual	spMappingImageSettings GetMappingImageSettings(  ) = 0;

		/**
		 * The settings for handling visibility weights. 
		 */
		virtual	spVisibilitySettings GetVisibilitySettings(  ) = 0;

		/**
		 * The settings for handling geometry culling. 
		 */
		virtual	spGeometryCullingSettings GetGeometryCullingSettings(  ) = 0;

		/**
		 * The settings for handling visibility weights. 
		 */
		virtual	spVertexWeightSettings GetVertexWeightSettings(  ) = 0;

	};

	/**
	 * Settings for the AggregationSettings class. The AggregationProcessor converts 
	 * entire scenes containing multiple draw calls into a single new object with a 
	 * single texture per material channel. The user can set whether or not the AggregationProcessor 
	 * should create new UVs based on the old UVs or create a completely new UV parameterization. 
	 */
	class IAggregationSettings : public ISettingsObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IAggregationSettings is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IAggregationSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IAggregationSettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IAggregationSettings pointer 
		 * @return a pointer to the IAggregationSettings object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IAggregationSettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IAggregationSettings") )
				return static_cast<IAggregationSettings*>(ptr);
			return nullptr;
		}
		/**
		 * Which SelectionSet should be processed. If set to -1, all geometries in the 
		 * scene will be processed. 
		 * @param value The desired SelectionSet id. Value cannot be less than -1. 
		 */
		virtual	void SetProcessSelectionSetID( rid value ) = 0;

		/**
		 * Which SelectionSet should be processed. If set to -1, all geometries in the 
		 * scene will be processed. 
		 */
		virtual	rid GetProcessSelectionSetID(  ) = 0;

		/**
		 * Which selection set should be processed. If the selection set is not found, 
		 * all geometries in the scene will be processed. If both selection set name and 
		 * ID are set, the name will be used. 
		 * @param value The desired SelectionSet name. 
		 */
		virtual	void SetProcessSelectionSetName( const char * value ) = 0;

		/**
		 * Which selection set should be processed. If the selection set is not found, 
		 * all geometries in the scene will be processed. If both selection set name and 
		 * ID are set, the name will be used. 
		 */
		virtual	spString GetProcessSelectionSetName(  ) = 0;

		/**
		 * If false, the processor will remove all geometry and scene meshes which were 
		 * not selected for processing from the scene. If true, only the geometry in the 
		 * ProcessSelectionSet will be replaced or updated, while the rest of the scene 
		 * tree is kept intact. New geometry is always added as the last child of the 
		 * scene root. If generating a mappingimage to cast materials, new materialIds 
		 * will also be appended to the end of the old material table instead of replacing 
		 * the old ones. 
		 * @param value The desired KeepUnprocessedSceneMeshes flag. 
		 */
		virtual	void SetKeepUnprocessedSceneMeshes( bool value ) = 0;

		/**
		 * If false, the processor will remove all geometry and scene meshes which were 
		 * not selected for processing from the scene. If true, only the geometry in the 
		 * ProcessSelectionSet will be replaced or updated, while the rest of the scene 
		 * tree is kept intact. New geometry is always added as the last child of the 
		 * scene root. If generating a mappingimage to cast materials, new materialIds 
		 * will also be appended to the end of the old material table instead of replacing 
		 * the old ones. 
		 */
		virtual	bool GetKeepUnprocessedSceneMeshes(  ) = 0;

		/**
		 * The processor will merge all the geometries in the scene into a single geometry 
		 * if this is enabled. 
		 * @param value The desired MergeGeometries flag. 
		 */
		virtual	void SetMergeGeometries( bool value ) = 0;

		/**
		 * The processor will merge all the geometries in the scene into a single geometry 
		 * if this is enabled. 
		 */
		virtual	bool GetMergeGeometries(  ) = 0;

		/**
		 * Enables culling object insides and permits use of GeometryCullingSettings. 
		 * If both this and visibility related culling is enabled, this is run first, 
		 * then visibility. 
		 * @param value The desired EnableTriangleCulling flag. 
		 */
		virtual	void SetEnableGeometryCulling( bool value ) = 0;

		/**
		 * Enables culling object insides and permits use of GeometryCullingSettings. 
		 * If both this and visibility related culling is enabled, this is run first, 
		 * then visibility. 
		 */
		virtual	bool GetEnableGeometryCulling(  ) = 0;

		/**
		 * The accuracy of the triangle intersection math to find and cull insides used 
		 * by the EnableTriangleCulling setting. Defined from 0 to 1 where 0 is max speed 
		 * and 1 is max precision. 
		 * @param value The desired TriangleCullingPrecision value. Value cannot be less 
		 * than 0.0. Value cannot be greater than 1.0. 
		 */
		virtual	void SetGeometryCullingPrecision( real value ) = 0;

		/**
		 * The accuracy of the triangle intersection math to find and cull insides used 
		 * by the EnableTriangleCulling setting. Defined from 0 to 1 where 0 is max speed 
		 * and 1 is max precision. 
		 */
		virtual	real GetGeometryCullingPrecision(  ) = 0;

		/**
		 * Subdivides the geometry based on the tiling texture coords. The cutting frequency 
		 * "SubdivisionTileSize" is a positive integer multiplier (i.e. the mesh will 
		 * be cut each time its U or V texcoords crosses the SubdivisionTileSize). The 
		 * output UVs will be in the range [(0,0),(SubdivisionTileSize,SubdivisionTileSize)]. 
		 * @param value The desired SubdivideGeometryBasedOnUVTiles flag. 
		 */
		virtual	void SetSubdivideGeometryBasedOnUVTiles( bool value ) = 0;

		/**
		 * Subdivides the geometry based on the tiling texture coords. The cutting frequency 
		 * "SubdivisionTileSize" is a positive integer multiplier (i.e. the mesh will 
		 * be cut each time its U or V texcoords crosses the SubdivisionTileSize). The 
		 * output UVs will be in the range [(0,0),(SubdivisionTileSize,SubdivisionTileSize)]. 
		 *  
		 */
		virtual	bool GetSubdivideGeometryBasedOnUVTiles(  ) = 0;

		/**
		 * The cutting frequency used when SubdivideGeometryBasedOnUVTiles is enabled. 
		 * @param value The desired SubdivisionTileSize value. Value cannot be less than 
		 * 0. Value cannot be greater than UINT_MAX. 
		 */
		virtual	void SetSubdivisionTileSize( unsigned int value ) = 0;

		/**
		 * The cutting frequency used when SubdivideGeometryBasedOnUVTiles is enabled. 
		 *  
		 */
		virtual	unsigned int GetSubdivisionTileSize(  ) = 0;

	};
	class IGeometryData;
	class IRealArray;
	class IMaterialTable;
	class ITextureTable;

	/**
	 * Computes new texture coordinates for a geometry with overlapping UV charts. 
	 */
	class IChartAggregator : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IChartAggregator is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IChartAggregator",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IChartAggregator 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IChartAggregator pointer 
		 * @return a pointer to the IChartAggregator object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IChartAggregator *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IChartAggregator") )
				return static_cast<IChartAggregator*>(ptr);
			return nullptr;
		}
		/**
		 * Executes the parameterization of the geometry. 
		 * @param geom The geometry which is to be parameterized. 
		 * @param arr The array where the result is stored. 
		 * @return True if the parameterization succeeds, false otherwise. 
		 */
		virtual	bool Parameterize( spGeometryData geom , spRealArray arr ) = 0;

		/**
		 * The number of input materials used in the original geometry for mapping to 
		 * multiple output materials. This needs to be set before you can set any specific 
		 * in-out material mapping. 0 signifies that no in-out material mapping is used, 
		 * ie. the process will produce one resulting mapping image. 
		 * @param value The number of outputs. 
		 */
		virtual	void SetInputMaterialCount( unsigned int value ) = 0;

		/**
		 * The number of input materials used in the original geometry for mapping to 
		 * multiple output materials. This needs to be set before you can set any specific 
		 * in-out material mapping. 0 signifies that no in-out material mapping is used, 
		 * ie. the process will produce one resulting mapping image. 
		 */
		virtual	unsigned int GetInputMaterialCount(  ) = 0;

		/**
		 * The number of output mapping images that are to be generated. The triangle 
		 * field OutputMaterialIds also needs to be set, or the material IDs of the original 
		 * geometry needs to be set to a specific output material in this setting object. 
		 * @param value The number of outputs. Value cannot be less than 1. Value cannot 
		 * be greater than SG_MAXIMUM_CHART_AGGREGATOR_OUTPUT_MATERIAL_COUNT. 
		 */
		virtual	void SetOutputMaterialCount( unsigned int value ) = 0;

		/**
		 * The number of output mapping images that are to be generated. The triangle 
		 * field OutputMaterialIds also needs to be set, or the material IDs of the original 
		 * geometry needs to be set to a specific output material in this setting object. 
		 *  
		 */
		virtual	unsigned int GetOutputMaterialCount(  ) = 0;

		/**
		 * The material mapping for InMaterialId, meaning what material of the generated 
		 * LOD InMaterialId will be baked into. Both InputMaterialCount and OutputMaterialCount 
		 * need to be set for this mapping to work, and all original materials need to 
		 * be mapped to an existing output id. 
		 * @param InMaterialId The input material ID. 
		 * @param OutMaterialId The output material ID. 
		 */
		virtual	void SetInputOutputMaterialMapping( unsigned int InMaterialId , int OutMaterialId ) = 0;

		/**
		 * The previously set material mapping for mat_id. 
		 * @param InMaterialId The input material ID. 
		 * @return The currently mapped output material for InMaterialId. -1 means mapping 
		 * is not set. 
		 */
		virtual	int GetInputOutputMaterialMapping( unsigned int InMaterialId ) = 0;

		/**
		 * The width of the texture to use. 
		 * @param value The texture width. 
		 */
		virtual	void SetTextureWidth( unsigned int value ) = 0;

		/**
		 * The width of the texture to use. 
		 */
		virtual	unsigned int GetTextureWidth(  ) = 0;

		/**
		 * The width of the texture to use. 
		 * @param id The output material ID. 
		 * @param value The texture width. 
		 */
		virtual	void SetTextureWidthForMaterialIndex( unsigned int id , unsigned int value ) = 0;

		/**
		 * The width of the texture to use. 
		 * @param id The output material ID. 
		 * @return The current value of texture width. 
		 */
		virtual	unsigned int GetTextureWidthForMaterialIndex( unsigned int id ) = 0;

		/**
		 * The height of the texture to use. 
		 * @param value The texture height. 
		 */
		virtual	void SetTextureHeight( unsigned int value ) = 0;

		/**
		 * The height of the texture to use. 
		 */
		virtual	unsigned int GetTextureHeight(  ) = 0;

		/**
		 * The height of the texture to use. 
		 * @param id The output material ID. 
		 * @param value The texture height. 
		 */
		virtual	void SetTextureHeightForMaterialIndex( unsigned int id , unsigned int value ) = 0;

		/**
		 * The height of the texture to use. 
		 * @param id The output material ID. 
		 * @return The current value of texture height. 
		 */
		virtual	unsigned int GetTextureHeightForMaterialIndex( unsigned int id ) = 0;

		/**
		 * The minimum number of pixels between charts. 
		 * @param value The value to which GutterSpace will be set. 
		 */
		virtual	void SetGutterSpace( unsigned int value ) = 0;

		/**
		 * The minimum number of pixels between charts. 
		 */
		virtual	unsigned int GetGutterSpace(  ) = 0;

		/**
		 * The minimum number of pixels between charts. 
		 * @param id The output material ID. 
		 * @param value The value to which GutterSpace will be set. 
		 */
		virtual	void SetGutterSpaceForMaterialIndex( unsigned int id , unsigned int value ) = 0;

		/**
		 * The minimum number of pixels between charts. 
		 * @param id The output material ID. 
		 * @return The current value of GutterSpace 
		 */
		virtual	unsigned int GetGutterSpaceForMaterialIndex( unsigned int id ) = 0;

		/**
		 * The automatic_texture_size flag. If true, then texture sizes will be computed 
		 * for the reduced mesh depending on its pixel size on screen. 
		 * @param value The desired flag. 
		 */
		virtual	void SetUseAutomaticTextureSize( bool value ) = 0;

		/**
		 * The automatic_texture_size flag. If true, then texture sizes will be computed 
		 * for the reduced mesh depending on its pixel size on screen. 
		 */
		virtual	bool GetUseAutomaticTextureSize(  ) = 0;

		/**
		 * A texture dimension length multiplier for the automatic texture size. 
		 * @param value The desired multiplier. 
		 */
		virtual	void SetAutomaticTextureSizeMultiplier( real value ) = 0;

		/**
		 * A texture dimension length multiplier for the automatic texture size. 
		 */
		virtual	real GetAutomaticTextureSizeMultiplier(  ) = 0;

		/**
		 * If UseAutomaticTextureSize is enabled, then force the texture sizes to be a 
		 * power of 2. 
		 * @param value The desired flag. 
		 */
		virtual	void SetForcePower2Texture( bool value ) = 0;

		/**
		 * If UseAutomaticTextureSize is enabled, then force the texture sizes to be a 
		 * power of 2. 
		 */
		virtual	bool GetForcePower2Texture(  ) = 0;

		/**
		 * Which TexCoord level to get charts from during re-parameterization. If a TexCoordName 
		 * is set, it will override the TexCoordLevel. 
		 * @param value The level/id of the TexCoord to use (i.e. 0-255). 
		 */
		virtual	void SetTexCoordLevel( unsigned int value ) = 0;

		/**
		 * Which TexCoord level to get charts from during re-parameterization. If a TexCoordName 
		 * is set, it will override the TexCoordLevel. 
		 */
		virtual	unsigned int GetTexCoordLevel(  ) = 0;

		/**
		 * Which TexCoord name to get charts from during re-parameterization. 
		 * @param value The name of the TexCoord to use (i.e. 'TexCoord0'-'TexCoord255'). 
		 *  
		 */
		virtual	void SetTexCoordName( const char * value ) = 0;

		/**
		 * Which TexCoord name to get charts from during re-parameterization. 
		 */
		virtual	spString GetTexCoordName(  ) = 0;

		/**
		 * Determines which method to use when aggregating the UVs. TextureSizeProportions: 
		 * Aggregated UV charts will be scaled to keep their relative pixel density relative 
		 * to all other UV charts. The user can still set the size of the output texture 
		 * maps. SurfaceArea: Aggregated UV charts will have their size set based on its 
		 * actual geometrical size. OriginalPixelDensity: The combined atlas will be resized 
		 * to fit each chart so that all charts retain the same amount of pixels as they 
		 * originally had. This will override any manually set texture size. UVSizeProportions: 
		 * Aggregated UV charts will have their size set based on its original UV size, 
		 * disregarding the size of the texture they are used in. 
		 * @param value The ChartAggregatorMode value to use. 
		 */
		virtual	void SetChartAggregatorMode( Simplygon::EChartAggregatorMode value ) = 0;

		/**
		 * Determines which method to use when aggregating the UVs. TextureSizeProportions: 
		 * Aggregated UV charts will be scaled to keep their relative pixel density relative 
		 * to all other UV charts. The user can still set the size of the output texture 
		 * maps. SurfaceArea: Aggregated UV charts will have their size set based on its 
		 * actual geometrical size. OriginalPixelDensity: The combined atlas will be resized 
		 * to fit each chart so that all charts retain the same amount of pixels as they 
		 * originally had. This will override any manually set texture size. UVSizeProportions: 
		 * Aggregated UV charts will have their size set based on its original UV size, 
		 * disregarding the size of the texture they are used in. 
		 */
		virtual	Simplygon::EChartAggregatorMode GetChartAggregatorMode(  ) = 0;

		/**
		 * If multiple UV charts overlap and have the same material, SurfaceAreaScale 
		 * specifies which of those instances determines the the output scale. It is only 
		 * valid when the ChartAggregatorMode is SurfaceArea and SeparateOverlappingCharts 
		 * is false. 
		 * @param value The SurfaceAreaScale value to use. 
		 */
		virtual	void SetSurfaceAreaScale( Simplygon::ESurfaceAreaScale value ) = 0;

		/**
		 * If multiple UV charts overlap and have the same material, SurfaceAreaScale 
		 * specifies which of those instances determines the the output scale. It is only 
		 * valid when the ChartAggregatorMode is SurfaceArea and SeparateOverlappingCharts 
		 * is false. 
		 */
		virtual	Simplygon::ESurfaceAreaScale GetSurfaceAreaScale(  ) = 0;

		/**
		 * The Separate Overlapping Charts flag. If charts are overlapping in the original 
		 * texture coords, they will be separated. 
		 * @param value The desired flag value. 
		 */
		virtual	void SetSeparateOverlappingCharts( bool value ) = 0;

		/**
		 * The scene material table. 
		 * @param value The scene material table. 
		 */
		virtual	void SetMaterialTable( spMaterialTable value ) = 0;

		/**
		 * The scene texture table. 
		 * @param value The scene texture table. 
		 */
		virtual	void SetTextureTable( spTextureTable value ) = 0;

		/**
		 * If KeepOriginalChartSizes is enabled: calling GetKeepOriginalChartSizesTextureWidth 
		 * and GetKeepOriginalChartSizesTextureHeight after parameterization will return 
		 * the final texture sizes. 
		 * @return The current KeepOriginalChartSizesTextureWidth size. 
		 */
		virtual	unsigned int GetKeepOriginalChartSizesTextureWidth(  ) = 0;

		/**
		 * If KeepOriginalChartSizes is enabled: calling GetKeepOriginalChartSizesTextureWidth 
		 * and GetKeepOriginalChartSizesTextureHeight after parameterization will return 
		 * the final texture sizes. 
		 * @param OutputID The output id. 
		 * @return The current KeepOriginalChartSizesTextureWidth size. 
		 */
		virtual	unsigned int GetKeepOriginalChartSizesTextureWidthForMaterialIndex( unsigned int OutputID ) = 0;

		/**
		 * If KeepOriginalChartSizes is enabled: calling GetKeepOriginalChartSizesTextureWidth 
		 * and GetKeepOriginalChartSizesTextureHeight after parameterization will return 
		 * the final texture sizes. 
		 * @return The current KeepOriginalChartSizesTextureHeight size. 
		 */
		virtual	unsigned int GetKeepOriginalChartSizesTextureHeight(  ) = 0;

		/**
		 * If KeepOriginalChartSizes is enabled: calling GetKeepOriginalChartSizesTextureWidth 
		 * and GetKeepOriginalChartSizesTextureHeight after parameterization will return 
		 * the final texture sizes. 
		 * @param OutputID The output id. 
		 * @return The current KeepOriginalChartSizesTextureHeight size. 
		 */
		virtual	unsigned int GetKeepOriginalChartSizesTextureHeightForMaterialIndex( unsigned int OutputID ) = 0;

		/**
		 * Set OriginalChartProportionsChannel to an SG_MATERIAL_CHANNEL_[...]. This channel 
		 * determines which texture channel to look at when determining which chart sizes 
		 * to keep. 
		 * @param value The new OriginalChartProportionsChannel value. 
		 */
		virtual	void SetOriginalChartProportionsChannel( const char * value ) = 0;

		/**
		 * Set OriginalChartProportionsChannel to an SG_MATERIAL_CHANNEL_[...]. This channel 
		 * determines which texture channel to look at when determining which chart sizes 
		 * to keep. 
		 */
		virtual	spString GetOriginalChartProportionsChannel(  ) = 0;

		/**
		 * The UseVertexWeights flag to scale the charts according to their vertex weights. 
		 * @param value The desired flag value. 
		 */
		virtual	void SetUseVertexWeights( bool value ) = 0;

		/**
		 * The UseVertexWeights flag to scale the charts according to their vertex weights. 
		 *  
		 */
		virtual	bool GetUseVertexWeights(  ) = 0;

		/**
		 * If LockUVRotation is enabled, only the original UV rotation will be used. Otherwise 
		 * 4 rotations are used (90 degree rotations). 
		 * @param value The new LockUVRotation. 
		 */
		virtual	void SetLockUVRotation( bool value ) = 0;

		/**
		 * If LockUVRotation is enabled, only the original UV rotation will be used. Otherwise 
		 * 4 rotations are used (90 degree rotations). 
		 */
		virtual	bool GetLockUVRotation(  ) = 0;

		/**
		 * If ExpandZeroAreaUVs is enabled then triangles that have zero area will be 
		 * slightly expanded. 
		 * @param value The new ExpandZeroAreaUVs. 
		 */
		virtual	void SetExpandZeroAreaUVs( bool value ) = 0;

		/**
		 * If ExpandZeroAreaUVs is enabled then triangles that have zero area will be 
		 * slightly expanded. 
		 */
		virtual	bool GetExpandZeroAreaUVs(  ) = 0;

	};

	/**
	 * VertexColorCasterSettings is the interface for basic vertex color caster settings. 
	 */
	class IVertexColorCasterSettings : public IMaterialCasterSettings
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IVertexColorCasterSettings is a or is 
		 * a descendant of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IVertexColorCasterSettings",type)==0 )
				return true;
			return IMaterialCasterSettings::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IVertexColorCasterSettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IVertexColorCasterSettings pointer 
		 * @return a pointer to the IVertexColorCasterSettings object, if the cast can 
		 * be made, and a NULL pointer otherwise 
		 */

		static IVertexColorCasterSettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IVertexColorCasterSettings") )
				return static_cast<IVertexColorCasterSettings*>(ptr);
			return nullptr;
		}
		/**
		 * The OutputColorLevel index. 
		 * @param value The OutputColorLevel index value. 
		 */
		virtual	void SetOutputColorLevel( rid value ) = 0;

		/**
		 * The OutputColorLevel index. 
		 */
		virtual	rid GetOutputColorLevel(  ) = 0;

		/**
		 * The OutputColorName string . 
		 * @param value The OutputColorLevel index value. 
		 */
		virtual	void SetOutputColorName( const char * value ) = 0;

		/**
		 * The OutputColorName string . 
		 */
		virtual	spString GetOutputColorName(  ) = 0;

		/**
		 * The color space edge threshold, which will define how many hard color borders 
		 * there will be. Corners more similar than the threshold will be merged. This 
		 * works similarly to HardEdgeAngle for normals; lower values leads more hard 
		 * borders between neighboring corner colors, and higher values will give you 
		 * more shared, smoother, colors. This also impacts data usage when using packed 
		 * geometry since (more unique colors) == (more vertices). The distance is measured 
		 * in RGBA space. 
		 * @param value The ColorSpaceEdgeThreshold value. Value cannot be less than 0. 
		 * Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetColorSpaceEdgeThreshold( real value ) = 0;

		/**
		 * The color space edge threshold, which will define how many hard color borders 
		 * there will be. Corners more similar than the threshold will be merged. This 
		 * works similarly to HardEdgeAngle for normals; lower values leads more hard 
		 * borders between neighboring corner colors, and higher values will give you 
		 * more shared, smoother, colors. This also impacts data usage when using packed 
		 * geometry since (more unique colors) == (more vertices). The distance is measured 
		 * in RGBA space. 
		 */
		virtual	real GetColorSpaceEdgeThreshold(  ) = 0;

	};
	class IScene;
	class IVertexColorCasterSettings;

	/**
	 * VertexColorCaster. 
	 */
	class IVertexColorCaster : public IMaterialCaster
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IVertexColorCaster is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IVertexColorCaster",type)==0 )
				return true;
			return IMaterialCaster::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IVertexColorCaster 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IVertexColorCaster pointer 
		 * @return a pointer to the IVertexColorCaster object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IVertexColorCaster *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IVertexColorCaster") )
				return static_cast<IVertexColorCaster*>(ptr);
			return nullptr;
		}
		/**
		 * The scene used for vertex casting. 
		 * @param value Is the scene object. 
		 */
		virtual	void SetScene( spScene value ) = 0;

		/**
		 * The color caster settings object. 
		 * @return Color caster settings object 
		 */
		virtual	spVertexColorCasterSettings GetVertexColorCasterSettings(  ) = 0;

	};
	class IImageData;

	/**
	 * Class for saving image data to different file formats. 
	 */
	class IImageDataExporter : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IImageDataExporter is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IImageDataExporter",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IImageDataExporter 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IImageDataExporter pointer 
		 * @return a pointer to the IImageDataExporter object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IImageDataExporter *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IImageDataExporter") )
				return static_cast<IImageDataExporter*>(ptr);
			return nullptr;
		}
		/**
		 * The main export file path. This must always be set. 
		 * @param value The desired main export file path. 
		 */
		virtual	void SetExportFilePath( const char * value ) = 0;

		/**
		 * The main export file path. This must always be set. 
		 */
		virtual	spString GetExportFilePath(  ) = 0;

		/**
		 * The image data to export. 
		 * @param value The image data object to export. 
		 */
		virtual	void SetImage( spImageData value ) = 0;

		/**
		 * Runs the export. Note that all parameters must be setup before exporting. 
		 */
		virtual	bool RunExport(  ) = 0;

		/**
		 * Output image file format to use. 
		 * @param value The desired output image file format. 
		 */
		virtual	void SetImageFileFormat( Simplygon::EImageOutputFormat value ) = 0;

		/**
		 * Output image file format to use. 
		 */
		virtual	Simplygon::EImageOutputFormat GetImageFileFormat(  ) = 0;

		/**
		 * The DDS block compression type to use. The block compression type will alter 
		 * the number of output channels. BC1-3 - 3 channels. BC4 - 1 channel. BC5 - 3 
		 * channels. 
		 * @param value The desired DDS compression type name. 
		 */
		virtual	void SetDDSCompressionType( Simplygon::EDDSCompressionType value ) = 0;

		/**
		 * The DDS block compression type to use. The block compression type will alter 
		 * the number of output channels. BC1-3 - 3 channels. BC4 - 1 channel. BC5 - 3 
		 * channels. 
		 */
		virtual	Simplygon::EDDSCompressionType GetDDSCompressionType(  ) = 0;

		/**
		 * Close any open file or stream, release any allocated data. 
		 */
		virtual	void Clear(  ) = 0;

	};
	class IScene;
	class IAmbientOcclusionCasterSettings;

	/**
	 * AmbientOcclusionCaster generates an ambient occlusion map based on the original 
	 * geometry, and casts it. 
	 */
	class IAmbientOcclusionCaster : public IMaterialCaster
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IAmbientOcclusionCaster is a or is a 
		 * descendant of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IAmbientOcclusionCaster",type)==0 )
				return true;
			return IMaterialCaster::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IAmbientOcclusionCaster 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IAmbientOcclusionCaster pointer 
		 * @return a pointer to the IAmbientOcclusionCaster object, if the cast can be 
		 * made, and a NULL pointer otherwise 
		 */

		static IAmbientOcclusionCaster *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IAmbientOcclusionCaster") )
				return static_cast<IAmbientOcclusionCaster*>(ptr);
			return nullptr;
		}
		/**
		 * An additional scene that will be used to compute the ambient occlusion on the 
		 * main scene. 
		 * @param value The additional scene. 
		 */
		virtual	void SetAdditionalSourceScene( spScene value ) = 0;

		/**
		 * The ambient occlusion caster settings object. 
		 * @return Ambient occlusion caster settings object. 
		 */
		virtual	spAmbientOcclusionCasterSettings GetAmbientOcclusionCasterSettings(  ) = 0;

	};

	/**
	 * AmbientOcclusionCasterSettings manages settings for an ambient occlusion caster. 
	 */
	class IAmbientOcclusionCasterSettings : public IMaterialCasterSettings
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IAmbientOcclusionCasterSettings is a 
		 * or is a descendant of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IAmbientOcclusionCasterSettings",type)==0 )
				return true;
			return IMaterialCasterSettings::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IAmbientOcclusionCasterSettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IAmbientOcclusionCasterSettings 
		 * pointer 
		 * @return a pointer to the IAmbientOcclusionCasterSettings object, if the cast 
		 * can be made, and a NULL pointer otherwise 
		 */

		static IAmbientOcclusionCasterSettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IAmbientOcclusionCasterSettings") )
				return static_cast<IAmbientOcclusionCasterSettings*>(ptr);
			return nullptr;
		}
		/**
		 * This determines how many rays are traced per pixel (or subpixel) to evaluate 
		 * the occlusion. 
		 * @param value The desired number of rays. Value cannot be less than 0. Value 
		 * cannot be greater than UINT_MAX. 
		 */
		virtual	void SetRaysPerPixel( unsigned int value ) = 0;

		/**
		 * This determines how many rays are traced per pixel (or subpixel) to evaluate 
		 * the occlusion. 
		 */
		virtual	unsigned int GetRaysPerPixel(  ) = 0;

		/**
		 * How far away a surface has to be from another surface to generate no occlusion. 
		 * Only applicable if SimpleOcclusionMode is off. 
		 * @param value The far occlusion falloff. Value cannot be less than -REAL_MAX. 
		 * Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetOcclusionFalloff( real value ) = 0;

		/**
		 * How far away a surface has to be from another surface to generate no occlusion. 
		 * Only applicable if SimpleOcclusionMode is off. 
		 */
		virtual	real GetOcclusionFalloff(  ) = 0;

		/**
		 * This is just a basic intensity scaler. Higher is "darker". 
		 * @param value The occlusion multiplier. Value cannot be less than -REAL_MAX. 
		 * Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetOcclusionMultiplier( real value ) = 0;

		/**
		 * This is just a basic intensity scaler. Higher is "darker". 
		 */
		virtual	real GetOcclusionMultiplier(  ) = 0;

		/**
		 * If set, occlusion will not scale with distance, each ray will only be either 
		 * fully occluded or not at all. Speeds up processing time. 
		 * @param value The flag to which UseSimpleOcclusionMode will be set. 
		 */
		virtual	void SetUseSimpleOcclusionMode( bool value ) = 0;

		/**
		 * If set, occlusion will not scale with distance, each ray will only be either 
		 * fully occluded or not at all. Speeds up processing time. 
		 */
		virtual	bool GetUseSimpleOcclusionMode(  ) = 0;

	};
	class IScene;
	class IImpostorSettings;
	class IMappingImageSettings;
	class IMappingImage;
	class IGeometryData;

	/**
	 * The ImpostorProcessor generates an impostor of one of these impostor types: 
	 * BillboardCloud, Flipbook or ImpostorFromSingleView. 
	 */
	class IImpostorProcessor : public IProcessingObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IImpostorProcessor is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IImpostorProcessor",type)==0 )
				return true;
			return IProcessingObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IImpostorProcessor 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IImpostorProcessor pointer 
		 * @return a pointer to the IImpostorProcessor object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IImpostorProcessor *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IImpostorProcessor") )
				return static_cast<IImpostorProcessor*>(ptr);
			return nullptr;
		}
		/**
		 * The scene for the impostor processing. Please note that internal refrences 
		 * might be modified by the processor. The caller should refresh any reference 
		 * that is cached outside the scene after running the processor. 
		 * @param value The scene for the impostor processing. 
		 */
		virtual	void SetScene( spScene value ) = 0;

		/**
		 * The scene for the impostor processing. Please note that internal refrences 
		 * might be modified by the processor. The caller should refresh any reference 
		 * that is cached outside the scene after running the processor. 
		 */
		virtual	spScene GetScene(  ) = 0;

		/**
		 * The settings for the ImpostorProcessor. 
		 * @return The ImpostorProcessor settings object associated with the processor 
		 *  
		 */
		virtual	spImpostorSettings GetImpostorSettings(  ) = 0;

		/**
		 * The settings for the the MappingImage. 
		 * @return The MappingImage settings object associated with the processor 
		 */
		virtual	spMappingImageSettings GetMappingImageSettings(  ) = 0;

		/**
		 * The MappingImage for the Impostor geometry. 
		 * @return The MappingImage object associated with the processor 
		 */
		virtual	spMappingImage GetMappingImage(  ) = 0;

		/**
		 * If an impostor has been generated with ImpostorType: ImpostorFromSingleView, 
		 * this function returns the quad GeometryData. 
		 * @return The Impostor GeometryData object created by the processor 
		 */
		virtual	spGeometryData GetImpostorGeometryFromSingleView(  ) = 0;

		/**
		 * If an impostor has been generated with ImpostorType: ImpostorFromSingleView, 
		 * this function returns the aspect ratio so the mapping setting can be set accordingly. 
		 * TextureHeight * AspectRatio = TextureWidth 
		 */
		virtual	real GetSingleViewAspectRatio(  ) = 0;

		/**
		 * If an impostor has been generated with ImpostorType: BillboardCloud, this function 
		 * returns the material id of the generated material. 
		 */
		virtual	rid GetBillboardCloudMaterialId(  ) = 0;

	};
	class IBillboardCloudSettings;
	class IFlipbookSettings;
	class IImpostorFromSingleViewSettings;

	/**
	 * Settings for the ImpostorProccessor 
	 */
	class IImpostorSettings : public ISettingsObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IImpostorSettings is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IImpostorSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IImpostorSettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IImpostorSettings pointer 
		 * @return a pointer to the IImpostorSettings object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IImpostorSettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IImpostorSettings") )
				return static_cast<IImpostorSettings*>(ptr);
			return nullptr;
		}
		/**
		 * Specifies which type of impostor should be created: BillboardCloud, Flipbook 
		 * or ImpostorFromSingleView. 
		 * @param value The ImpostorType value to use. 
		 */
		virtual	void SetImpostorType( Simplygon::EImpostorType value ) = 0;

		/**
		 * Specifies which type of impostor should be created: BillboardCloud, Flipbook 
		 * or ImpostorFromSingleView. 
		 */
		virtual	Simplygon::EImpostorType GetImpostorType(  ) = 0;

		/**
		 * Which selection set should be processed. If set to -1, all geometries in the 
		 * scene will be processed. If both selection set name and ID are set, the name 
		 * will be used. 
		 * @param value The desired SelectionSet id. Value cannot be less than -1. 
		 */
		virtual	void SetProcessSelectionSetID( rid value ) = 0;

		/**
		 * Which selection set should be processed. If set to -1, all geometries in the 
		 * scene will be processed. If both selection set name and ID are set, the name 
		 * will be used. 
		 */
		virtual	rid GetProcessSelectionSetID(  ) = 0;

		/**
		 * Which selection set should be processed. If the name is not found, all geometries 
		 * in the scene will be processed. If both selection set name and ID are set, 
		 * the name will be used. 
		 * @param value The desired SelectionSet name. 
		 */
		virtual	void SetProcessSelectionSetName( const char * value ) = 0;

		/**
		 * Which selection set should be processed. If the name is not found, all geometries 
		 * in the scene will be processed. If both selection set name and ID are set, 
		 * the name will be used. 
		 */
		virtual	spString GetProcessSelectionSetName(  ) = 0;

		/**
		 * The settings for creating the billboard cloud. 
		 * @return The settings for creating the billboard cloud. 
		 */
		virtual	spBillboardCloudSettings GetBillboardCloudSettings(  ) = 0;

		/**
		 * The settings for creating the flipbook. 
		 * @return The settings for creating the flipbook. 
		 */
		virtual	spFlipbookSettings GetFlipbookSettings(  ) = 0;

		/**
		 * The settings for the single view impostor. 
		 * @return The settings for the single view impostor. 
		 */
		virtual	spImpostorFromSingleViewSettings GetImpostorFromSingleViewSettings(  ) = 0;

	};
	class IScene;
	class IGeometryData;
	class IMappingImageSettings;
	class IMappingImage;

	/**
	 * ISurfaceMapper creates a mapping image between two user-defined geometries. 
	 * The mapper basically looks for the source geometry in the inverse normal direction 
	 * from the outwardly offset destination geometry, and maps pixels accordingly. 
	 * This means that you can modify the normals of the destination geometry to adjust 
	 * the search direction to your liking. The geometries can either be set as IGeometryDatas 
	 * or as the root nodes of scenes. If both are set, the scene is used. If only 
	 * a single source or a destination is set, or if the source and destination are 
	 * the same scene or geometry, the surface mapper will map the mesh onto itself. 
	 */
	class ISurfaceMapper : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if ISurfaceMapper is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("ISurfaceMapper",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a ISurfaceMapper 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ISurfaceMapper pointer 
		 * @return a pointer to the ISurfaceMapper object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static ISurfaceMapper *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("ISurfaceMapper") )
				return static_cast<ISurfaceMapper*>(ptr);
			return nullptr;
		}
		/**
		 * The scene used for the surface transfer source. 
		 * @param value Is the source scene object. 
		 */
		virtual	void SetSourceScene( spScene value ) = 0;

		/**
		 * The scene used for the surface transfer source. 
		 */
		virtual	spScene GetSourceScene(  ) = 0;

		/**
		 * The scene used for the surface transfer destination. 
		 * @param value Is the destination scene object. 
		 */
		virtual	void SetDestinationScene( spScene value ) = 0;

		/**
		 * The scene used for the surface transfer destination. 
		 */
		virtual	spScene GetDestinationScene(  ) = 0;

		/**
		 * The source geometry data. 
		 * @param value Is the source geometry. 
		 */
		virtual	void SetSourceGeometry( spGeometryData value ) = 0;

		/**
		 * The source geometry data. 
		 */
		virtual	spGeometryData GetSourceGeometry(  ) = 0;

		/**
		 * The destination geometry data. 
		 * @param value Is the destination geometry. 
		 */
		virtual	void SetDestinationGeometry( spGeometryData value ) = 0;

		/**
		 * The destination geometry data. 
		 */
		virtual	spGeometryData GetDestinationGeometry(  ) = 0;

		/**
		 * The mapping image settings. Currently, the only applicable settings for this 
		 * mapper is texcoordlevel, texcoordname, size, and supersampling settings. 
		 * @return the mapping image settings object 
		 */
		virtual	spMappingImageSettings GetMappingImageSettings(  ) = 0;

		/**
		 * The mapping image. 
		 * @return the mapping image 
		 */
		virtual	spMappingImage GetMappingImage(  ) = 0;

		/**
		 * If set, the search direction from the destination mesh to the source mesh will 
		 * be determined by an internal normal calculation with the specified hard edge 
		 * angle. If false, the search direction will be determined by the existing normals 
		 * of the destination geometry. 
		 * @param value Is the desired flag value. 
		 */
		virtual	void SetRecalculateSearchDirection( bool value ) = 0;

		/**
		 * If set, the search direction from the destination mesh to the source mesh will 
		 * be determined by an internal normal calculation with the specified hard edge 
		 * angle. If false, the search direction will be determined by the existing normals 
		 * of the destination geometry. 
		 */
		virtual	bool GetRecalculateSearchDirection(  ) = 0;

		/**
		 * The hard edge angle in degrees. If RecalculateSearchDirection is on, the search 
		 * direction from the destination mesh to the source mesh will be determined by 
		 * an internal normal calculation with the specified hard edge angle. If false, 
		 * the search direction will be determined by the existing normals of the destination 
		 * geometry. 
		 * @param value Is the hard angle value. Value cannot be less than 0. Value cannot 
		 * be greater than 180. 
		 */
		virtual	void SetSearchDirectionHardEdgeAngle( real value ) = 0;

		/**
		 * The hard edge angle in degrees. If RecalculateSearchDirection is on, the search 
		 * direction from the destination mesh to the source mesh will be determined by 
		 * an internal normal calculation with the specified hard edge angle. If false, 
		 * the search direction will be determined by the existing normals of the destination 
		 * geometry. 
		 */
		virtual	real GetSearchDirectionHardEdgeAngle(  ) = 0;

		/**
		 * The search distance. If the source geometry is found within this distance from 
		 * the destination geometry, it will be mapped. If negative, it will be set to 
		 * a sane default internally, based on the mesh size. 
		 * @param value Is the search distance value. 
		 */
		virtual	void SetSearchDistance( real value ) = 0;

		/**
		 * The search distance. If the source geometry is found within this distance from 
		 * the destination geometry, it will be mapped. If negative, it will be set to 
		 * a sane default internally, based on the mesh size. 
		 */
		virtual	real GetSearchDistance(  ) = 0;

		/**
		 * The search offset. This is how far out from the destination geometry the search 
		 * for the source geometry will begin, propagating inwardly for the length of 
		 * SearchDistance. If negative, it will be set to a sane default internally, based 
		 * on the mesh size. 
		 * @param value Is the search offset value. 
		 */
		virtual	void SetSearchOffset( real value ) = 0;

		/**
		 * The search offset. This is how far out from the destination geometry the search 
		 * for the source geometry will begin, propagating inwardly for the length of 
		 * SearchDistance. If negative, it will be set to a sane default internally, based 
		 * on the mesh size. 
		 */
		virtual	real GetSearchOffset(  ) = 0;

		/**
		 * Runs the surface mapping. 
		 */
		virtual	void RunSurfaceMapping(  ) = 0;

	};
	class IScene;
	class IOcclusionMeshSettings;

	/**
	 * The occlusion mesh processor creates a reconstruction of the input mesh from 
	 * its silhouette. This means concavities and internal geometry disappear. WARNING: 
	 * Experimental. Generates nice meshes, but currently very slow at high settings. 
	 * Recommended onscreens size ~100 
	 */
	class IOcclusionMeshProcessor : public IProcessingObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IOcclusionMeshProcessor is a or is a 
		 * descendant of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IOcclusionMeshProcessor",type)==0 )
				return true;
			return IProcessingObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IOcclusionMeshProcessor 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IOcclusionMeshProcessor pointer 
		 * @return a pointer to the IOcclusionMeshProcessor object, if the cast can be 
		 * made, and a NULL pointer otherwise 
		 */

		static IOcclusionMeshProcessor *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IOcclusionMeshProcessor") )
				return static_cast<IOcclusionMeshProcessor*>(ptr);
			return nullptr;
		}
		/**
		 * The scene used for processing. All mesh nodes in the whole scene tree will 
		 * be replaced by one proxy mesh. Please note that internal refrences might be 
		 * modified by the processor. The caller should refresh any reference that is 
		 * cached outside the scene after running the processor. 
		 * @param value The scene node to which SceneRoot will be set. 
		 */
		virtual	void SetScene( spScene value ) = 0;

		/**
		 * The scene used for processing. All mesh nodes in the whole scene tree will 
		 * be replaced by one proxy mesh. Please note that internal refrences might be 
		 * modified by the processor. The caller should refresh any reference that is 
		 * cached outside the scene after running the processor. 
		 */
		virtual	spScene GetScene(  ) = 0;

		/**
		 * The settings for the OcclusionMeshProcessor. 
		 * @return The ImpostorProcessor settings object associated with the processor 
		 *  
		 */
		virtual	spOcclusionMeshSettings GetOcclusionMeshSettings(  ) = 0;

	};

	/**
	 * Settings for occlusion meshes 
	 */
	class IOcclusionMeshSettings : public ISettingsObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IOcclusionMeshSettings is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IOcclusionMeshSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IOcclusionMeshSettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IOcclusionMeshSettings pointer 
		 * @return a pointer to the IOcclusionMeshSettings object, if the cast can be 
		 * made, and a NULL pointer otherwise 
		 */

		static IOcclusionMeshSettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IOcclusionMeshSettings") )
				return static_cast<IOcclusionMeshSettings*>(ptr);
			return nullptr;
		}
		/**
		 * The onscreen size (px) of the output utility mesh. This will determine triangle 
		 * count and quality. 
		 * @param value The desired onscreen size. Value cannot be less than 20. Value 
		 * cannot be greater than 10000. 
		 */
		virtual	void SetOnScreenSize( unsigned int value ) = 0;

		/**
		 * The onscreen size (px) of the output utility mesh. This will determine triangle 
		 * count and quality. 
		 */
		virtual	unsigned int GetOnScreenSize(  ) = 0;

		/**
		 * The OnScreenErrorTolerance determines how large of an error that is tolerated, 
		 * in pixels. Valid range is 1-50. Since this setting is based around the absolute 
		 * worst-case scenario, you can usually get good results at relatively high tolerances. 
		 * @param value The desired OnScreenErrorTolerance. Value cannot be less than 
		 * 1. Value cannot be greater than 50. 
		 */
		virtual	void SetOnScreenErrorTolerance( unsigned int value ) = 0;

		/**
		 * The OnScreenErrorTolerance determines how large of an error that is tolerated, 
		 * in pixels. Valid range is 1-50. Since this setting is based around the absolute 
		 * worst-case scenario, you can usually get good results at relatively high tolerances. 
		 *  
		 */
		virtual	unsigned int GetOnScreenErrorTolerance(  ) = 0;

		/**
		 * Flips the winding of the triangles of the output, making frontfaces backfaces 
		 * and vice versa. Good for conservative z testing. 
		 * @param value The desired value of InvertOutputMesh. 
		 */
		virtual	void SetInvertOutputMesh( bool value ) = 0;

		/**
		 * Flips the winding of the triangles of the output, making frontfaces backfaces 
		 * and vice versa. Good for conservative z testing. 
		 */
		virtual	bool GetInvertOutputMesh(  ) = 0;

		/**
		 * Sets whether to transfer the bone weights and bone ids to the new geometry. 
		 * @param value The desired value of InvertOutputMesh. 
		 */
		virtual	void SetTransferSkinning( bool value ) = 0;

		/**
		 * Sets whether to transfer the bone weights and bone ids to the new geometry. 
		 *  
		 */
		virtual	bool GetTransferSkinning(  ) = 0;

		/**
		 * If set, cameras from the input scene will be used to define what angles the 
		 * occlusion mesh can be visible from, and optimize the output mesh accordingly. 
		 * Otherwise, the occlusion mesh will be assumed to be viewable from all directions. 
		 * @param value The desired value of UseCameras. 
		 */
		virtual	void SetUseCameras( bool value ) = 0;

		/**
		 * If set, cameras from the input scene will be used to define what angles the 
		 * occlusion mesh can be visible from, and optimize the output mesh accordingly. 
		 * Otherwise, the occlusion mesh will be assumed to be viewable from all directions. 
		 *  
		 */
		virtual	bool GetUseCameras(  ) = 0;

		/**
		 * The camera selection set id. This determines the selection set used for the 
		 * cameras for when UseCameras is on. A value of -1 uses all cameras in the scene. 
		 * @param value The desired OcclusionMode. 
		 */
		virtual	void SetCameraSelectionSetId( int value ) = 0;

		/**
		 * The camera selection set id. This determines the selection set used for the 
		 * cameras for when UseCameras is on. A value of -1 uses all cameras in the scene. 
		 *  
		 */
		virtual	int GetCameraSelectionSetId(  ) = 0;

		/**
		 * The camera selection set name. This determines the selection set used for the 
		 * cameras for when UseCameras is on. If set to null, all cameras in the scene 
		 * will be used. If both selection set name and ID are set, the name will be used. 
		 * @param value The desired SelectionSet name. 
		 */
		virtual	void SetCameraSelectionSetName( const char * value ) = 0;

		/**
		 * The camera selection set name. This determines the selection set used for the 
		 * cameras for when UseCameras is on. If set to null, all cameras in the scene 
		 * will be used. If both selection set name and ID are set, the name will be used. 
		 *  
		 */
		virtual	spString GetCameraSelectionSetName(  ) = 0;

		/**
		 * The occlusion mode. This decides if the processor generates an occluder (which 
		 * is smaller than the original mesh), an ocludee (which is larger), or an output 
		 * that just tries to match the input. 
		 * @param value The desired OcclusionMode. 
		 */
		virtual	void SetOcclusionMode( Simplygon::EOcclusionMode value ) = 0;

		/**
		 * The occlusion mode. This decides if the processor generates an occluder (which 
		 * is smaller than the original mesh), an ocludee (which is larger), or an output 
		 * that just tries to match the input. 
		 */
		virtual	Simplygon::EOcclusionMode GetOcclusionMode(  ) = 0;

	};
	class IImageData;
	class IBoolArray;

	/**
	 * Compares images. 
	 */
	class IImageComparer : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IImageComparer is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IImageComparer",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IImageComparer 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IImageComparer pointer 
		 * @return a pointer to the IImageComparer object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static IImageComparer *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IImageComparer") )
				return static_cast<IImageComparer*>(ptr);
			return nullptr;
		}
		/**
		 * The two images that will be compared. Both images needs to be of the same type 
		 * and the same size. 
		 * @param beforeImg The image data obejct for the before image. 
		 * @param afterImg The image data obejct for the after image. 
		 */
		virtual	void SetImages( spImageData beforeImg , spImageData afterImg ) = 0;

		/**
		 * The two image-masks for the comparison. Both image-masks needs to be of the 
		 * same size as the compared images (same item-count as the number of pixels in 
		 * the images). True means a pixel in the compared image contains a part of the 
		 * rendered object, false means the pixel is only "background" and does not need 
		 * to be compared. When a pixel in the mask is set to "true" in one image and 
		 * "false" in the other image, this means that there is a silhouette-error. How 
		 * much this error should be measured can be set with the "SilhouetteDifferenceError" 
		 * setting. If masks are not set, all pixels in the images will be compared as 
		 * is, without taking into account what part of the images are of the actual model 
		 * and which parts are just background. 
		 * @param beforeImgMask The bool array for the before image mask. 
		 * @param afterImgMask The bool array for the after image mask. 
		 */
		virtual	void SetImageMasks( spBoolArray beforeImgMask , spBoolArray afterImgMask ) = 0;

		/**
		 * Compares the images either set from "SetImages" or the two images set from 
		 * the "ImagePathBeforeImg" and "ImagePathAfterImg" strings. Will return -1 if 
		 * two images were not set (in the same manner) Returns -2 if images aren't of 
		 * the same size Returns -3 if images are not 2D images (ImageData supports 3D 
		 * images for example - don't try to use these) Returns -4 if ImgMasks are set, 
		 * but are not same size as the Before and AfterImg. Returns 0 on success. 
		 */
		virtual	int CompareImages(  ) = 0;

		/**
		 * The path to one of the images to be compared. Both images needs to be of the 
		 * same type and size for this to work. This can be used instead of setting the 
		 * images from the "SetImage" function, and will only be used if the "SetImage" 
		 * function was never used. 
		 * @param value The file path to the image. 
		 */
		virtual	void SetImagePathBeforeImg( const char * value ) = 0;

		/**
		 * The path to the other of the images to be compared. Both images needs to be 
		 * of the same type and size for this to work. This can be used instead of setting 
		 * the images from the "SetImage" function, and will only be used if the "SetImage" 
		 * function was never used. 
		 * @param value The file path to the image. 
		 */
		virtual	void SetImagePathAfterImg( const char * value ) = 0;

		/**
		 * The export-path for the resulting comparison. Can be used to get a visual feedback 
		 * of the results of the comparison. 
		 * @param value The file path to the image. 
		 */
		virtual	void SetImageDiffExportPath( const char * value ) = 0;

		/**
		 * The export-path for the most heavily impacted areas of the comparison. Can 
		 * be used to get a visual feedback of the results of the comparison, to see the 
		 * highlighted "problem areas". 
		 * @param value The file path to the image. 
		 */
		virtual	void SetDiffHighlightsExportPath( const char * value ) = 0;

		/**
		 * Returns the image for the resulting comparison. Can be used to get a visual 
		 * feedback of the results of the comparison. 
		 */
		virtual	spImageData GetImageDiff(  ) = 0;

		/**
		 * Returns the image for the most heavily impacted areas of the comparison. Can 
		 * be used to get a visual feedback of the results of the comparison, to see the 
		 * highlighted "problem areas". 
		 */
		virtual	spImageData GetDiffHighlights(  ) = 0;

		/**
		 * Returns the number of pixels that either the before- or the after-masks covers. 
		 * Can be good to know when looking at the TotalPixelError and HighlightAreaCoverage 
		 * numbers, to get a feel for the big the error of the image is relative to how 
		 * big the measured area actually was. 
		 */
		virtual	unsigned int GetTotalMaskCoverage(  ) = 0;

		/**
		 * Returns the size of the largest problem-areas. Preferably this value should 
		 * be not much larger than the 1-2 range, or the model should probably be further 
		 * away from the camera to get a good looking LOD-switch. 
		 */
		virtual	float GetMaxPixelError(  ) = 0;

		/**
		 * Return the sum of all pixel-errors of the whole image. Can be used to get a 
		 * feel for the over-all similarity between the two images. Especially when scaled 
		 * with the TotalMaskCoverage value. That way you can get the avarage pixel-error 
		 * of the model. 
		 */
		virtual	float GetTotalPixelError(  ) = 0;

		/**
		 * Returns the sum of all pixels that are in a "high-problem" area. Used together 
		 * with the TotalMaskCoverage value, this can let you know how large the problem-areas 
		 * are compared to the size of the model. 
		 */
		virtual	unsigned int GetHighlightAreaCoverage(  ) = 0;

		/**
		 * Decides how big of an impact the silhouette-difference between the two masks 
		 * will be. 0.0 means the silhouette difference will not be taken into account 
		 * at all, and 1.0 means it will be counted as maximum possible error. Default 
		 * value is set for the case where the background behind the model blends in somewhat 
		 * with the model and the difference in silhouette will not be fully seen. 
		 * @param value The value of silhouette-difference (0.0 - 1.0) 
		 */
		virtual	void SetSilhouetteDifferenceError( float value ) = 0;

	};
	class IGeometryData;

	/**
	 * Estimates a coarse recommended UV size (width and height) for a geometry based 
	 * on only its surface area and either the distance it is allowed to deviate or 
	 * its intended on screen size. The UVs are assumed to be unique i.e. not tiled/repeated. 
	 * RecommendedWidth and RecommendedHeight will only differ from each other if ForcePower2Texture 
	 * is enabled. 
	 */
	class IRecommendedTextureSizeCalculator : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IRecommendedTextureSizeCalculator is 
		 * a or is a descendant of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IRecommendedTextureSizeCalculator",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IRecommendedTextureSizeCalculator 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IRecommendedTextureSizeCalculator 
		 * pointer 
		 * @return a pointer to the IRecommendedTextureSizeCalculator object, if the cast 
		 * can be made, and a NULL pointer otherwise 
		 */

		static IRecommendedTextureSizeCalculator *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IRecommendedTextureSizeCalculator") )
				return static_cast<IRecommendedTextureSizeCalculator*>(ptr);
			return nullptr;
		}
		/**
		 * If true, then force the texture sizes to be a power of 2. 
		 * @param value The desired flag. 
		 */
		virtual	void SetForcePower2Texture( bool value ) = 0;

		/**
		 * If true, then force the texture sizes to be a power of 2. 
		 */
		virtual	bool GetForcePower2Texture(  ) = 0;

		/**
		 * The texture size multiplier for the automatic texture size. 
		 * @param value The desired multiplier. 
		 */
		virtual	void SetRecommendedTextureSizeMultiplier( real value ) = 0;

		/**
		 * The texture size multiplier for the automatic texture size. 
		 */
		virtual	real GetRecommendedTextureSizeMultiplier(  ) = 0;

		/**
		 * The recommended width calculated in CalculateRecommendedTextureSize() 
		 * @return The recommended width 
		 */
		virtual	unsigned int GetRecommendedWidth(  ) = 0;

		/**
		 * The recommended height calculated in CalculateRecommendedTextureSize() 
		 * @return The recommended height 
		 */
		virtual	unsigned int GetRecommendedHeight(  ) = 0;

		/**
		 * Calculates the recommended UV size based on the surface area of the geometry 
		 * and the allowed deviation. The recommended width and height can be fetched 
		 * with the GetRecommendedWidth() and GetRecommendedHeight() 
		 * @param geom The geometry for which to calculate the recommended UV size. 
		 * @param deviation The deviation value. 
		 */
		virtual	void CalculateBasedOnDeviation( spGeometryData geom , real deviation ) = 0;

		/**
		 * Calculates the recommended UV size based on the surface area of the geometry 
		 * and the intended on screen size (in pixels) The recommended width and height 
		 * can be fetched with the GetRecommendedWidth() and GetRecommendedHeight() 
		 * @param geom The geometry for which to calculate the recommended UV size. 
		 * @param onScreenSize The on screen size value. 
		 */
		virtual	void CalculateBasedOnOnScreenSize( spGeometryData geom , unsigned int onScreenSize ) = 0;

	};
	class IGeometryData;
	class IScene;
	class IRealArray;

	/**
	 * The PartRemover tool can identify unconnected sub-meshes, and remove meshes 
	 * that fall below a set size threshold. This size threshold can be set globally 
	 * for the entire geometry, or per-material to be able to remove things like decals 
	 * effectively. 
	 */
	class IPartRemover : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IPartRemover is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IPartRemover",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IPartRemover 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IPartRemover pointer 
		 * @return a pointer to the IPartRemover object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static IPartRemover *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IPartRemover") )
				return static_cast<IPartRemover*>(ptr);
			return nullptr;
		}
		/**
		 * Runs the part removal processing. 
		 */
		virtual	void RunPartRemoval(  ) = 0;

		/**
		 * The geometry data object to run the part removal on. If a scene is set, this 
		 * parameter is ignored by the reducer. 
		 * @param value The geometry data to be used for processing. 
		 */
		virtual	void SetGeometry( spGeometryData value ) = 0;

		/**
		 * The geometry data object to run the part removal on. If a scene is set, this 
		 * parameter is ignored by the reducer. 
		 */
		virtual	spGeometryData GetGeometry(  ) = 0;

		/**
		 * The scene object to run the part removal on. 
		 * @param value The scene data to be used for processing. 
		 */
		virtual	void SetScene( spScene value ) = 0;

		/**
		 * The scene object to run the part removal on. 
		 */
		virtual	spScene GetScene(  ) = 0;

		/**
		 * The size threshold to be used when removing parts. If SizeThreshold is equal 
		 * to, or greater than, the boundingbox radius of a part, then that part is removed. 
		 * If UsePerMaterialSizeThresholds is true, this value will be ignored and the 
		 * per-material values will be used instead. 
		 * @param value The new value of SizeThreshold. 
		 */
		virtual	void SetSizeThreshold( real value ) = 0;

		/**
		 * The size threshold to be used when removing parts. If SizeThreshold is equal 
		 * to, or greater than, the boundingbox radius of a part, then that part is removed. 
		 * If UsePerMaterialSizeThresholds is true, this value will be ignored and the 
		 * per-material values will be used instead. 
		 */
		virtual	real GetSizeThreshold(  ) = 0;

		/**
		 * The UsePerMaterialSizeThresholds flag. If true, the global SizeThreshold value 
		 * will be ignored and the per-material values in the PerMaterialSizeThresholds 
		 * will be used instead. 
		 * @param value The new value of UsePerMaterialSizeThresholds. 
		 */
		virtual	void SetUsePerMaterialSizeThresholds( bool value ) = 0;

		/**
		 * The UsePerMaterialSizeThresholds flag. If true, the global SizeThreshold value 
		 * will be ignored and the per-material values in the PerMaterialSizeThresholds 
		 * will be used instead. 
		 */
		virtual	bool GetUsePerMaterialSizeThresholds(  ) = 0;

		/**
		 * The per-material threshold array. These thresholds are mapped per material 
		 * ID in the geometrydata object if UsePerMaterialSizeThresholds is true. The 
		 * size and values in this array needs to be set up by the user, and material 
		 * IDs that fall outside the set array will be ignored. 
		 * @return The geometry data to be used for processing 
		 */
		virtual	spRealArray GetPerMaterialSizeThresholds(  ) = 0;

	};
	class IScene;
	class IGeometryData;

	/**
	 * Welds vertices within the geometry or scene together. 
	 */
	class IWelder : public IProcessingObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IWelder is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IWelder",type)==0 )
				return true;
			return IProcessingObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IWelder 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IWelder pointer 
		 * @return a pointer to the IWelder object, if the cast can be made, and a NULL 
		 * pointer otherwise 
		 */

		static IWelder *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IWelder") )
				return static_cast<IWelder*>(ptr);
			return nullptr;
		}
		/**
		 * The scene. 
		 * @param value The scene object. 
		 */
		virtual	void SetScene( spScene value ) = 0;

		/**
		 * The scene. 
		 */
		virtual	spScene GetScene(  ) = 0;

		/**
		 * The ID of the selection set containing the meshes to weld If the ID is -1, 
		 * all meshes are selected. If both selection set name and ID are set, the name 
		 * will be used. 
		 * @param value The ID of the selection set to use. 
		 */
		virtual	void SetProcessSelectionSetID( rid value ) = 0;

		/**
		 * The ID of the selection set containing the meshes to weld If the ID is -1, 
		 * all meshes are selected. If both selection set name and ID are set, the name 
		 * will be used. 
		 */
		virtual	rid GetProcessSelectionSetID(  ) = 0;

		/**
		 * The now of the selection set containing the meshes to weld. If the name is 
		 * not found, all geometries in the scene will be processed. If both selection 
		 * set name and ID are set, the name will be used. 
		 * @param value The desired SelectionSet name. 
		 */
		virtual	void SetProcessSelectionSetName( const char * value ) = 0;

		/**
		 * The now of the selection set containing the meshes to weld. If the name is 
		 * not found, all geometries in the scene will be processed. If both selection 
		 * set name and ID are set, the name will be used. 
		 */
		virtual	spString GetProcessSelectionSetName(  ) = 0;

		/**
		 * The distance below which the vertices will be welded. 
		 * @param value The weld distance. 
		 */
		virtual	void SetWeldDist( real value ) = 0;

		/**
		 * The distance below which the vertices will be welded. 
		 */
		virtual	real GetWeldDist(  ) = 0;

		/**
		 * Welds the geometry. 
		 * @param geom The geometry data object. 
		 */
		virtual	void WeldGeometry( spGeometryData geom ) = 0;

		/**
		 * If true, the welder will call CalculateExtents on the geometry before welding. 
		 * @param value The desired flag value. 
		 */
		virtual	void SetUpdateExtents( bool value ) = 0;

		/**
		 * If true, the welder will call CalculateExtents on the geometry before welding. 
		 *  
		 */
		virtual	bool GetUpdateExtents(  ) = 0;

		/**
		 * The number of progressive passes. 
		 * @param value The number of passes to perform. 
		 */
		virtual	void SetProgressivePasses( unsigned int value ) = 0;

		/**
		 * The number of progressive passes. 
		 */
		virtual	unsigned int GetProgressivePasses(  ) = 0;

		/**
		 * If IgnoreVertexLocks is true, then also vertices that are locked may be welded. 
		 * @param value The desired flag value. 
		 */
		virtual	void SetIgnoreVertexLocks( bool value ) = 0;

		/**
		 * If IgnoreVertexLocks is true, then also vertices that are locked may be welded. 
		 *  
		 */
		virtual	bool GetIgnoreVertexLocks(  ) = 0;

		/**
		 * If true, the welder will call Compact on the geometry after welding. 
		 * @param value The desired flag value. 
		 */
		virtual	void SetCompactMesh( bool value ) = 0;

		/**
		 * If true, the welder will call Compact on the geometry after welding. 
		 */
		virtual	bool GetCompactMesh(  ) = 0;

		/**
		 * If set, only vertices that are on the border are considered for the welding. 
		 * @param value The new OnlyBorders value. 
		 */
		virtual	void SetOnlyBorders( bool value ) = 0;

		/**
		 * If set, only vertices that are on the border are considered for the welding. 
		 *  
		 */
		virtual	bool GetOnlyBorders(  ) = 0;

		/**
		 * If set, only vertices that are within the same material are welded. Vertices 
		 * on material borders are locked. 
		 * @param value The desired flag value. 
		 */
		virtual	void SetOnlyWithinMaterial( bool value ) = 0;

		/**
		 * If set, only vertices that are within the same material are welded. Vertices 
		 * on material borders are locked. 
		 */
		virtual	bool GetOnlyWithinMaterial(  ) = 0;

		/**
		 * If set, only vertices that are within the same scene node are welded. 
		 * @param value The desired flag value. 
		 */
		virtual	void SetOnlyWithinSceneNode( bool value ) = 0;

		/**
		 * If set, only vertices that are within the same scene node are welded. 
		 */
		virtual	bool GetOnlyWithinSceneNode(  ) = 0;

		/**
		 * If set, only vertices that belong to different scene nodes are considered for 
		 * the welding. 
		 * @param value The desired flag value. 
		 */
		virtual	void SetOnlyBetweenSceneNodes( bool value ) = 0;

		/**
		 * If set, only vertices that belong to different scene nodes are considered for 
		 * the welding. 
		 */
		virtual	bool GetOnlyBetweenSceneNodes(  ) = 0;

	};
	class IScene;
	class IGeometryData;

	/**
	 * Removes t-junctions by subdividing triangles and welding vertices 
	 */
	class ITJunctionEliminator : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if ITJunctionEliminator is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("ITJunctionEliminator",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a ITJunctionEliminator 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ITJunctionEliminator pointer 
		 * @return a pointer to the ITJunctionEliminator object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static ITJunctionEliminator *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("ITJunctionEliminator") )
				return static_cast<ITJunctionEliminator*>(ptr);
			return nullptr;
		}
		/**
		 * The scene. 
		 * @param value The scene object. 
		 */
		virtual	void SetScene( spScene value ) = 0;

		/**
		 * The scene. 
		 */
		virtual	spScene GetScene(  ) = 0;

		/**
		 * Removes the t-junctions in the geometry data. 
		 * @param geom The geometry data object. 
		 */
		virtual	void RemoveTJunctionsInGeometry( spGeometryData geom ) = 0;

		/**
		 * Removes the t-junctions in the set scene, processing each sub-geometry individually. 
		 *  
		 */
		virtual	void RemoveTJunctions(  ) = 0;

		/**
		 * The distance, below which, the t-junctions will be welded. 
		 * @param value The welding distance. 
		 */
		virtual	void SetWeldDist( real value ) = 0;

		/**
		 * The distance, below which, the t-junctions will be welded. 
		 */
		virtual	real GetWeldDist(  ) = 0;

		/**
		 * If set, only vertices that are on the boundary between two different objects 
		 * are considered for the welding. 
		 * @param value The desired value of the flag. 
		 */
		virtual	void SetOnlyObjectBoundaryFlag( bool value ) = 0;

		/**
		 * If set, only vertices that are on the boundary between two different objects 
		 * are considered for the welding. 
		 */
		virtual	bool GetOnlyObjectBoundaryFlag(  ) = 0;

		/**
		 * The ID of the SelectionSet containing the meshes to weld If the ID is -1, all 
		 * meshes are selected. If both ID and Name are set, name will be used. 
		 * @param value The ID of the selection set to use. 
		 */
		virtual	void SetProcessSelectionSetID( rid value ) = 0;

		/**
		 * The ID of the SelectionSet containing the meshes to weld If the ID is -1, all 
		 * meshes are selected. If both ID and Name are set, name will be used. 
		 */
		virtual	rid GetProcessSelectionSetID(  ) = 0;

		/**
		 * Which SelectionSet should be processed. If Name is not found, all geometries 
		 * in the scene will be processed. If both ID and Name are set, name will be used. 
		 * @param value The desired SelectionSet name. 
		 */
		virtual	void SetProcessSelectionSetName( const char * value ) = 0;

		/**
		 * Which SelectionSet should be processed. If Name is not found, all geometries 
		 * in the scene will be processed. If both ID and Name are set, name will be used. 
		 *  
		 */
		virtual	spString GetProcessSelectionSetName(  ) = 0;

		/**
		 * If set, only vertices that are within the same material are welded. Vertices 
		 * on material borders are locked. 
		 * @param value The desired flag value. 
		 */
		virtual	void SetOnlyWithinMaterialFlag( bool value ) = 0;

		/**
		 * If set, only vertices that are within the same material are welded. Vertices 
		 * on material borders are locked. 
		 */
		virtual	bool GetOnlyWithinMaterialFlag(  ) = 0;

		/**
		 * If set, only vertices that arewithin the same scene node are welded. 
		 * @param value The desired flag value. 
		 */
		virtual	void SetOnlyWithinSceneNode( bool value ) = 0;

		/**
		 * If set, only vertices that arewithin the same scene node are welded. 
		 */
		virtual	bool GetOnlyWithinSceneNode(  ) = 0;

	};
	class IScene;
	class IMaterialCaster;
	class IObjectCollection;
	class IPipelineSettings;
	class IMappingImageSettings;
	class IMappingImage;
	class IStringArray;

	/**
	 * Pipeline is the interface for a processing pipeline, which applies a number 
	 * of processing opearations on an input scene to generate an output scene. The 
	 * input and output scenes can be any file format supported by Simplygon. 
	 */
	class IPipeline : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IPipeline is a or is a descendant of 
		 * the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IPipeline",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IPipeline 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IPipeline pointer 
		 * @return a pointer to the IPipeline object, if the cast can be made, and a NULL 
		 * pointer otherwise 
		 */

		static IPipeline *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IPipeline") )
				return static_cast<IPipeline*>(ptr);
			return nullptr;
		}
		/**
		 * Run the pipeline on the scene loaded from the given input scene file, and optionally 
		 * write the resulting scene to the given output scene file. If the scene is not 
		 * written to file it can be accessed with the GetProcessedScene method. When 
		 * using cascaded pipelines with RunSceneFromFile and the output file format does 
		 * not support cascaded scenes (OBJ, FBX, glTF), only the scene from the first 
		 * top level pipeline is exported to the output file. 
		 * @param input_scene The file path of the input scene file. Value cannot be equal 
		 * to null. 
		 * @param output_scene The file path of the output scene file (can be null) 
		 * @param run_mode Pipeline run mode controlling if pipeline run in this or separate/distributed 
		 * process. Valid values are the SG_PIPELINE_RUN* constants (from PipelineRunMode 
		 * enum). 
		 */
		virtual	void RunSceneFromFile( const char * input_scene , const char * output_scene , Simplygon::EPipelineRunMode run_mode ) = 0;

		/**
		 * Run the pipeline on the given scene, which will be modifed and contain the 
		 * result of the pipeline when the function returns. Please note that internal 
		 * refrences might be modified by the pipeline. The caller should refresh any 
		 * reference that is cached outside the scene after running the pipeline. 
		 * @param scene The scene to run the pipeline on. 
		 * @param run_mode Pipeline run mode controlling if pipeline run in this or separate/distributed 
		 * process. Valid values are the SG_PIPELINE_RUN* constants (from PipelineRunMode 
		 * enum). 
		 */
		virtual	void RunScene( spScene scene , Simplygon::EPipelineRunMode run_mode ) = 0;

		/**
		 * Add a material caster. Material casting requires the mapping image generation 
		 * to be enabled (SetGenerateMappingImage in MappingImageSettings returned by 
		 * GetMappingImageSettings). If called with a material index set to non-zero, 
		 * the mapping image for the corresponding output material will be used. See GetOutputMaterialCount/SetOutputMaterialCount 
		 * in MappingImageSettings. 
		 * @param MaterialCaster The material caster to add. 
		 * @param MaterialIndex The material index the caster will be associated with, 
		 * 0 for first material. 
		 */
		virtual	void AddMaterialCaster( spMaterialCaster MaterialCaster , unsigned int MaterialIndex ) = 0;

		/**
		 * Add a material caster by type name. Type name should undecorated base name 
		 * of caster, for example "Color", "AmbientOcclusion", "Normal" etc. Material 
		 * casting requires the mapping image generation to be enabled (SetGenerateMappingImage 
		 * in MappingImageSettings returned by GetMappingImageSettings). If called with 
		 * a material index set to non-zero, the mapping image for the corresponding output 
		 * material will be used. See GetOutputMaterialCount/SetOutputMaterialCount in 
		 * MappingImageSettings. 
		 * @param CasterType Caster type name, like "Color", "AmbientOcclusion", "Normal" 
		 * or similar. 
		 * @param MaterialIndex The material index the caster will be associated with, 
		 * 0 for first material. 
		 * @return The new material caster 
		 */
		virtual	spMaterialCaster AddMaterialCasterByType( const char * CasterType , unsigned int MaterialIndex ) = 0;

		/**
		 * The material casters for the pipeline. 
		 * @return All material casters 
		 */
		virtual	spObjectCollection GetMaterialCasters(  ) = 0;

		/**
		 * Get the number of material casters for the pipeline. 
		 * @return Number of material casters 
		 */
		virtual	unsigned int GetMaterialCasterCount(  ) = 0;

		/**
		 * Get the material caster in the pipeline for the given index, which must be 
		 * less than the material caster count. 
		 * @param index Material caster index, must be less than the material caster count. 
		 * Value cannot be less than 0. Value cannot be greater than the value returned 
		 * by GetMaterialCasterCount(). 
		 * @return Material caster for the given index 
		 */
		virtual	spMaterialCaster GetMaterialCasterByIndex( unsigned int index ) = 0;

		/**
		 * The settings for the pipeline. 
		 * @return Settings object for pipeline 
		 */
		virtual	spPipelineSettings GetPipelineSettings(  ) = 0;

		/**
		 * Set a named parameter boolean value including parameter path. 
		 * @param name Parameter path separated with forward slash, like "/RemeshingProcessor/Reduction/MergeGeometries". 
		 *  
		 * @param value New value for parameter. 
		 * @return True if successful, false if error (invalid parameter path or mismatching 
		 * parameter type) 
		 */
		virtual	bool SetBoolParameter( const char * name , bool value ) = 0;

		/**
		 * Set a named parameter integer value including parameter path. 
		 * @param name Parameter path separated with forward slash, like "/RemeshingProcessor/Reduction/MergeGeometries". 
		 *  
		 * @param value New value for parameter. 
		 * @return True if successful, false if error (invalid parameter path or mismatching 
		 * parameter type) 
		 */
		virtual	bool SetIntParameter( const char * name , int value ) = 0;

		/**
		 * Set a named parameter unsigned integer value including parameter path. 
		 * @param name Parameter path separated with forward slash, like "/RemeshingProcessor/Reduction/MergeGeometries". 
		 *  
		 * @param value New value for parameter. 
		 * @return True if successful, false if error (invalid parameter path or mismatching 
		 * parameter type) 
		 */
		virtual	bool SetUIntParameter( const char * name , unsigned int value ) = 0;

		/**
		 * Set a named parameter floating point value including parameter path. 
		 * @param name Parameter path separated with forward slash, like "/RemeshingProcessor/Reduction/MergeGeometries". 
		 *  
		 * @param value New value for parameter. 
		 * @return True if successful, false if error (invalid parameter path or mismatching 
		 * parameter type) 
		 */
		virtual	bool SetDoubleParameter( const char * name , double value ) = 0;

		/**
		 * Set a named parameter string value including parameter path. 
		 * @param name Parameter path separated with forward slash, like "/RemeshingProcessor/Reduction/MergeGeometries". 
		 *  
		 * @param value New value for parameter. 
		 * @return True if successful, false if error (invalid parameter path or mismatching 
		 * parameter type) 
		 */
		virtual	bool SetStringParameter( const char * name , const char * value ) = 0;

		/**
		 * Set a named parameter enum value including parameter path. 
		 * @param name Parameter path separated with forward slash, like "/RemeshingProcessor/Reduction/MergeGeometries". 
		 *  
		 * @param value New value for parameter. 
		 * @param valueEnumType Value type of enum for parameter value. 
		 * @return True if successful, false if error (invalid parameter path or mismatching 
		 * parameter type) 
		 */
		virtual	bool SetEnumParameter( const char * name , int value , Simplygon::ESettingValueType valueEnumType ) = 0;

		/**
		 * Set a named parameter value including parameter path. The string will be parsed 
		 * with best effort according to the parameter data type. 
		 * @param name Parameter path separated with forward slash, like "/RemeshingProcessor/Reduction/MergeGeometries". 
		 *  
		 * @param value New value for parameter. 
		 * @return True if successful, false if error (invalid parameter path or mismatching 
		 * parameter type) 
		 */
		virtual	bool SetParameterFromString( const char * name , const char * value ) = 0;

		/**
		 * Get a named parameter boolean value including parameter path. 
		 * @param name Parameter path separated with forward slash, like "/RemeshingProcessor/Reduction/MergeGeometries". 
		 *  
		 * @return Parameter value, or false if invalid parameter path or mismatching 
		 * type 
		 */
		virtual	bool GetBoolParameter( const char * name ) = 0;

		/**
		 * Get a named parameter integer value including parameter path. 
		 * @param name Parameter path separated with forward slash, like "/RemeshingProcessor/Reduction/MergeGeometries". 
		 *  
		 * @return Parameter value, or 0 if invalid parameter path or mismatching type 
		 *  
		 */
		virtual	int GetIntParameter( const char * name ) = 0;

		/**
		 * Get a named parameter unsigned integer value including parameter path. 
		 * @param name Parameter path separated with forward slash, like "/RemeshingProcessor/Reduction/MergeGeometries". 
		 *  
		 * @return Parameter value, or 0 if invalid parameter path or mismatching type 
		 *  
		 */
		virtual	unsigned int GetUIntParameter( const char * name ) = 0;

		/**
		 * Get a named parameter floating point value including parameter path. 
		 * @param name Parameter path separated with forward slash, like "/RemeshingProcessor/Reduction/MergeGeometries". 
		 *  
		 * @return Parameter value, or 0 if invalid parameter path or mismatching type 
		 *  
		 */
		virtual	double GetDoubleParameter( const char * name ) = 0;

		/**
		 * Get a named parameter string value including parameter path. 
		 * @param name Parameter path separated with forward slash, like "/RemeshingProcessor/Reduction/MergeGeometries". 
		 *  
		 * @return Parameter value, or null pointer if invalid parameter path or mismatching 
		 * type 
		 */
		virtual	spString GetStringParameter( const char * name ) = 0;

		/**
		 * Get a named parameter enum value as int including parameter path. 
		 * @param name Parameter path separated with forward slash, like "/RemeshingProcessor/Reduction/MergeGeometries". 
		 *  
		 * @return Parameter value, or null pointer if invalid parameter path or mismatching 
		 * type 
		 */
		virtual	int GetEnumParameter( const char * name ) = 0;

		/**
		 * Get a named parameter data type including parameter path. 
		 * @param name Parameter path separated with forward slash, like "/RemeshingProcessor/Reduction/MergeGeometries". 
		 *  
		 * @return Parameter data type (see SettingValueType enum), or Invalid if invalid 
		 * parameter path 
		 */
		virtual	Simplygon::ESettingValueType GetParameterType( const char * name ) = 0;

		/**
		 * The mapping image settings object containing the mapping image settings for 
		 * this pipeline. The return value will be null if the pipeline does not use material 
		 * casting and mapping images. 
		 * @return The mapping image settings 
		 */
		virtual	spMappingImageSettings GetMappingImageSettings(  ) = 0;

		/**
		 * The mapping image from the performed remeshing. Should only be called after 
		 * the pipeline has been run. The return value will be null if the pipeline does 
		 * not use material casting and mapping images. 
		 * @param materialIndex The index of the output material to get the mapping image 
		 * for. 
		 * @return The mapping image for the corresponding output material 
		 */
		virtual	spMappingImage GetMappingImage( unsigned int materialIndex ) = 0;

		/**
		 * The cascaded child pipeline object for the given index. 
		 * @param index The index of the cascaded child pipeline. 
		 * @return The cascaded child pipeline 
		 */
		virtual	spPipeline GetCascadedPipelineByIndex( unsigned int index ) = 0;

		/**
		 * Add a cascaded child pipeline. The child pipeline will execute on the scene 
		 * output from this pipeline. 
		 * @param pipeline The pipeline to add as a cascaded child pipeline. 
		 */
		virtual	void AddCascadedPipeline( spPipeline pipeline ) = 0;

		/**
		 * Remove a cascaded child pipeline. 
		 * @param pipeline The pipeline to remove from list of cascaded child pipelines. 
		 *  
		 */
		virtual	void RemoveCascadedPipeline( spPipeline pipeline ) = 0;

		/**
		 * Get number of cascaded child pipelines. 
		 * @return The number of cascaded child pipelines 
		 */
		virtual	unsigned int GetCascadedPipelineCount(  ) = 0;

		/**
		 * The resulting scene from the last execution of this pipeline. 
		 * @return The processed scene 
		 */
		virtual	spScene GetProcessedScene(  ) = 0;

		/**
		 * Returns the current progress of the pipeline as a value between 0 and 100. 
		 * @return The current progress of the pipeline as a value between 0 and 100. 
		 *  
		 */
		virtual	real GetPercentDone(  ) = 0;

		/**
		 * Get the names of all currently active selection sets used by this pipeline, 
		 * based on the current settings 
		 * @param sets The array recieving unique names of all selection sets being used 
		 * by this pipeline. Value cannot be equal to null. 
		 */
		virtual	void GetActiveSelectionSets( spStringArray sets ) = 0;

	};
	class IPipeline;
	class IScene;

	/**
	 * Control object to launch pipelines in batches, both locally and distributed 
	 */
	class IPipelineBatch : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IPipelineBatch is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IPipelineBatch",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IPipelineBatch 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IPipelineBatch pointer 
		 * @return a pointer to the IPipelineBatch object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static IPipelineBatch *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IPipelineBatch") )
				return static_cast<IPipelineBatch*>(ptr);
			return nullptr;
		}
		/**
		 * The path to the directory where data is serialized. All pipelines and scenes 
		 * are serialized in this path as temporary storage. If the path is not explicitly 
		 * set the pipeline batch will create a temporary directory which will be removed 
		 * once the pipeline batch object is deallocated, discarding all processed scenes. 
		 * @param path The path to use to serialize temporary storage of pipelines and 
		 * scenes. 
		 */
		virtual	void SetStoragePath( const char * path ) = 0;

		/**
		 * The path to the directory where data is serialized. All pipelines and scenes 
		 * are serialized in this path as temporary storage. If the path is not explicitly 
		 * set the pipeline batch will create a temporary directory which will be removed 
		 * once the pipeline batch object is deallocated, discarding all processed scenes. 
		 *  
		 */
		virtual	spString GetStoragePath(  ) = 0;

		/**
		 * Queue a pipeline to process the given scene. Use the returned handle to retrieve 
		 * the processed scene once the run call completes. The pipeline and scene will 
		 * be serialized in this function call and any updates to pipeline settings and/or 
		 * scene data will NOT affect the execution in this pipeline batch. 
		 * @param pipeline The pipeline to execute. Value cannot be equal to null. 
		 * @param scene The scene to process. Value cannot be equal to null. 
		 * @return Handle used to retrieve the processed scene. 
		 */
		virtual	unsigned int Queue( spPipeline pipeline , spScene scene ) = 0;

		/**
		 * Queue execution of a pipeline on a scene, both given as external files. Use 
		 * the returned handle to retrieve the processed scene once the run call completes. 
		 * @param pipeline The pipeline file to execute. Value cannot be equal to null. 
		 *  
		 * @param scene The scene file to process. Value cannot be equal to null. 
		 * @return Handle used to retrieve the processed scene. 
		 */
		virtual	unsigned int QueueFile( const char * pipeline , const char * scene ) = 0;

		/**
		 * Run processing on all queued pipelines using the given run mode, either local 
		 * or distributed, and clear the queue. 
		 * @param runMode The run mode for all pipelines. 
		 */
		virtual	void Run( Simplygon::EPipelineRunMode runMode ) = 0;

		/**
		 * Load the output scene for the given queue handle. For a cascaded pipeline, 
		 * use GetCascadedSceneCount/GetCascadedSceneForIndex on the returned scene to 
		 * get the corresponding cascaded scene output. 
		 * @param handle The handle for the scene as returned by a call to Queue/QueueFile. 
		 *  
		 * @return The processed scene. 
		 */
		virtual	spScene LoadProcessedScene( unsigned int handle ) = 0;

		/**
		 * Get the number of pipelines queued in the pipeline batch. 
		 * @return Number of pipelines queued in the pipeline batch. 
		 */
		virtual	unsigned int GetBatchCount(  ) = 0;

		/**
		 * Get the path of the serialized pipeline for the given batch index. 
		 * @param index The batch index. 
		 * @return The file path of the serialized pipeline for the given batch index. 
		 *  
		 */
		virtual	spString GetPipelinePath( unsigned int index ) = 0;

		/**
		 * Get the path of the serialized input scene for the given batch index. 
		 * @param index The batch index. 
		 * @return The file path of the serialized input scene for the given batch index. 
		 *  
		 */
		virtual	spString GetScenePath( unsigned int index ) = 0;

		/**
		 * Get the path of the serialized output scene for the given batch index. 
		 * @param index The batch index. 
		 * @return The file path of the serialized output scene for the given batch index. 
		 *  
		 */
		virtual	spString GetOutputPath( unsigned int index ) = 0;

		/**
		 * Manually clear the queue. 
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * The run mode to use on cascaded pipelines when executing the pipeline batch. 
		 * @param mode The run mode to use for cascaded pipelines. 
		 */
		virtual	void SetCascadedRunMode( Simplygon::EPipelineRunMode mode ) = 0;

		/**
		 * The run mode to use on cascaded pipelines when executing the pipeline batch. 
		 *  
		 */
		virtual	Simplygon::EPipelineRunMode GetCascadedRunMode(  ) = 0;

	};
	class IPipeline;
	class IPipelineBatch;

	class IPipelineSerializer : public IObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IPipelineSerializer is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IPipelineSerializer",type)==0 )
				return true;
			return IObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IPipelineSerializer 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IPipelineSerializer pointer 
		 * @return a pointer to the IPipelineSerializer object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IPipelineSerializer *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IPipelineSerializer") )
				return static_cast<IPipelineSerializer*>(ptr);
			return nullptr;
		}
		/**
		 * Load the pipeline definition to the given file and create a pipeline object 
		 * as defined in this file, including settings. 
		 * @param path The file path of the input pipeline definition. Value cannot be 
		 * equal to null. 
		 * @return A pipeline object with settings restored 
		 */
		virtual	spPipeline LoadPipelineFromFile( const char * path ) = 0;

		/**
		 * Save the pipeline definition and settings to the given file, which can be used 
		 * to restore the pipeline through the LoadPipelineFromFile method. Note that 
		 * pipeline files are NOT meant for storage, only as a transient transfer format 
		 * between processes and hosts. Do NOT store pipeline files for later use, as 
		 * there is no guarantee that pipeline files will be compatible between different 
		 * versions of Simplygon. 
		 * @param path The file path of the output pipeline definition. 
		 * @param pipeline The pipeline object to save. 
		 */
		virtual	void SavePipelineToFile( const char * path , spPipeline pipeline ) = 0;

		/**
		 * Load the pipeline batch definition to the given file and create a pipeline 
		 * batcg object as defined in this file. 
		 * @param path The file path of the input pipeline batch definition. Value cannot 
		 * be equal to null. 
		 * @return A pipeline batch object 
		 */
		virtual	spPipelineBatch LoadPipelineBatchFromFile( const char * path ) = 0;

		/**
		 * Save the pipeline batch definition and associated pipelines and scenes to the 
		 * given file, which can be used to restore the pipeline batch through the LoadPipelineBatchFromFile 
		 * method. Associated pipelines and scenes will be stored in the same directory 
		 * as the pipeline batch file. Note that pipeline files are NOT meant for storage, 
		 * only as a transient transfer format between processes and hosts. Do NOT store 
		 * pipeline files for later use, as there is no guarantee that pipeline files 
		 * will be compatible between different versions of Simplygon. 
		 * @param path The file path of the output pipeline batch definition. 
		 * @param batch The pipeline batch object to save. 
		 */
		virtual	void SavePipelineBatchToFile( const char * path , spPipelineBatch batch ) = 0;

	};
	class IReductionSettings;
	class IRepairSettings;
	class INormalCalculationSettings;
	class IVisibilitySettings;
	class IBoneSettings;
	class IVertexWeightSettings;

	/**
	 * ReductionPipeline provides a pipeline for a single reduction processor to be 
	 * applied on the input scene. 
	 */
	class IReductionPipeline : public IPipeline
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IReductionPipeline is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IReductionPipeline",type)==0 )
				return true;
			return IPipeline::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IReductionPipeline 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IReductionPipeline pointer 
		 * @return a pointer to the IReductionPipeline object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IReductionPipeline *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IReductionPipeline") )
				return static_cast<IReductionPipeline*>(ptr);
			return nullptr;
		}
		/**
		 * The reduction settings object containing the reduction settings for this pipeline. 
		 * @return The reduction settings 
		 */
		virtual	spReductionSettings GetReductionSettings(  ) = 0;

		/**
		 * The repair settings object containing the repair settings for this pipeline. 
		 * @return The repair settings 
		 */
		virtual	spRepairSettings GetRepairSettings(  ) = 0;

		/**
		 * The normal calculation settings object containing the normal calculation settings 
		 * for this pipeline. 
		 * @return The normal calculation settings 
		 */
		virtual	spNormalCalculationSettings GetNormalCalculationSettings(  ) = 0;

		/**
		 * The visibility settings object containing the visibility settings for this 
		 * pipeline. 
		 * @return The visibility settings 
		 */
		virtual	spVisibilitySettings GetVisibilitySettings(  ) = 0;

		/**
		 * The bone settings object containing the bone settings for this pipeline. 
		 * @return The bone settings 
		 */
		virtual	spBoneSettings GetBoneSettings(  ) = 0;

		/**
		 * The vertex weight settings object for this pipeline. 
		 * @return The vertex weight settings 
		 */
		virtual	spVertexWeightSettings GetVertexWeightSettings(  ) = 0;

		/**
		 * Returns the max deviation reached for the last processing. 
		 * @return The max deviation of the last processing 
		 */
		virtual	real GetResultDeviation(  ) = 0;

	};
	class IRemeshingLegacySettings;
	class IVisibilitySettings;
	class IBoneSettings;

	/**
	 * RemeshingLegacyPipeline provides a pipeline for a single remeshing legacy processor 
	 * to be applied on the input scene. 
	 */
	class IRemeshingLegacyPipeline : public IPipeline
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IRemeshingLegacyPipeline is a or is a 
		 * descendant of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IRemeshingLegacyPipeline",type)==0 )
				return true;
			return IPipeline::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IRemeshingLegacyPipeline 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IRemeshingLegacyPipeline pointer 
		 * @return a pointer to the IRemeshingLegacyPipeline object, if the cast can be 
		 * made, and a NULL pointer otherwise 
		 */

		static IRemeshingLegacyPipeline *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IRemeshingLegacyPipeline") )
				return static_cast<IRemeshingLegacyPipeline*>(ptr);
			return nullptr;
		}
		/**
		 * The remeshing settings object containing the remeshing settings for this pipeline. 
		 * @return The remeshing settings 
		 */
		virtual	spRemeshingLegacySettings GetRemeshingLegacySettings(  ) = 0;

		/**
		 * The visibility settings object containing the visibility settings for this 
		 * pipeline. 
		 * @return The visibility settings 
		 */
		virtual	spVisibilitySettings GetVisibilitySettings(  ) = 0;

		/**
		 * The bone settings object containing the bone settings for this pipeline. 
		 * @return The bone settings 
		 */
		virtual	spBoneSettings GetBoneSettings(  ) = 0;

	};
	class IAggregationSettings;
	class IVisibilitySettings;
	class IGeometryCullingSettings;
	class IVertexWeightSettings;
	class IGenerateLightmapTexCoordSettings;

	/**
	 * AggregationPipeline provides a pipeline for a single aggregation processor to 
	 * be applied on the input scene. 
	 */
	class IAggregationPipeline : public IPipeline
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IAggregationPipeline is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IAggregationPipeline",type)==0 )
				return true;
			return IPipeline::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IAggregationPipeline 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IAggregationPipeline pointer 
		 * @return a pointer to the IAggregationPipeline object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IAggregationPipeline *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IAggregationPipeline") )
				return static_cast<IAggregationPipeline*>(ptr);
			return nullptr;
		}
		/**
		 * The aggregation settings object for this pipeline. 
		 */
		virtual	spAggregationSettings GetAggregationSettings(  ) = 0;

		/**
		 * The visibility settings object for this pipeline. 
		 */
		virtual	spVisibilitySettings GetVisibilitySettings(  ) = 0;

		/**
		 * The geometry culling settings object for this pipeline. 
		 */
		virtual	spGeometryCullingSettings GetGeometryCullingSettings(  ) = 0;

		/**
		 * The vertex weight settings object for this pipeline. 
		 */
		virtual	spVertexWeightSettings GetVertexWeightSettings(  ) = 0;

		/**
		 * The settings object to create an extra set of TexCoord used for light mapping. 
		 *  
		 */
		virtual	spGenerateLightmapTexCoordSettings GetGenerateLightmapTexCoordSettings(  ) = 0;

	};

	/**
	 * PipelineSettings is the interface used to manage settings for a pipeline 
	 */
	class IPipelineSettings : public ISettingsObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IPipelineSettings is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IPipelineSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IPipelineSettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IPipelineSettings pointer 
		 * @return a pointer to the IPipelineSettings object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IPipelineSettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IPipelineSettings") )
				return static_cast<IPipelineSettings*>(ptr);
			return nullptr;
		}
		/**
		 * The path where the pipeline will save any created textures from material casters. 
		 * A relative path will be treated as relative to the scene file output path if 
		 * the pipeline is executed with scene file paths (RunSceneFromFile), or from 
		 * the current working directory if the pipeline is executed with a scene object 
		 * (RunScene). The directory must exist, it will not be created. 
		 * @param value Path where created textures will be saved. 
		 */
		virtual	void SetTextureOutputPath( const char * value ) = 0;

		/**
		 * The path where the pipeline will save any created textures from material casters. 
		 * A relative path will be treated as relative to the scene file output path if 
		 * the pipeline is executed with scene file paths (RunSceneFromFile), or from 
		 * the current working directory if the pipeline is executed with a scene object 
		 * (RunScene). The directory must exist, it will not be created. 
		 */
		virtual	spString GetTextureOutputPath(  ) = 0;

		/**
		 * The path for the batch tool used when executing pipelines in a new/distributed 
		 * process. This should be the path to the directory where the SimplygonBatch 
		 * executable is located. If the tool is in the system path this setting should 
		 * be an empty string. 
		 * @param value Path where SimplygonBatch executable is located. 
		 */
		virtual	void SetSimplygonBatchPath( const char * value ) = 0;

		/**
		 * The path for the batch tool used when executing pipelines in a new/distributed 
		 * process. This should be the path to the directory where the SimplygonBatch 
		 * executable is located. If the tool is in the system path this setting should 
		 * be an empty string. 
		 */
		virtual	spString GetSimplygonBatchPath(  ) = 0;

		/**
		 * The name of the output material. If the output material count is greater than 
		 * one, an index separated with an underscore will be appended to the material 
		 * names, such that MyMaterial becomes MyMaterial_0, MyMaterial_1 and so on. 
		 * @param value Output material name. 
		 */
		virtual	void SetOutputMaterialName( const char * value ) = 0;

		/**
		 * The name of the output material. If the output material count is greater than 
		 * one, an index separated with an underscore will be appended to the material 
		 * names, such that MyMaterial becomes MyMaterial_0, MyMaterial_1 and so on. 
		 */
		virtual	spString GetOutputMaterialName(  ) = 0;

		/**
		 * Generate unique material names if set to true, by replacing the default scheme 
		 * of appending a sequential material index to the name with appending a GUID. 
		 * This will make the material names unique each time the pipeline is run, even 
		 * on the same input scene. 
		 * @param value Flag controlling if material names are unique or sequential. 
		 */
		virtual	void SetOutputUniqueMaterialNames( bool value ) = 0;

		/**
		 * Generate unique material names if set to true, by replacing the default scheme 
		 * of appending a sequential material index to the name with appending a GUID. 
		 * This will make the material names unique each time the pipeline is run, even 
		 * on the same input scene. 
		 */
		virtual	bool GetOutputUniqueMaterialNames(  ) = 0;

		/**
		 * Set flag to control if output file formats that support embedding referenced 
		 * resources (like textures) should do so. 
		 * @param value Embed flag. 
		 */
		virtual	void SetEmbedReferences( bool value ) = 0;

		/**
		 * Set flag to control if output file formats that support embedding referenced 
		 * resources (like textures) should do so. 
		 */
		virtual	bool GetEmbedReferences(  ) = 0;

		/**
		 * Set flag to control if this pipeline step is an intermediate step where the 
		 * processed scene is only used as input to the next cascaded pipeline and not 
		 * for export or further access. This will discard any processed data once all 
		 * cascaded pipelines are done, and the scene will be ignored during export. Useful 
		 * if you want to group two pipelines together for one output, for example an 
		 * aggregation and a reduction pipeline where you only want the output from the 
		 * combined aggregation + reduction. 
		 * @param value Intermediate step flag. 
		 */
		virtual	void SetIntermediateStep( bool value ) = 0;

		/**
		 * Set flag to control if this pipeline step is an intermediate step where the 
		 * processed scene is only used as input to the next cascaded pipeline and not 
		 * for export or further access. This will discard any processed data once all 
		 * cascaded pipelines are done, and the scene will be ignored during export. Useful 
		 * if you want to group two pipelines together for one output, for example an 
		 * aggregation and a reduction pipeline where you only want the output from the 
		 * combined aggregation + reduction. 
		 */
		virtual	bool GetIntermediateStep(  ) = 0;

		/**
		 * Set run mode to use for cascaded child pipelines. 
		 * @param value Run mode for cascaded child pipelines. 
		 */
		virtual	void SetCascadedRunMode( Simplygon::EPipelineRunMode value ) = 0;

		/**
		 * Set run mode to use for cascaded child pipelines. 
		 */
		virtual	Simplygon::EPipelineRunMode GetCascadedRunMode(  ) = 0;

	};
	class IRemeshingSettings;
	class IBoneSettings;
	class IGeometryCullingSettings;
	class IVisibilitySettings;

	/**
	 * RemeshingPipeline provides a pipeline for a single remeshing processor to be 
	 * applied on the input scene. 
	 */
	class IRemeshingPipeline : public IPipeline
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IRemeshingPipeline is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IRemeshingPipeline",type)==0 )
				return true;
			return IPipeline::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IRemeshingPipeline 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IRemeshingPipeline pointer 
		 * @return a pointer to the IRemeshingPipeline object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IRemeshingPipeline *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IRemeshingPipeline") )
				return static_cast<IRemeshingPipeline*>(ptr);
			return nullptr;
		}
		/**
		 * The remeshing settings object containing the remeshing settings for this pipeline. 
		 * @return The remeshing settings 
		 */
		virtual	spRemeshingSettings GetRemeshingSettings(  ) = 0;

		/**
		 * The bone settings object containing the bone settings for this pipeline. 
		 * @return The bone settings 
		 */
		virtual	spBoneSettings GetBoneSettings(  ) = 0;

		/**
		 * The settings for handling visibility weights. 
		 * @return The geometry culling settings for this pipeline 
		 */
		virtual	spGeometryCullingSettings GetGeometryCullingSettings(  ) = 0;

		/**
		 * The visibility settings object containing the visibility settings for this 
		 * pipeline. 
		 * @return The visibility settings 
		 */
		virtual	spVisibilitySettings GetVisibilitySettings(  ) = 0;

	};

	/**
	 * PassthroughPipeline provides an empty pipeline for creating a cascading pipeline 
	 * using a single dummy root node. It does not process the input scene in any way. 
	 */
	class IPassthroughPipeline : public IPipeline
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IPassthroughPipeline is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IPassthroughPipeline",type)==0 )
				return true;
			return IPipeline::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IPassthroughPipeline 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IPassthroughPipeline pointer 
		 * @return a pointer to the IPassthroughPipeline object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IPassthroughPipeline *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IPassthroughPipeline") )
				return static_cast<IPassthroughPipeline*>(ptr);
			return nullptr;
		}
	};
	class IGeometryDataCasterSettings;

	/**
	 * GeometryDataCaster is used to cast original GeometryData information to an image 
	 * using mapping image 
	 */
	class IGeometryDataCaster : public IMaterialCaster
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IGeometryDataCaster is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IGeometryDataCaster",type)==0 )
				return true;
			return IMaterialCaster::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IGeometryDataCaster 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IGeometryDataCaster pointer 
		 * @return a pointer to the IGeometryDataCaster object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IGeometryDataCaster *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IGeometryDataCaster") )
				return static_cast<IGeometryDataCaster*>(ptr);
			return nullptr;
		}
		/**
		 * The GeometryDataCaster settings object. 
		 * @return The caster settings object. 
		 */
		virtual	spGeometryDataCasterSettings GetGeometryDataCasterSettings(  ) = 0;

	};

	/**
	 * GeometryDataCasterSettings is the interface used to manage settings for GeometryDataCaster 
	 */
	class IGeometryDataCasterSettings : public IMaterialCasterSettings
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IGeometryDataCasterSettings is a or is 
		 * a descendant of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IGeometryDataCasterSettings",type)==0 )
				return true;
			return IMaterialCasterSettings::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IGeometryDataCasterSettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IGeometryDataCasterSettings pointer 
		 * @return a pointer to the IGeometryDataCasterSettings object, if the cast can 
		 * be made, and a NULL pointer otherwise 
		 */

		static IGeometryDataCasterSettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IGeometryDataCasterSettings") )
				return static_cast<IGeometryDataCasterSettings*>(ptr);
			return nullptr;
		}
		/**
		 * The GeometryDataFieldType setting, which specifies what field type to cast 
		 * in the GeometryDataCaster. 
		 * @param FieldType The field type to set. Specified in the GeometryDataFieldTypes 
		 * enum. 
		 */
		virtual	void SetGeometryDataFieldType( Simplygon::EGeometryDataFieldType FieldType ) = 0;

		/**
		 * The GeometryDataFieldType setting, which specifies what field type to cast 
		 * in the GeometryDataCaster. 
		 */
		virtual	Simplygon::EGeometryDataFieldType GetGeometryDataFieldType(  ) = 0;

		/**
		 * The GeometryDataFieldIndex setting, which specifies what field index to cast 
		 * in the GeometryDataCaster, for fields where it is applicable (TexCoords, Tangents, 
		 * Bitangents and Colors). The setting is ignored for other field types. 
		 * @param FieldIndex Value the field index for the selected field type, if applicable. 
		 * Allowed max value depend on the field type selected. Value cannot be less than 
		 * 0. Value cannot be greater than UINT_MAX. 
		 */
		virtual	void SetGeometryDataFieldIndex( unsigned int FieldIndex ) = 0;

		/**
		 * The GeometryDataFieldIndex setting, which specifies what field index to cast 
		 * in the GeometryDataCaster, for fields where it is applicable (TexCoords, Tangents, 
		 * Bitangents and Colors). The setting is ignored for other field types. 
		 */
		virtual	unsigned int GetGeometryDataFieldIndex(  ) = 0;

		/**
		 * The inferior/minimum value of field values to map onto the image data range 
		 * (0->1). The minimum value will be represented by 0 in the image. Note that 
		 * the mapping is only used for real value fields, not id-based fields, which 
		 * cannot be scaled accurately. 
		 * @param value The minimum value for the red channel. Value cannot be less than 
		 * -REAL_MAX. Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetMappingInfR( real value ) = 0;

		/**
		 * The inferior/minimum value of field values to map onto the image data range 
		 * (0->1). The minimum value will be represented by 0 in the image. Note that 
		 * the mapping is only used for real value fields, not id-based fields, which 
		 * cannot be scaled accurately. 
		 */
		virtual	real GetMappingInfR(  ) = 0;

		/**
		 * The Superior/maximum value of field values to map onto the image data range 
		 * (0->1). The maximum value will be represented by 1 in the image. Note that 
		 * the mapping is only used for real value fields, not id-based fields, which 
		 * cannot be scaled accurately. 
		 * @param value The maximum value for the red channel. Value cannot be less than 
		 * -REAL_MAX. Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetMappingSupR( real value ) = 0;

		/**
		 * The Superior/maximum value of field values to map onto the image data range 
		 * (0->1). The maximum value will be represented by 1 in the image. Note that 
		 * the mapping is only used for real value fields, not id-based fields, which 
		 * cannot be scaled accurately. 
		 */
		virtual	real GetMappingSupR(  ) = 0;

		/**
		 * The inferior/minimum value of field values to map onto the image data range 
		 * (0->1). The minimum value will be represented by 0 in the image. Note that 
		 * the mapping is only used for real value fields, not id-based fields, which 
		 * cannot be scaled accurately. 
		 * @param value The minimum value for the green channel. Value cannot be less 
		 * than -REAL_MAX. Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetMappingInfG( real value ) = 0;

		/**
		 * The inferior/minimum value of field values to map onto the image data range 
		 * (0->1). The minimum value will be represented by 0 in the image. Note that 
		 * the mapping is only used for real value fields, not id-based fields, which 
		 * cannot be scaled accurately. 
		 */
		virtual	real GetMappingInfG(  ) = 0;

		/**
		 * The Superior/maximum value of field values to map onto the image data range 
		 * (0->1). The maximum value will be represented by 1 in the image. Note that 
		 * the mapping is only used for real value fields, not id-based fields, which 
		 * cannot be scaled accurately. 
		 * @param value The maximum value for the green channel. Value cannot be less 
		 * than -REAL_MAX. Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetMappingSupG( real value ) = 0;

		/**
		 * The Superior/maximum value of field values to map onto the image data range 
		 * (0->1). The maximum value will be represented by 1 in the image. Note that 
		 * the mapping is only used for real value fields, not id-based fields, which 
		 * cannot be scaled accurately. 
		 */
		virtual	real GetMappingSupG(  ) = 0;

		/**
		 * The inferior/minimum value of field values to map onto the image data range 
		 * (0->1). The minimum value will be represented by 0 in the image. Note that 
		 * the mapping is only used for real value fields, not id-based fields, which 
		 * cannot be scaled accurately. 
		 * @param value The minimum value for the blue channel. Value cannot be less than 
		 * -REAL_MAX. Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetMappingInfB( real value ) = 0;

		/**
		 * The inferior/minimum value of field values to map onto the image data range 
		 * (0->1). The minimum value will be represented by 0 in the image. Note that 
		 * the mapping is only used for real value fields, not id-based fields, which 
		 * cannot be scaled accurately. 
		 */
		virtual	real GetMappingInfB(  ) = 0;

		/**
		 * The Superior/maximum value of field values to map onto the image data range 
		 * (0->1). The maximum value will be represented by 1 in the image. Note that 
		 * the mapping is only used for real value fields, not id-based fields, which 
		 * cannot be scaled accurately. 
		 * @param value The maximum value for the blue channel. Value cannot be less than 
		 * -REAL_MAX. Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetMappingSupB( real value ) = 0;

		/**
		 * The Superior/maximum value of field values to map onto the image data range 
		 * (0->1). The maximum value will be represented by 1 in the image. Note that 
		 * the mapping is only used for real value fields, not id-based fields, which 
		 * cannot be scaled accurately. 
		 */
		virtual	real GetMappingSupB(  ) = 0;

		/**
		 * Property the inferior/minimum value of field values to map onto the image data 
		 * range (0->1). The minimum value will be represented by 0 in the image. Note 
		 * that the mapping is only used for real value fields, not id-based fields, which 
		 * cannot be scaled accurately. 
		 * @param value The minimum value for the alpha channel. Value cannot be less 
		 * than -REAL_MAX. Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetMappingInfA( real value ) = 0;

		/**
		 * Property the inferior/minimum value of field values to map onto the image data 
		 * range (0->1). The minimum value will be represented by 0 in the image. Note 
		 * that the mapping is only used for real value fields, not id-based fields, which 
		 * cannot be scaled accurately. 
		 */
		virtual	real GetMappingInfA(  ) = 0;

		/**
		 * Property the Superior/maximum value of field values to map onto the image data 
		 * range (0->1). The maximum value will be represented by 1 in the image. Note 
		 * that the mapping is only used for real value fields, not id-based fields, which 
		 * cannot be scaled accurately. 
		 * @param value The maximum value for the alpha channel. Value cannot be less 
		 * than -REAL_MAX. Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetMappingSupA( real value ) = 0;

		/**
		 * Property the Superior/maximum value of field values to map onto the image data 
		 * range (0->1). The maximum value will be represented by 1 in the image. Note 
		 * that the mapping is only used for real value fields, not id-based fields, which 
		 * cannot be scaled accurately. 
		 */
		virtual	real GetMappingSupA(  ) = 0;

		/**
		 * The inferior/minimum value of field values to map onto the image data range 
		 * (0->1). The minimum value will be represented by 0 in the image. Note that 
		 * the mapping is only used for real value fields, not id-based fields, which 
		 * cannot be scaled accurately. 
		 * @param vec_realInputDataPtr The minimum value for each channel (RGBA, 4 values). 
		 * Value cannot be less than -REAL_MAX,-REAL_MAX,-REAL_MAX,-REAL_MAX. Value cannot 
		 * be greater than REAL_MAX,REAL_MAX,REAL_MAX,REAL_MAX. 
		 */
		virtual	void SetMappingInf( const real *vec_realInputDataPtr ) = 0;

		/**
		 * The inferior/minimum value of field values to map onto the image data range 
		 * (0->1). The minimum value will be represented by 0 in the image. Note that 
		 * the mapping is only used for real value fields, not id-based fields, which 
		 * cannot be scaled accurately. 
		 * @return The returned data array. The array contains 4 items. 
		 */
		virtual	spRealData GetMappingInf(  ) = 0;

		/**
		 * The Superior/maximum value of field values to map onto the image data range 
		 * (0->1). The maximum value will be represented by 1 in the image. Note that 
		 * the mapping is only used for real value fields, not id-based fields, which 
		 * cannot be scaled accurately. 
		 * @param vec_realInputDataPtr The maximum value for each channel (RGBA, 4 values). 
		 * Value cannot be less than -REAL_MAX,-REAL_MAX,-REAL_MAX,-REAL_MAX. Value cannot 
		 * be greater than REAL_MAX,REAL_MAX,REAL_MAX,REAL_MAX. 
		 */
		virtual	void SetMappingSup( const real *vec_realInputDataPtr ) = 0;

		/**
		 * The Superior/maximum value of field values to map onto the image data range 
		 * (0->1). The maximum value will be represented by 1 in the image. Note that 
		 * the mapping is only used for real value fields, not id-based fields, which 
		 * cannot be scaled accurately. 
		 * @return The returned data array. The array contains 4 items. 
		 */
		virtual	spRealData GetMappingSup(  ) = 0;

	};

	/**
	 * This settings object contains all settings related to how the user-set weighting 
	 * field "VertexWeights" is setup and used in different contexts. The values in 
	 * the field can be considered an "importance" factor. Generally, weights set to 
	 * 1.0 are handled normally, values >1.0 are given greater importance, and values 
	 * <1.0 are given less. These weights can either be manually set in the input geometry 
	 * data or converted from vertex color sets using the WeightsFromColor settings. 
	 * See the documentation of the WeightsFromColorMode property to see the details 
	 * of how color intensity is mapped to vertex weight. Vertex weights can be used 
	 * to reduce more or less aggressively on different parts of the mesh, or used 
	 * to scale UV allocation in the parameterizers to give more or less texture area 
	 * to different areas. 
	 */
	class IVertexWeightSettings : public ISettingsObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IVertexWeightSettings is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IVertexWeightSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IVertexWeightSettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IVertexWeightSettings pointer 
		 * @return a pointer to the IVertexWeightSettings object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IVertexWeightSettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IVertexWeightSettings") )
				return static_cast<IVertexWeightSettings*>(ptr);
			return nullptr;
		}
		/**
		 * If set, and using the reduction processor, the reduction will be weighted based 
		 * on the weights in the "VertexWeights" vertex field. 
		 * @param value The desired flag value. 
		 */
		virtual	void SetUseVertexWeightsInReducer( bool value ) = 0;

		/**
		 * If set, and using the reduction processor, the reduction will be weighted based 
		 * on the weights in the "VertexWeights" vertex field. 
		 */
		virtual	bool GetUseVertexWeightsInReducer(  ) = 0;

		/**
		 * If set, and generating new texcoords using either the parameterizeror the chart 
		 * aggregator, the relative sizes of the output charts willbe scaled using the 
		 * weights in the "VertexWeights" vertex field. 
		 * @param value The desired flag value. 
		 */
		virtual	void SetUseVertexWeightsInTexcoordGenerator( bool value ) = 0;

		/**
		 * If set, and generating new texcoords using either the parameterizeror the chart 
		 * aggregator, the relative sizes of the output charts willbe scaled using the 
		 * weights in the "VertexWeights" vertex field. 
		 */
		virtual	bool GetUseVertexWeightsInTexcoordGenerator(  ) = 0;

		/**
		 * If the name of an existing vertex color field in the input geometry is set 
		 * here, the existing VertexWeights field will be overwritten by a set created 
		 * by converting the selected color field according to the other WeightsFromColor 
		 * settings in this settings object. If both ColorName and the corresponding ColorLevel 
		 * is set, the processors will prioritize the name. 
		 * @param value The desired vertex color field name. 
		 */
		virtual	void SetWeightsFromColorName( const char * value ) = 0;

		/**
		 * If the name of an existing vertex color field in the input geometry is set 
		 * here, the existing VertexWeights field will be overwritten by a set created 
		 * by converting the selected color field according to the other WeightsFromColor 
		 * settings in this settings object. If both ColorName and the corresponding ColorLevel 
		 * is set, the processors will prioritize the name. 
		 */
		virtual	spString GetWeightsFromColorName(  ) = 0;

		/**
		 * If the index of an existing vertex color field in the input geometry is set 
		 * here, the existing VertexWeights field will be overwritten by a set created 
		 * byconverting the selected color field according to the other WeightsFromColor 
		 * settings in this settings object. If both this and the corresponding ColorName 
		 * is set, the processors will prioritize the name. 
		 * @param value The desired vertex color field level. Value cannot be less than 
		 * -1. 
		 */
		virtual	void SetWeightsFromColorLevel( rid value ) = 0;

		/**
		 * If the index of an existing vertex color field in the input geometry is set 
		 * here, the existing VertexWeights field will be overwritten by a set created 
		 * byconverting the selected color field according to the other WeightsFromColor 
		 * settings in this settings object. If both this and the corresponding ColorName 
		 * is set, the processors will prioritize the name. 
		 */
		virtual	rid GetWeightsFromColorLevel(  ) = 0;

		/**
		 * If converting vertex colors to weights, this setting controls which color component 
		 * is used to create the weights. 
		 * @param value The desired WeightsFromColorComponent. 
		 */
		virtual	void SetWeightsFromColorComponent( Simplygon::EColorComponent value ) = 0;

		/**
		 * If converting vertex colors to weights, this setting controls which color component 
		 * is used to create the weights. 
		 */
		virtual	Simplygon::EColorComponent GetWeightsFromColorComponent(  ) = 0;

		/**
		 * If converting vertex colors to weights, this setting controls the max and min 
		 * resulting vertex weights generated by the input color. 
		 * @param value The new WeightsFromColorMultiplier. Value cannot be less than 
		 * 0.0. Value cannot be greater than 10.0. 
		 */
		virtual	void SetWeightsFromColorMultiplier( real value ) = 0;

		/**
		 * If converting vertex colors to weights, this setting controls the max and min 
		 * resulting vertex weights generated by the input color. 
		 */
		virtual	real GetWeightsFromColorMultiplier(  ) = 0;

		/**
		 * If converting vertex colors to weights, this setting along with WeightsFromColorMultiplier 
		 * controls how to map the RGBA intensity between 0-1 to weights. Standard mode 
		 * maps color intensity [0-1] to vertex weight [1/Multiplier - Multiplier]. High 
		 * mode maps color intensity [0-1] to vertex weight [1 - Multiplier]. Low mode 
		 * maps color intensity [0-1] to vertex weight [1/Multiplier - 1]. 
		 * @param value The new WeightsFromColorMode. 
		 */
		virtual	void SetWeightsFromColorMode( Simplygon::EWeightsFromColorMode value ) = 0;

		/**
		 * If converting vertex colors to weights, this setting along with WeightsFromColorMultiplier 
		 * controls how to map the RGBA intensity between 0-1 to weights. Standard mode 
		 * maps color intensity [0-1] to vertex weight [1/Multiplier - Multiplier]. High 
		 * mode maps color intensity [0-1] to vertex weight [1 - Multiplier]. Low mode 
		 * maps color intensity [0-1] to vertex weight [1/Multiplier - 1]. 
		 */
		virtual	Simplygon::EWeightsFromColorMode GetWeightsFromColorMode(  ) = 0;

	};

	/**
	 * GenerateLightmapTexCoordSettings is the interface used to manage light map uv 
	 * generation. 
	 */
	class IGenerateLightmapTexCoordSettings : public ISettingsObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IGenerateLightmapTexCoordSettings is 
		 * a or is a descendant of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IGenerateLightmapTexCoordSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IGenerateLightmapTexCoordSettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IGenerateLightmapTexCoordSettings 
		 * pointer 
		 * @return a pointer to the IGenerateLightmapTexCoordSettings object, if the cast 
		 * can be made, and a NULL pointer otherwise 
		 */

		static IGenerateLightmapTexCoordSettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IGenerateLightmapTexCoordSettings") )
				return static_cast<IGenerateLightmapTexCoordSettings*>(ptr);
			return nullptr;
		}
		/**
		 * Property for whether to generate an extra set of TexCoords for LightMapping. 
		 * @param value The new value. 
		 */
		virtual	void SetGenerateLightmapTexCoord( bool value ) = 0;

		/**
		 * Property for whether to generate an extra set of TexCoords for LightMapping. 
		 *  
		 */
		virtual	bool GetGenerateLightmapTexCoord(  ) = 0;

		/**
		 * The texture coordinate level used for storing the LightMap UVs. The texcoord 
		 * name has priority over level. If neither name or level is set then output would 
		 * be level 0. 
		 * @param value The desired texture coordinate level. Value cannot be less than 
		 * -1. Value cannot be greater than INT_MAX. 
		 */
		virtual	void SetLightmapTexCoordLevel( rid value ) = 0;

		/**
		 * The texture coordinate level used for storing the LightMap UVs. The texcoord 
		 * name has priority over level. If neither name or level is set then output would 
		 * be level 0. 
		 */
		virtual	rid GetLightmapTexCoordLevel(  ) = 0;

		/**
		 * The texture coordinate level name used for storing the generated Lightmap UVs. 
		 * If this is not set will default to level. If neither name or level is set then 
		 * output would be level 0. 
		 * @param value The TexCoord level name. 
		 * @return The current texture coordinate level name 
		 */
		virtual	void SetLightmapTexCoordName( const char * value ) = 0;

		/**
		 * The texture coordinate level name used for storing the generated Lightmap UVs. 
		 * If this is not set will default to level. If neither name or level is set then 
		 * output would be level 0. 
		 * @return The current texture coordinate level name Default value is nullptr 
		 *  
		 */
		virtual	spString GetLightmapTexCoordName(  ) = 0;

		/**
		 * Determines which method to use when aggregating the UVs. TextureSizeProportions 
		 * - Aggregated UV charts will be scaled to keep their relative pixel density 
		 * relative to all other UV charts. The user can still set the size of the output 
		 * texture maps. SurfaceArea - Aggregated UV charts will have their size set based 
		 * on its actual geometrical size. OriginalPixelDensity - The combined atlas will 
		 * be resized to fit each chart so that all charts retain the same amount of pixels 
		 * as they originally had. This will override any manually set texture size. UVSizeProportions 
		 * - Aggregated UV charts will have their size set based on its original UV size, 
		 * disregarding the size of the texture they are used in.");. 
		 * @param value The ChartAggregaotrMode value to use. 
		 */
		virtual	void SetChartAggregatorMode( Simplygon::EChartAggregatorMode value ) = 0;

		/**
		 * Determines which method to use when aggregating the UVs. TextureSizeProportions 
		 * - Aggregated UV charts will be scaled to keep their relative pixel density 
		 * relative to all other UV charts. The user can still set the size of the output 
		 * texture maps. SurfaceArea - Aggregated UV charts will have their size set based 
		 * on its actual geometrical size. OriginalPixelDensity - The combined atlas will 
		 * be resized to fit each chart so that all charts retain the same amount of pixels 
		 * as they originally had. This will override any manually set texture size. UVSizeProportions 
		 * - Aggregated UV charts will have their size set based on its original UV size, 
		 * disregarding the size of the texture they are used in.");. 
		 */
		virtual	Simplygon::EChartAggregatorMode GetChartAggregatorMode(  ) = 0;

		/**
		 * The width of the texture of the output mapping image. 
		 * @param value The value to which Width will be set. Value cannot be less than 
		 * 0. Value cannot be greater than UINT_MAX. 
		 */
		virtual	void SetTextureWidth( unsigned int value ) = 0;

		/**
		 * The width of the texture of the output mapping image. 
		 */
		virtual	unsigned int GetTextureWidth(  ) = 0;

		/**
		 * The height of the texture of the output mapping image. 
		 * @param value The value to which Height will be set. Value cannot be less than 
		 * 0. Value cannot be greater than UINT_MAX. 
		 */
		virtual	void SetTextureHeight( unsigned int value ) = 0;

		/**
		 * The height of the texture of the output mapping image. 
		 */
		virtual	unsigned int GetTextureHeight(  ) = 0;

		/**
		 * The minimum number of pixels between charts of the output mapping image. 
		 * @param value The value to which GutterSpace will be set. Value cannot be less 
		 * than 0. Value cannot be greater than UINT_MAX. 
		 */
		virtual	void SetGutterSpace( unsigned int value ) = 0;

		/**
		 * The minimum number of pixels between charts of the output mapping image. 
		 */
		virtual	unsigned int GetGutterSpace(  ) = 0;

	};

	/**
	 * Settings for the chart aggregator. 
	 */
	class IChartAggregatorSettings : public ISettingsObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IChartAggregatorSettings is a or is a 
		 * descendant of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IChartAggregatorSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IChartAggregatorSettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IChartAggregatorSettings pointer 
		 * @return a pointer to the IChartAggregatorSettings object, if the cast can be 
		 * made, and a NULL pointer otherwise 
		 */

		static IChartAggregatorSettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IChartAggregatorSettings") )
				return static_cast<IChartAggregatorSettings*>(ptr);
			return nullptr;
		}
		/**
		 * Determines which method to use when aggregating the UVs. TextureSizeProportions 
		 * - Aggregated UV charts will be scaled to keep their relative pixel density 
		 * relative to all other UV charts. The user can still set the size of the output 
		 * texture maps. SurfaceArea - Aggregated UV charts will have their size set based 
		 * on its actual geometrical size. OriginalPixelDensity - The combined atlas will 
		 * be resized to fit each chart so that all charts retain the same amount of pixels 
		 * as they originally had. This will override any manually set texture size. UVSizeProportions 
		 * - Aggregated UV charts will have their size set based on its original UV size, 
		 * disregarding the size of the texture they are used in. 
		 * @param value The ChartAggregatorMode value to use. 
		 */
		virtual	void SetChartAggregatorMode( Simplygon::EChartAggregatorMode value ) = 0;

		/**
		 * Determines which method to use when aggregating the UVs. TextureSizeProportions 
		 * - Aggregated UV charts will be scaled to keep their relative pixel density 
		 * relative to all other UV charts. The user can still set the size of the output 
		 * texture maps. SurfaceArea - Aggregated UV charts will have their size set based 
		 * on its actual geometrical size. OriginalPixelDensity - The combined atlas will 
		 * be resized to fit each chart so that all charts retain the same amount of pixels 
		 * as they originally had. This will override any manually set texture size. UVSizeProportions 
		 * - Aggregated UV charts will have their size set based on its original UV size, 
		 * disregarding the size of the texture they are used in. 
		 */
		virtual	Simplygon::EChartAggregatorMode GetChartAggregatorMode(  ) = 0;

		/**
		 * If multiple UV charts overlap and have the same material, SurfaceAreaScale 
		 * specifies which of those instances determines the the output scale. It is only 
		 * valid when the ChartAggregatorMode is SurfaceArea and SeparateOverlappingCharts 
		 * is false. 
		 * @param value The SurfaceAreaScale value to use. 
		 */
		virtual	void SetSurfaceAreaScale( Simplygon::ESurfaceAreaScale value ) = 0;

		/**
		 * If multiple UV charts overlap and have the same material, SurfaceAreaScale 
		 * specifies which of those instances determines the the output scale. It is only 
		 * valid when the ChartAggregatorMode is SurfaceArea and SeparateOverlappingCharts 
		 * is false. 
		 */
		virtual	Simplygon::ESurfaceAreaScale GetSurfaceAreaScale(  ) = 0;

		/**
		 * Only used when the TexCoordGeneratorType is ChartAggregator. Set the texture 
		 * coordinate level to get charts from. If the ChartAggregatorOriginalTexCoordName 
		 * ha been set, the ChartAggregatorOriginalTexCoordLevel is not used. 
		 * @param value The desired texture coordinate level. Value cannot be less than 
		 * -1. Value cannot be greater than INT_MAX. 
		 */
		virtual	void SetOriginalTexCoordLevel( rid value ) = 0;

		/**
		 * Only used when the TexCoordGeneratorType is ChartAggregator. Set the texture 
		 * coordinate level to get charts from. If the ChartAggregatorOriginalTexCoordName 
		 * ha been set, the ChartAggregatorOriginalTexCoordLevel is not used. 
		 */
		virtual	rid GetOriginalTexCoordLevel(  ) = 0;

		/**
		 * Only used when the TexCoordGeneratorType is ChartAggregator. Set the name of 
		 * the texture coordinate level to get charts from. If not set, it will use the 
		 * ChartAggregatorOriginalTexCoordLevel (index) instead. 
		 * @param value The desired texture coordinate level name. 
		 */
		virtual	void SetOriginalTexCoordName( const char * value ) = 0;

		/**
		 * Only used when the TexCoordGeneratorType is ChartAggregator. Set the name of 
		 * the texture coordinate level to get charts from. If not set, it will use the 
		 * ChartAggregatorOriginalTexCoordLevel (index) instead. 
		 */
		virtual	spString GetOriginalTexCoordName(  ) = 0;

		/**
		 * Only used when the TexCoordGeneratorType is ChartAggregator. If set, charts 
		 * that are overlapping in the original texture coords will be separated. 
		 * @param value The value to which ChartAggregatorSeparateOverlappingCharts is 
		 * set. 
		 */
		virtual	void SetSeparateOverlappingCharts( bool value ) = 0;

		/**
		 * Only used when the TexCoordGeneratorType is ChartAggregator. If set, charts 
		 * that are overlapping in the original texture coords will be separated. 
		 */
		virtual	bool GetSeparateOverlappingCharts(  ) = 0;

		/**
		 * Only used when the TexCoordGeneratorType is ChartAggregator. Set ChartAggregatorKeepOriginalChartProportionsFromChannel 
		 * to an SG_MATERIAL_CHANNEL_[...]. This channel determines which texture channel 
		 * to look at when determining which chart proportions to keep. 
		 * @param value The new ChartAggregatorKeepOriginalChartProportionsFromChannel 
		 * value. 
		 */
		virtual	void SetOriginalChartProportionsChannel( const char * value ) = 0;

		/**
		 * Only used when the TexCoordGeneratorType is ChartAggregator. Set ChartAggregatorKeepOriginalChartProportionsFromChannel 
		 * to an SG_MATERIAL_CHANNEL_[...]. This channel determines which texture channel 
		 * to look at when determining which chart proportions to keep. 
		 */
		virtual	spString GetOriginalChartProportionsChannel(  ) = 0;

		/**
		 * Only used when the TexCoordGeneratorType is ChartAggregator. If ChartAggregatorLockUVRotation 
		 * is enabled, only the original UV rotation will be used. Otherwise 4 rotations 
		 * are used (90 degree rotations). 
		 * @param value The new LockUVRotation. 
		 */
		virtual	void SetLockUVRotation( bool value ) = 0;

		/**
		 * Only used when the TexCoordGeneratorType is ChartAggregator. If ChartAggregatorLockUVRotation 
		 * is enabled, only the original UV rotation will be used. Otherwise 4 rotations 
		 * are used (90 degree rotations). 
		 */
		virtual	bool GetLockUVRotation(  ) = 0;

	};

	/**
	 * Settings for the parameterizer. 
	 */
	class IParameterizerSettings : public ISettingsObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IParameterizerSettings is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IParameterizerSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IParameterizerSettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IParameterizerSettings pointer 
		 * @return a pointer to the IParameterizerSettings object, if the cast can be 
		 * made, and a NULL pointer otherwise 
		 */

		static IParameterizerSettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IParameterizerSettings") )
				return static_cast<IParameterizerSettings*>(ptr);
			return nullptr;
		}
		/**
		 * Only used when the TexCoordGeneratorType is Parameterizer. The maximum allowed 
		 * texture stretch. Range 0->1. 
		 * @param value The desired maximum allowed texture stretch. Value cannot be less 
		 * than 0. Value cannot be greater than 1. 
		 */
		virtual	void SetMaxStretch( real value ) = 0;

		/**
		 * Only used when the TexCoordGeneratorType is Parameterizer. The maximum allowed 
		 * texture stretch. Range 0->1. 
		 */
		virtual	real GetMaxStretch(  ) = 0;

		/**
		 * Only used when the TexCoordGeneratorType is Parameterizer. The importance value 
		 * for trying to have as large and few charts as possible. The closer the value 
		 * is to 1, the slower it is. Having 0 means no extra focus will be put on reducing 
		 * the number of charts. Having value 1 means maximum focus will be put on reducing 
		 * the number of charts and thereby increasing the size of the charts. 
		 * @param value The desired large charts importance value. Value cannot be less 
		 * than 0. Value cannot be greater than 1. 
		 */
		virtual	void SetLargeChartsImportance( real value ) = 0;

		/**
		 * Only used when the TexCoordGeneratorType is Parameterizer. The importance value 
		 * for trying to have as large and few charts as possible. The closer the value 
		 * is to 1, the slower it is. Having 0 means no extra focus will be put on reducing 
		 * the number of charts. Having value 1 means maximum focus will be put on reducing 
		 * the number of charts and thereby increasing the size of the charts. 
		 */
		virtual	real GetLargeChartsImportance(  ) = 0;

	};
	class IFoliageSettings;

	/**
	 * Settings for the ImpostorType: BillboardCloud 
	 */
	class IBillboardCloudSettings : public ISettingsObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IBillboardCloudSettings is a or is a 
		 * descendant of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IBillboardCloudSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IBillboardCloudSettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IBillboardCloudSettings pointer 
		 * @return a pointer to the IBillboardCloudSettings object, if the cast can be 
		 * made, and a NULL pointer otherwise 
		 */

		static IBillboardCloudSettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IBillboardCloudSettings") )
				return static_cast<IBillboardCloudSettings*>(ptr);
			return nullptr;
		}
		/**
		 * Specifies how the impostors should be mapped to the scene. 
		 * @param value The BillboardMode value to use. 
		 */
		virtual	void SetBillboardMode( Simplygon::EBillboardMode value ) = 0;

		/**
		 * Specifies how the impostors should be mapped to the scene. 
		 */
		virtual	Simplygon::EBillboardMode GetBillboardMode(  ) = 0;

		/**
		 * Determines whether to prioritize generating vertical billboards which means 
		 * they will be optimized to be viewed from the side. Otherwise, if the geometry 
		 * in the input scene is mostly facing upwards/downwards then the generated billboards 
		 * will also be facing upwards/downwards which makes them not well suited to being 
		 * viewed from the side. 
		 * @param value The new value. 
		 * @return The current value. 
		 */
		virtual	void SetFavorVerticalPlanes( bool value ) = 0;

		/**
		 * Determines whether to prioritize generating vertical billboards which means 
		 * they will be optimized to be viewed from the side. Otherwise, if the geometry 
		 * in the input scene is mostly facing upwards/downwards then the generated billboards 
		 * will also be facing upwards/downwards which makes them not well suited to being 
		 * viewed from the side. 
		 * @return The current value. Default value is false 
		 */
		virtual	bool GetFavorVerticalPlanes(  ) = 0;

		/**
		 * Only applicable if BillboardMode: Foliage. Determines if the scene is intended 
		 * to be viewed from both sides without back face culling. 
		 * @param value The new value. 
		 * @return The current value. 
		 */
		virtual	void SetTwoSided( bool value ) = 0;

		/**
		 * Only applicable if BillboardMode: Foliage. Determines if the scene is intended 
		 * to be viewed from both sides without back face culling. 
		 * @return The current value. Default value is true 
		 */
		virtual	bool GetTwoSided(  ) = 0;

		/**
		 * Determines whether to prioritize accurately mapping triangles with higher visibility 
		 * to billboards. 
		 * @param value The new value. 
		 * @return The current value. 
		 */
		virtual	void SetUseVisibilityWeights( bool value ) = 0;

		/**
		 * Determines whether to prioritize accurately mapping triangles with higher visibility 
		 * to billboards. 
		 * @return The current value. Default value is true 
		 */
		virtual	bool GetUseVisibilityWeights(  ) = 0;

		/**
		 * Determines how many billboards to create. A large BillboardDensity means that 
		 * more billboards will be created to represent spatially spread out triangles 
		 * better. Having a low BillboardDensity means that fewer billboards will be created 
		 * and the distances from original leaves to billboards will get larger. The range 
		 * is 0->1. 
		 * @param value The new value. Value cannot be less than 0.0. Value cannot be 
		 * greater than 1.0. 
		 * @return The current value. 
		 */
		virtual	void SetBillboardDensity( real value ) = 0;

		/**
		 * Determines how many billboards to create. A large BillboardDensity means that 
		 * more billboards will be created to represent spatially spread out triangles 
		 * better. Having a low BillboardDensity means that fewer billboards will be created 
		 * and the distances from original leaves to billboards will get larger. The range 
		 * is 0->1. 
		 * @return The current value. Default value is 0.2 
		 */
		virtual	real GetBillboardDensity(  ) = 0;

		/**
		 * Determines the maximum billboard count. When this criteria is met, it is not 
		 * guaranteed that all triangles in the scene have been accurately mapped to a 
		 * billboard yet. Triangles that have not been mapped to a billboard within the 
		 * BillboardMaxDeviation distance will be mapped to an existing billboard that 
		 * best represents the triangle. 
		 * @param value The new value. Value cannot be less than 0. Value cannot be greater 
		 * than UINT_MAX. 
		 * @return The current value. 
		 */
		virtual	void SetMaxPlaneCount( unsigned int value ) = 0;

		/**
		 * Determines the maximum billboard count. When this criteria is met, it is not 
		 * guaranteed that all triangles in the scene have been accurately mapped to a 
		 * billboard yet. Triangles that have not been mapped to a billboard within the 
		 * BillboardMaxDeviation distance will be mapped to an existing billboard that 
		 * best represents the triangle. 
		 * @return The current value. Default value is 10 
		 */
		virtual	unsigned int GetMaxPlaneCount(  ) = 0;

		/**
		 * Determines the geometric complexity of the billboards. The value range is 0->1, 
		 * where a value of Zero means that the billboards will be simple and not follow 
		 * the projection closely. And a value of One means that the geometric complexity 
		 * will be increased and follow the projection closely. 
		 * @param value The new value. Value cannot be less than 0.0. Value cannot be 
		 * greater than 1.0. 
		 * @return The current value. 
		 */
		virtual	void SetGeometricComplexity( real value ) = 0;

		/**
		 * Determines the geometric complexity of the billboards. The value range is 0->1, 
		 * where a value of Zero means that the billboards will be simple and not follow 
		 * the projection closely. And a value of One means that the geometric complexity 
		 * will be increased and follow the projection closely. 
		 * @return The current value. Default value is 0.5 
		 */
		virtual	real GetGeometricComplexity(  ) = 0;

		/**
		 * Settings for foliage when BillboardMode is Foliage. 
		 * @return The settings for foliage. 
		 */
		virtual	spFoliageSettings GetFoliageSettings(  ) = 0;

	};

	/**
	 * Settings for the ImpostorType: FlipBook 
	 */
	class IFlipbookSettings : public ISettingsObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IFlipbookSettings is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IFlipbookSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IFlipbookSettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IFlipbookSettings pointer 
		 * @return a pointer to the IFlipbookSettings object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IFlipbookSettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IFlipbookSettings") )
				return static_cast<IFlipbookSettings*>(ptr);
			return nullptr;
		}
		/**
		 * Determines the number of views generated for the flip book impostor. 
		 * @param value The new value. Value cannot be less than 0. Value cannot be greater 
		 * than 64. 
		 * @return The current value. 
		 */
		virtual	void SetNumberOfViews( unsigned int value ) = 0;

		/**
		 * Determines the number of views generated for the flip book impostor. 
		 * @return The current value. Default value is 9 
		 */
		virtual	unsigned int GetNumberOfViews(  ) = 0;

		/**
		 * This vector determines the direction of the first view. The rest of the views 
		 * are uniformly distributed around the scene rotated around the up-vector. The 
		 * resulting billboard will be oriented in the negative view direction. 
		 * @param value_realInputDataPtr The new view vector. 
		 */
		virtual	void SetViewDirection( const real *value_realInputDataPtr ) = 0;

		/**
		 * This vector determines the direction of the first view. The rest of the views 
		 * are uniformly distributed around the scene rotated around the up-vector. The 
		 * resulting billboard will be oriented in the negative view direction. 
		 * @return The returned data array. The array contains 3 items. 
		 */
		virtual	spRealData GetViewDirection(  ) = 0;

		/**
		 * The X component of the ViewDirection vector. The ViewDirection determines the 
		 * direction of the first view. The rest of the views are uniformly distributed 
		 * around the scene rotated around the up-vector. The resulting billboard will 
		 * be oriented in the negative view direction. 
		 * @param value The new view vector X component. Value cannot be less than -REAL_MAX. 
		 * Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetViewDirectionX( real value ) = 0;

		/**
		 * The X component of the ViewDirection vector. The ViewDirection determines the 
		 * direction of the first view. The rest of the views are uniformly distributed 
		 * around the scene rotated around the up-vector. The resulting billboard will 
		 * be oriented in the negative view direction. 
		 */
		virtual	real GetViewDirectionX(  ) = 0;

		/**
		 * The Y component of the ViewDirection vector. The ViewDirection determines the 
		 * direction of the first view. The rest of the views are uniformly distributed 
		 * around the scene rotated around the up-vector. The resulting billboard will 
		 * be oriented in the negative view direction. 
		 * @param value The new view vector Y component. Value cannot be less than -REAL_MAX. 
		 * Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetViewDirectionY( real value ) = 0;

		/**
		 * The Y component of the ViewDirection vector. The ViewDirection determines the 
		 * direction of the first view. The rest of the views are uniformly distributed 
		 * around the scene rotated around the up-vector. The resulting billboard will 
		 * be oriented in the negative view direction. 
		 */
		virtual	real GetViewDirectionY(  ) = 0;

		/**
		 * The Z component of the ViewDirection vector. The ViewDirection determines the 
		 * direction of the first view. The rest of the views are uniformly distributed 
		 * around the scene rotated around the up-vector. The resulting billboard will 
		 * be oriented in the negative view direction. 
		 * @param value The new view vector Z component. Value cannot be less than -REAL_MAX. 
		 * Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetViewDirectionZ( real value ) = 0;

		/**
		 * The Z component of the ViewDirection vector. The ViewDirection determines the 
		 * direction of the first view. The rest of the views are uniformly distributed 
		 * around the scene rotated around the up-vector. The resulting billboard will 
		 * be oriented in the negative view direction. 
		 */
		virtual	real GetViewDirectionZ(  ) = 0;

		/**
		 * The views are rotated around the up vector and the rendered images are oriented 
		 * with the up vector. 
		 * @param value_realInputDataPtr The new up vector. 
		 */
		virtual	void SetUpVector( const real *value_realInputDataPtr ) = 0;

		/**
		 * The views are rotated around the up vector and the rendered images are oriented 
		 * with the up vector. 
		 * @return The returned data array. The array contains 3 items. 
		 */
		virtual	spRealData GetUpVector(  ) = 0;

		/**
		 * The views are rotated around the up vector and the rendered images are oriented 
		 * with the up vector. 
		 * @param value The new up vector X component. Value cannot be less than -REAL_MAX. 
		 * Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetUpVectorX( real value ) = 0;

		/**
		 * The views are rotated around the up vector and the rendered images are oriented 
		 * with the up vector. 
		 */
		virtual	real GetUpVectorX(  ) = 0;

		/**
		 * The views are rotated around the up vector and the rendered images are oriented 
		 * with the up vector. 
		 * @param value The new up vector Y component. Value cannot be less than -REAL_MAX. 
		 * Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetUpVectorY( real value ) = 0;

		/**
		 * The views are rotated around the up vector and the rendered images are oriented 
		 * with the up vector. 
		 */
		virtual	real GetUpVectorY(  ) = 0;

		/**
		 * The views are rotated around the up vector and the rendered images are oriented 
		 * with the up vector. 
		 * @param value The new up vector Z component. Value cannot be less than -REAL_MAX. 
		 * Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetUpVectorZ( real value ) = 0;

		/**
		 * The views are rotated around the up vector and the rendered images are oriented 
		 * with the up vector. 
		 */
		virtual	real GetUpVectorZ(  ) = 0;

		/**
		 * @deprecated Method is marked as deprecated and will be removed in future version. 
		 * Use \link ViewDirection ViewDirection() \endlink instead. Deprecated: Use ViewDirection 
		 * and UpVector instead. 
		 * @param value The new value. Value cannot be less than -90. Value cannot be 
		 * greater than 90. 
		 * @return The current value. 
		 */
		virtual	SGDEPRECATED void SetVerticalAngle( real value ) = 0;

		/**
		 * @deprecated Method is marked as deprecated and will be removed in future version. 
		 * Use \link ViewDirection ViewDirection() \endlink instead. Deprecated: Use ViewDirection 
		 * and UpVector instead. 
		 * @return The current value. Default value is 0 
		 */
		virtual	SGDEPRECATED real GetVerticalAngle(  ) = 0;

	};

	/**
	 * Settings for the ImpostorType: ImpostorFromSingleView. 
	 */
	class IImpostorFromSingleViewSettings : public ISettingsObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IImpostorFromSingleViewSettings is a 
		 * or is a descendant of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IImpostorFromSingleViewSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IImpostorFromSingleViewSettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IImpostorFromSingleViewSettings 
		 * pointer 
		 * @return a pointer to the IImpostorFromSingleViewSettings object, if the cast 
		 * can be made, and a NULL pointer otherwise 
		 */

		static IImpostorFromSingleViewSettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IImpostorFromSingleViewSettings") )
				return static_cast<IImpostorFromSingleViewSettings*>(ptr);
			return nullptr;
		}
		/**
		 * If set, the impostor will exactly conform to the bounds of the geometry. If 
		 * false, its dimensions will always be diameter*diameter. 
		 * @param value The value UseTightFitting will be set to. 
		 */
		virtual	void SetUseTightFitting( bool value ) = 0;

		/**
		 * If set, the impostor will exactly conform to the bounds of the geometry. If 
		 * false, its dimensions will always be diameter*diameter. 
		 */
		virtual	bool GetUseTightFitting(  ) = 0;

		/**
		 * This determines where the impostor will end up in depth. 0 is "center", 1 is 
		 * "front" and -1 is "back". 
		 * @param value The desired value TightFittingDepthOffset will be set to. Value 
		 * cannot be less than -1.0. Value cannot be greater than 1.0. 
		 */
		virtual	void SetTightFittingDepthOffset( real value ) = 0;

		/**
		 * This determines where the impostor will end up in depth. 0 is "center", 1 is 
		 * "front" and -1 is "back". 
		 */
		virtual	real GetTightFittingDepthOffset(  ) = 0;

		/**
		 * If set, the impostor will contain both front and back facing surfaces. 
		 * @param value The new TwoSided value. 
		 */
		virtual	void SetTwoSided( bool value ) = 0;

		/**
		 * If set, the impostor will contain both front and back facing surfaces. 
		 */
		virtual	bool GetTwoSided(  ) = 0;

		/**
		 * This vector determines how the resulting impostor geometry will be oriented. 
		 * The billboard will be perpendicular to this vector. 
		 * @param value_realInputDataPtr The new view vector. 
		 */
		virtual	void SetViewDirection( const real *value_realInputDataPtr ) = 0;

		/**
		 * This vector determines how the resulting impostor geometry will be oriented. 
		 * The billboard will be perpendicular to this vector. 
		 * @return The returned data array. The array contains 3 items. 
		 */
		virtual	spRealData GetViewDirection(  ) = 0;

		/**
		 * The X component of the ViewDirection vector. The ViewDirection determines how 
		 * the resulting impostor geometry will be oriented. The billboard will be perpendicular 
		 * to this vector. 
		 * @param value The new view vector X component. Value cannot be less than -REAL_MAX. 
		 * Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetViewDirectionX( real value ) = 0;

		/**
		 * The X component of the ViewDirection vector. The ViewDirection determines how 
		 * the resulting impostor geometry will be oriented. The billboard will be perpendicular 
		 * to this vector. 
		 */
		virtual	real GetViewDirectionX(  ) = 0;

		/**
		 * The Y component of the ViewDirection vector. The ViewDirection determines how 
		 * the resulting impostor geometry will be oriented. The billboard will be perpendicular 
		 * to this vector. 
		 * @param value The new view vector Y component. Value cannot be less than -REAL_MAX. 
		 * Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetViewDirectionY( real value ) = 0;

		/**
		 * The Y component of the ViewDirection vector. The ViewDirection determines how 
		 * the resulting impostor geometry will be oriented. The billboard will be perpendicular 
		 * to this vector. 
		 */
		virtual	real GetViewDirectionY(  ) = 0;

		/**
		 * The Z component of the ViewDirection vector. The ViewDirection determines how 
		 * the resulting impostor geometry will be oriented. The billboard will be perpendicular 
		 * to this vector. 
		 * @param value The new view vector Z component. Value cannot be less than -REAL_MAX. 
		 * Value cannot be greater than REAL_MAX. 
		 */
		virtual	void SetViewDirectionZ( real value ) = 0;

		/**
		 * The Z component of the ViewDirection vector. The ViewDirection determines how 
		 * the resulting impostor geometry will be oriented. The billboard will be perpendicular 
		 * to this vector. 
		 */
		virtual	real GetViewDirectionZ(  ) = 0;

		/**
		 * Normally, the processor will generate an impostor with texcoords from 0.0 to 
		 * 1.0, giving perfect UV coverage in the final texture. If your engine uses permanent 
		 * tiling rendering mode, you may need to add a small padding to avoid sub-pixel 
		 * wrapping artifact at the impostor edges, which this setting supplies. Ex: Setting 
		 * this to 0.01 will generate texcoords in the range 0.01 to 0.99. 
		 * @param value The desired value TexCoordPadding will be set to. Value cannot 
		 * be less than 0.0. Value cannot be greater than 0.5. 
		 */
		virtual	void SetTexCoordPadding( real value ) = 0;

		/**
		 * Normally, the processor will generate an impostor with texcoords from 0.0 to 
		 * 1.0, giving perfect UV coverage in the final texture. If your engine uses permanent 
		 * tiling rendering mode, you may need to add a small padding to avoid sub-pixel 
		 * wrapping artifact at the impostor edges, which this setting supplies. Ex: Setting 
		 * this to 0.01 will generate texcoords in the range 0.01 to 0.99. 
		 */
		virtual	real GetTexCoordPadding(  ) = 0;

	};
	class IImpostorFromSingleViewSettings;

	/**
	 * ImpostorFromSingleViewPipeline provides a pipeline for a impostor from single 
	 * view impostor processor to be applied on the input scene. 
	 */
	class IImpostorFromSingleViewPipeline : public IPipeline
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IImpostorFromSingleViewPipeline is a 
		 * or is a descendant of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IImpostorFromSingleViewPipeline",type)==0 )
				return true;
			return IPipeline::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IImpostorFromSingleViewPipeline 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IImpostorFromSingleViewPipeline 
		 * pointer 
		 * @return a pointer to the IImpostorFromSingleViewPipeline object, if the cast 
		 * can be made, and a NULL pointer otherwise 
		 */

		static IImpostorFromSingleViewPipeline *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IImpostorFromSingleViewPipeline") )
				return static_cast<IImpostorFromSingleViewPipeline*>(ptr);
			return nullptr;
		}
		/**
		 * The ImpostorFromSingleViewPipeline settings object containing the imposter 
		 * settings from a single view for this pipeline. 
		 * @return The ImpostorFromSingleView settings 
		 */
		virtual	spImpostorFromSingleViewSettings GetImpostorFromSingleViewSettings(  ) = 0;

	};
	class IBillboardCloudSettings;

	/**
	 * BillboardCloudPipeline provides a pipeline for a billboard cloud impostor processor 
	 * to be applied on the input scene. 
	 */
	class IBillboardCloudPipeline : public IPipeline
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IBillboardCloudPipeline is a or is a 
		 * descendant of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IBillboardCloudPipeline",type)==0 )
				return true;
			return IPipeline::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IBillboardCloudPipeline 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IBillboardCloudPipeline pointer 
		 * @return a pointer to the IBillboardCloudPipeline object, if the cast can be 
		 * made, and a NULL pointer otherwise 
		 */

		static IBillboardCloudPipeline *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IBillboardCloudPipeline") )
				return static_cast<IBillboardCloudPipeline*>(ptr);
			return nullptr;
		}
		/**
		 * The billboard cloud settings object containing the billboard cloud settings 
		 * for this pipeline. 
		 * @return The billboard cloud settings 
		 */
		virtual	spBillboardCloudSettings GetBillboardCloudSettings(  ) = 0;

	};
	class IBillboardCloudSettings;

	/**
	 * BillboardCloudPipeline provides a pipeline for a billboard cloud vegetation 
	 * impostor processor to be applied on the input scene. 
	 */
	class IBillboardCloudVegetationPipeline : public IPipeline
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IBillboardCloudVegetationPipeline is 
		 * a or is a descendant of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IBillboardCloudVegetationPipeline",type)==0 )
				return true;
			return IPipeline::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IBillboardCloudVegetationPipeline 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IBillboardCloudVegetationPipeline 
		 * pointer 
		 * @return a pointer to the IBillboardCloudVegetationPipeline object, if the cast 
		 * can be made, and a NULL pointer otherwise 
		 */

		static IBillboardCloudVegetationPipeline *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IBillboardCloudVegetationPipeline") )
				return static_cast<IBillboardCloudVegetationPipeline*>(ptr);
			return nullptr;
		}
		/**
		 * The billboard cloud settings object containing the billboard cloud settings 
		 * for this pipeline. 
		 * @return The billboard cloud settings 
		 */
		virtual	spBillboardCloudSettings GetBillboardCloudSettings(  ) = 0;

	};
	class IFlipbookSettings;

	/**
	 * FlipbookPipeline provides a pipeline for a flipbook impostor processor to be 
	 * applied on the input scene. 
	 */
	class IFlipbookPipeline : public IPipeline
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IFlipbookPipeline is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IFlipbookPipeline",type)==0 )
				return true;
			return IPipeline::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IFlipbookPipeline 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IFlipbookPipeline pointer 
		 * @return a pointer to the IFlipbookPipeline object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IFlipbookPipeline *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IFlipbookPipeline") )
				return static_cast<IFlipbookPipeline*>(ptr);
			return nullptr;
		}
		/**
		 * The flipbook settings object containing the flipbook settings for this pipeline. 
		 * @return The flipbook settings 
		 */
		virtual	spFlipbookSettings GetFlipbookSettings(  ) = 0;

	};

	/**
	 * Settings for the BillboardMode: Foliage 
	 */
	class IFoliageSettings : public ISettingsObject
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IFoliageSettings is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IFoliageSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IFoliageSettings 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IFoliageSettings pointer 
		 * @return a pointer to the IFoliageSettings object, if the cast can be made, 
		 * and a NULL pointer otherwise 
		 */

		static IFoliageSettings *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IFoliageSettings") )
				return static_cast<IFoliageSettings*>(ptr);
			return nullptr;
		}
		/**
		 * Determines whether to enable separation between foliage and trunk in a vegetation 
		 * scene. Use the SeparateFoliage[...] settings to determine how parts are separated. 
		 * @param value The new value. 
		 * @return The current value. 
		 */
		virtual	void SetSeparateTrunkAndFoliage( bool value ) = 0;

		/**
		 * Determines whether to enable separation between foliage and trunk in a vegetation 
		 * scene. Use the SeparateFoliage[...] settings to determine how parts are separated. 
		 * @return The current value. Default value is false 
		 */
		virtual	bool GetSeparateTrunkAndFoliage(  ) = 0;

		/**
		 * Is used to separate the trunk from the foliage in a vegetation scene by comparing 
		 * each group of connected triangles in the scene with the scene's largest group. 
		 * If a group's triangle count is below SeparateFoliageTriangleRatio * largestGrouptriangleCount 
		 * it is treated as foliage and processed into billboards. The trunk is optimized 
		 * using triangle reduction. The range is 0.0->1.0. 0.0 means nothing will be 
		 * foliage, 1.0 means everything will be foliage. 
		 * @param value The new value. Value cannot be less than 0.0. Value cannot be 
		 * greater than 1.0. 
		 * @return The current value. 
		 */
		virtual	void SetSeparateFoliageTriangleRatio( real value ) = 0;

		/**
		 * Is used to separate the trunk from the foliage in a vegetation scene by comparing 
		 * each group of connected triangles in the scene with the scene's largest group. 
		 * If a group's triangle count is below SeparateFoliageTriangleRatio * largestGrouptriangleCount 
		 * it is treated as foliage and processed into billboards. The trunk is optimized 
		 * using triangle reduction. The range is 0.0->1.0. 0.0 means nothing will be 
		 * foliage, 1.0 means everything will be foliage. 
		 * @return The current value. Default value is 0.01 
		 */
		virtual	real GetSeparateFoliageTriangleRatio(  ) = 0;

		/**
		 * Is used to separate the trunk from the foliage in a vegetation scene by finding 
		 * each group of connected triangles in the scene and if the triangle count is 
		 * below SeparateFoliageTriangleThreshold it is treated as foliage and processed 
		 * into billboards. The trunk is optimized using reduction. The range is 0->large 
		 * value. 0 means nothing will be foliage, value larger than the maximum triangle 
		 * count means everything will be foliage. 
		 * @param value The new value. Value cannot be less than 0. Value cannot be greater 
		 * than UINT_MAX. 
		 * @return The current value. 
		 */
		virtual	void SetSeparateFoliageTriangleThreshold( unsigned int value ) = 0;

		/**
		 * Is used to separate the trunk from the foliage in a vegetation scene by finding 
		 * each group of connected triangles in the scene and if the triangle count is 
		 * below SeparateFoliageTriangleThreshold it is treated as foliage and processed 
		 * into billboards. The trunk is optimized using reduction. The range is 0->large 
		 * value. 0 means nothing will be foliage, value larger than the maximum triangle 
		 * count means everything will be foliage. 
		 * @return The current value. Default value is 10 
		 */
		virtual	unsigned int GetSeparateFoliageTriangleThreshold(  ) = 0;

		/**
		 * Is used to separate the trunk from the foliage in a vegetation scene by finding 
		 * each group of connected triangles in the scene and if the surface area is below 
		 * (SeparateFoliageAreaThreshold * AreaOfTheLargestGroupInTheScene) it is treated 
		 * as foliage and processed into billboards. The trunk is optimized using reduction. 
		 * The range is 0->large value. 0 means nothing will be foliage, value larger 
		 * than the maximum surface area means everything will be foliage. 
		 * @param value The new value. Value cannot be less than 0. Value cannot be greater 
		 * than REAL_MAX. 
		 * @return The current value. 
		 */
		virtual	void SetSeparateFoliageAreaThreshold( real value ) = 0;

		/**
		 * Is used to separate the trunk from the foliage in a vegetation scene by finding 
		 * each group of connected triangles in the scene and if the surface area is below 
		 * (SeparateFoliageAreaThreshold * AreaOfTheLargestGroupInTheScene) it is treated 
		 * as foliage and processed into billboards. The trunk is optimized using reduction. 
		 * The range is 0->large value. 0 means nothing will be foliage, value larger 
		 * than the maximum surface area means everything will be foliage. 
		 * @return The current value. Default value is 0.1 
		 */
		virtual	real GetSeparateFoliageAreaThreshold(  ) = 0;

		/**
		 * Is used to separate the trunk from the foliage in a vegetation scene by finding 
		 * each group of connected triangles in the scene and if the diameter of the group 
		 * is below (SeparateFoliageSizeThreshold * SceneDiameter) it is treated as foliage 
		 * and processed into billboards. The trunk is optimized using reduction. The 
		 * range is 0->large value. 0 means nothing will be foliage, value larger than 
		 * the scene's diameter means everything will be foliage. 
		 * @param value The new value. Value cannot be less than 0. Value cannot be greater 
		 * than REAL_MAX. 
		 * @return The current value. 
		 */
		virtual	void SetSeparateFoliageSizeThreshold( real value ) = 0;

		/**
		 * Is used to separate the trunk from the foliage in a vegetation scene by finding 
		 * each group of connected triangles in the scene and if the diameter of the group 
		 * is below (SeparateFoliageSizeThreshold * SceneDiameter) it is treated as foliage 
		 * and processed into billboards. The trunk is optimized using reduction. The 
		 * range is 0->large value. 0 means nothing will be foliage, value larger than 
		 * the scene's diameter means everything will be foliage. 
		 * @return The current value. Default value is 0.1 
		 */
		virtual	real GetSeparateFoliageSizeThreshold(  ) = 0;

		/**
		 * Determines the triangle reduction ratio for the trunk part that has been separated 
		 * from the foliage part based on the "separate foliage" settings. 
		 * @param value The new value. Value cannot be less than 0.0. Value cannot be 
		 * greater than 1.0. 
		 * @return The current value. 
		 */
		virtual	void SetTrunkReductionRatio( real value ) = 0;

		/**
		 * Determines the triangle reduction ratio for the trunk part that has been separated 
		 * from the foliage part based on the "separate foliage" settings. 
		 * @return The current value. Default value is 0.5 
		 */
		virtual	real GetTrunkReductionRatio(  ) = 0;

	};

	/**
	 * StringArray is the string implementation of ValueArray. See ValueArray for a 
	 * description. 
	 */
	class IStringArray : public IValueArray
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IStringArray is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IStringArray",type)==0 )
				return true;
			return IValueArray::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IStringArray 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IStringArray pointer 
		 * @return a pointer to the IStringArray object, if the cast can be made, and 
		 * a NULL pointer otherwise 
		 */

		static IStringArray *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IStringArray") )
				return static_cast<IStringArray*>(ptr);
			return nullptr;
		}
		/**
		 * Adds an item to the list, allocates memory as needed to enlarge the list. If 
		 * many items are being put into the list, use Resize to set the size of the new 
		 * list (only one reallocation needed) and then use SetItem() / SetTuple() to 
		 * set the items directly. 
		 * @param value The value of the item. 
		 */
		virtual	void AddItem( const char * value ) = 0;

		/**
		 * Sets an item in the list. The id of the item is the exact location of the item 
		 * (TupleId * TupleSize + Index of item in tuple) Warning! No range checking is 
		 * done. 
		 * @param id The id of the item. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxItemId(). 
		 * @param value The new value of the item. 
		 */
		virtual	void SetItem( rid id , const char * value ) = 0;

		/**
		 * Gets the value of an item in the list. The id of the item is the exact location 
		 * of the item (TupleId * TupleSize + Index of item in tuple) Warning! No range 
		 * checking is done. 
		 * @param id The id of the item. Value cannot be less than 0. Value cannot be 
		 * greater than the value returned by GetMaxItemId(). 
		 */
		virtual	spString GetItem( rid id ) = 0;

	};
	class IOcclusionMeshSettings;

	/**
	 * OcclusionMeshPipeline provides a pipeline for a single occlusion mesh processor 
	 * to be applied on the input scene. 
	 */
	class IOcclusionMeshPipeline : public IPipeline
	{
		public:
		/**
		 * GetClass returns the name of the class of the object. 
		 * @return the name of the actual class of the object, as a const char string 
		 *  
		 */

		virtual spString GetClass();

		/**
		 * The IsA function returns true if the object is a or is a descendant of the 
		 * class named as the type parameter 
		 * @param type is the name of the class to check if the object is, or is a descendant 
		 * of 
		 * @return true if the object is of the specified class, false if not 
		 */

		virtual bool IsA( const char *type ) const;

		/**
		 * The IsClassA function returns true if IOcclusionMeshPipeline is a or is a descendant 
		 * of the class named as the type parameter 
		 * @param type is the name of the class to check if the class is, or is a descendant 
		 * of 
		 * @return true if the class is of the specified class, false if not 
		 */

		static bool IsClassA( const char *type )
		{
			if( !type )
				return false;
			if( strcmp("IOcclusionMeshPipeline",type)==0 )
				return true;
			return IPipeline::IsClassA(type);
		}

		/**
		 * SafeCast makes sure the pointer is of a class that can be cast into a IOcclusionMeshPipeline 
		 * pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IOcclusionMeshPipeline pointer 
		 * @return a pointer to the IOcclusionMeshPipeline object, if the cast can be 
		 * made, and a NULL pointer otherwise 
		 */

		static IOcclusionMeshPipeline *SafeCast( IObject *ptr )
		{
			if( ptr && ptr->IsA("IOcclusionMeshPipeline") )
				return static_cast<IOcclusionMeshPipeline*>(ptr);
			return nullptr;
		}
		/**
		 * The occlusion mesh settings object containing the occlusion mesh settings for 
		 * this pipeline. 
		 * @return The occlusion mesh settings 
		 */
		virtual	spOcclusionMeshSettings GetOcclusionMeshSettings(  ) = 0;

	};

	class ISimplygon
	{
		public:
		/**
		 * Creates and returns a counted pointer to an object of type IBoolArray
		 * Documentation from IBoolArray:
		 * BoolArray is the bool implementation of ValueArray. See ValueArray for a description. 
		 * @return the created object, of type spBoolArray
		 */
		virtual spBoolArray CreateBoolArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ICharArray
		 * Documentation from ICharArray:
		 * CharArray is the char implementation of ValueArray. See ValueArray for a description. 
		 * @return the created object, of type spCharArray
		 */
		virtual spCharArray CreateCharArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IDoubleArray
		 * Documentation from IDoubleArray:
		 * DoubleArray is the double implementation of ValueArray. See ValueArray for 
		 * a description. 
		 * @return the created object, of type spDoubleArray
		 */
		virtual spDoubleArray CreateDoubleArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IFloatArray
		 * Documentation from IFloatArray:
		 * FloatArray is the float implementation of ValueArray. See ValueArray for a 
		 * description. 
		 * @return the created object, of type spFloatArray
		 */
		virtual spFloatArray CreateFloatArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IIntArray
		 * Documentation from IIntArray:
		 * IntArray is the int implementation of ValueArray. See ValueArray for a description. 
		 * @return the created object, of type spIntArray
		 */
		virtual spIntArray CreateIntArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ILongArray
		 * Documentation from ILongArray:
		 * LongArray is the long implementation of ValueArray. See ValueArray for a description. 
		 * @return the created object, of type spLongArray
		 */
		virtual spLongArray CreateLongArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IRealArray
		 * Documentation from IRealArray:
		 * RealArray is the real implementation of ValueArray. See ValueArray for a description. 
		 * @return the created object, of type spRealArray
		 */
		virtual spRealArray CreateRealArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IRidArray
		 * Documentation from IRidArray:
		 * RidArray is the rid implementation of ValueArray. See ValueArray for a description. 
		 * @return the created object, of type spRidArray
		 */
		virtual spRidArray CreateRidArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShortArray
		 * Documentation from IShortArray:
		 * ShortArray is the short implementation of ValueArray. See ValueArray for a 
		 * description. 
		 * @return the created object, of type spShortArray
		 */
		virtual spShortArray CreateShortArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IUnsignedCharArray
		 * Documentation from IUnsignedCharArray:
		 * UnsignedCharArray is the uchar implementation of ValueArray. See ValueArray 
		 * for a description. 
		 * @return the created object, of type spUnsignedCharArray
		 */
		virtual spUnsignedCharArray CreateUnsignedCharArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IUnsignedIntArray
		 * Documentation from IUnsignedIntArray:
		 * UnsignedIntArray is the uint implementation of ValueArray. See ValueArray for 
		 * a description. 
		 * @return the created object, of type spUnsignedIntArray
		 */
		virtual spUnsignedIntArray CreateUnsignedIntArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IUnsignedLongArray
		 * Documentation from IUnsignedLongArray:
		 * UnsignedLongArray is the ulong implementation of ValueArray. See ValueArray 
		 * for a description. 
		 * @return the created object, of type spUnsignedLongArray
		 */
		virtual spUnsignedLongArray CreateUnsignedLongArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IUnsignedShortArray
		 * Documentation from IUnsignedShortArray:
		 * UnsignedShortArray is the ushort implementation of ValueArray. See ValueArray 
		 * for a description. 
		 * @return the created object, of type spUnsignedShortArray
		 */
		virtual spUnsignedShortArray CreateUnsignedShortArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IDirectXRenderer
		 * Documentation from IDirectXRenderer:
		 * A Renderer using DirectX 11 that can be used to preview a scene object containing 
		 * geometry data by rendering it from selected SceneCamera nodes within the given 
		 * scene and then storing the frames to disc. If using a Shading Node Network 
		 * (having an IShadingNode assigned to the IMaterial), then the material can be 
		 * previewed with the generated HLSL shader. 
		 * @return the created object, of type spDirectXRenderer
		 */
		virtual spDirectXRenderer CreateDirectXRenderer() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IGeometryData
		 * Documentation from IGeometryData:
		 * GeometryData represents a geometric structure consisting of point data (Vertices) 
		 * and topological data (Triangles). GeometryData may represent a whole geometric 
		 * object, but can also be used by streaming data filters, and in this way, only 
		 * represents a part of the object. Different fields in the Vertices and Triangles 
		 * fields data objects will contain point data and topological data. The standard 
		 * naming convention used in the filters/renderers are as follows: (Case sensitive 
		 * naming, other fields may also be present) 'Coords' Positional coordinates of 
		 * a vertex, expressed with a 3-component real field (XYZ). 'TexCoords0' - 'TexCoords255' 
		 *  Texture coordinates of a vertex, expressed with a 2 components real field. 
		 * By convention, the existing fields must be sequential, and must start with 
		 * 'TexCoord0'. 'Normals' Normal vector for the vertex, expressed with a 3-component 
		 * real field, a normalized (XYZ) vector. 'VertexIds' The id of the current vertex 
		 * in the primitive. This field is present even if the vertex data is directly 
		 * specified in the primitive data, to specify topology. The field is of type 
		 * rid. 'MaterialIds' The material of the primitive. The field is of type rid. 
		 *  The 'Coords' and 'VertexIds' fields always exist in the object, but the other 
		 * fields are optional. Also, there can exist user fields. 
		 * @return the created object, of type spGeometryData
		 */
		virtual spGeometryData CreateGeometryData() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IPackedGeometryData
		 * Documentation from IPackedGeometryData:
		 * PackedGeometryData keeps the same information as GeometryData, but with all 
		 * corner data fields moved into per-vertex fields. No per-corner fields exist, 
		 * apart from the VertexIds field. Please note that the number of vertices in 
		 * an PackedGeometryData is commonly higher than in an GeometryData, as vertices 
		 * must be split to accommodate for different corner data. 
		 * @return the created object, of type spPackedGeometryData
		 */
		virtual spPackedGeometryData CreatePackedGeometryData() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IImageData
		 * Documentation from IImageData:
		 * ImageData holds unpacked image data. The data is stored in an FieldData object 
		 * as value fields. For simplicity all images are implemented as 3D images, but 
		 * has an extent of 1 in Z for 2D images, and an extent of 1 in both Y and Z for 
		 * 1D images. Cube maps are stored as a 3D image with Z-depth of 6 (one for each 
		 * side) 
		 * @return the created object, of type spImageData
		 */
		virtual spImageData CreateImageData() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ITable
		 * Documentation from ITable:
		 * Table is the base class for tables objects, where items are added into an id-indexed 
		 * array of objects. 
		 * @return the created object, of type spTable
		 */
		virtual spTable CreateTable() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IMaterial
		 * Documentation from IMaterial:
		 * Material object that keeps material information used while rendering. 
		 * @return the created object, of type spMaterial
		 */
		virtual spMaterial CreateMaterial() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IMaterialTable
		 * Documentation from IMaterialTable:
		 * MaterialTable keeps information on materials used while rendering. 
		 * @return the created object, of type spMaterialTable
		 */
		virtual spMaterialTable CreateMaterialTable() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IMatrix4x4
		 * Documentation from IMatrix4x4:
		 * Matrix4x4 is used to represent and manipulate 4x4 transformation matrices, 
		 * which can be either standard matrices, or homogeneous 4x4 matrices used to 
		 * transform 3D homogeneous coordinates [x y z w]. The transformations are defined 
		 * in row-major order. 
		 * @return the created object, of type spMatrix4x4
		 */
		virtual spMatrix4x4 CreateMatrix4x4() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ITransform3
		 * Documentation from ITransform3:
		 * Transform3 handles homogeneous 4x4 transforms, i.e. transformations which can 
		 * be represented by multiplying a 4x4 matrix with a homogeneous 3D coordinate. 
		 * Transform3 can either pre-multiply a matrix onto the transformation, which 
		 * will add a transform around the current transform, or it can post-multiply 
		 * the matrix, which will add a transform inside the current transform. Post-multiply 
		 * is the default mode. 
		 * @return the created object, of type spTransform3
		 */
		virtual spTransform3 CreateTransform3() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IParameterizer
		 * Documentation from IParameterizer:
		 * Computes texture coordinates for arbitrary geometry. 
		 * @return the created object, of type spParameterizer
		 */
		virtual spParameterizer CreateParameterizer() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IObjectCollection
		 * Documentation from IObjectCollection:
		 * ObjectCollection and its specializations handles a collection of Objects. There 
		 * are methods for adding, removing and iterating through the objects. 
		 * @return the created object, of type spObjectCollection
		 */
		virtual spObjectCollection CreateObjectCollection() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IGeometryDataCollection
		 * Documentation from IGeometryDataCollection:
		 * GeometryDataCollection holds a number of GeometryData objects. The objects 
		 * can be looked up by their names (if they have been named with a call to SetName). 
		 * @return the created object, of type spGeometryDataCollection
		 */
		virtual spGeometryDataCollection CreateGeometryDataCollection() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IWavefrontImporter
		 * Documentation from IWavefrontImporter:
		 * OBJ scene importer 
		 * @return the created object, of type spWavefrontImporter
		 */
		virtual spWavefrontImporter CreateWavefrontImporter() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IGLTFImporter
		 * Documentation from IGLTFImporter:
		 * glTF scene importer 
		 * @return the created object, of type spGLTFImporter
		 */
		virtual spGLTFImporter CreateGLTFImporter() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IFBXImporter
		 * Documentation from IFBXImporter:
		 * FBX scene importer 
		 * @return the created object, of type spFBXImporter
		 */
		virtual spFBXImporter CreateFBXImporter() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IWavefrontExporter
		 * Documentation from IWavefrontExporter:
		 * Wavefront .obj geometry exporter. 
		 * @return the created object, of type spWavefrontExporter
		 */
		virtual spWavefrontExporter CreateWavefrontExporter() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IFBXExporter
		 * Documentation from IFBXExporter:
		 * FBX scene exporter. 
		 * @return the created object, of type spFBXExporter
		 */
		virtual spFBXExporter CreateFBXExporter() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IGLTFExporter
		 * Documentation from IGLTFExporter:
		 * glTF geometry exporter capable of exporting both glTF and GLB files determined 
		 * by output path extension. Textures and binary blob files for glTF export will 
		 * be placed alongside the glTF file and have names prefixed by the output file 
		 * name. Note that any normal textures for the scene must be in tangent space, 
		 * as generated by a normal caster with SetGenerateTangentSpaceNormals set to 
		 * true. 
		 * @return the created object, of type spGLTFExporter
		 */
		virtual spGLTFExporter CreateGLTFExporter() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IBinaryImporter
		 * Documentation from IBinaryImporter:
		 * BinaryImporter loads the geometry data from a binary file, that is specific 
		 * for Simplygon. Please note that the binary file is only intended for temporary 
		 * storage, and that no compatibility between versions of Simplygon is guaranteed. 
		 * @return the created object, of type spBinaryImporter
		 */
		virtual spBinaryImporter CreateBinaryImporter() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IBinaryExporter
		 * Documentation from IBinaryExporter:
		 * BinaryExporter stores the geometry data into a binary file, that is specific 
		 * for Simplygon. Please note that the binary file is only intended for temporary 
		 * storage, and that no compatibility between versions of Simplygon is guaranteed. 
		 * @return the created object, of type spBinaryExporter
		 */
		virtual spBinaryExporter CreateBinaryExporter() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IGeometryValidator
		 * Documentation from IGeometryValidator:
		 * Checks the geometry for consistent indices, number of triangles etc. 
		 * @return the created object, of type spGeometryValidator
		 */
		virtual spGeometryValidator CreateGeometryValidator() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IMaterialCasterSettings
		 * Documentation from IMaterialCasterSettings:
		 * MaterialCasterSettings is the base interface for material casting settings 
		 * @return the created object, of type spMaterialCasterSettings
		 */
		virtual spMaterialCasterSettings CreateMaterialCasterSettings() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IColorCaster
		 * Documentation from IColorCaster:
		 * ColorCaster is the interface used to cast basic color values. Currently supported 
		 * material color value types are Ambient, Diffuse and Specular + Shininess. 
		 * @return the created object, of type spColorCaster
		 */
		virtual spColorCaster CreateColorCaster() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IColorCasterSettings
		 * Documentation from IColorCasterSettings:
		 * ColorCasterSettings is the interface for basic color caster settings. 
		 * @return the created object, of type spColorCasterSettings
		 */
		virtual spColorCasterSettings CreateColorCasterSettings() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IOpacityCaster
		 * Documentation from IOpacityCaster:
		 * OpacityCaster is the interface used to cast opacity values. To be used when 
		 * opacity is needed as a separate texture. IMPORTANT: Make sure to set OpacityChannel 
		 * to the channel you want to cast, since this caster bakes opacity rather than 
		 * the channel set in the MaterialChannel setting like most other casters. 
		 * @return the created object, of type spOpacityCaster
		 */
		virtual spOpacityCaster CreateOpacityCaster() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IOpacityCasterSettings
		 * Documentation from IOpacityCasterSettings:
		 * OpacityCasterSettings is the interface used to manage settings for an opacity 
		 * caster. IMPORTANT: Make sure to set the OpacityChannel setting to the channel 
		 * you want to cast, since this caster bakes opacity rather than the channel set 
		 * in the MaterialChannel setting like most other casters. 
		 * @return the created object, of type spOpacityCasterSettings
		 */
		virtual spOpacityCasterSettings CreateOpacityCasterSettings() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type INormalCaster
		 * Documentation from INormalCaster:
		 * NormalCaster is the interface used to cast normals data onto the receiving 
		 * geometry. 
		 * @return the created object, of type spNormalCaster
		 */
		virtual spNormalCaster CreateNormalCaster() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type INormalCasterSettings
		 * Documentation from INormalCasterSettings:
		 * NormalCasterSettings is the interface used to manage settings for a normal 
		 * caster 
		 * @return the created object, of type spNormalCasterSettings
		 */
		virtual spNormalCasterSettings CreateNormalCasterSettings() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type INormalRepairer
		 * Documentation from INormalRepairer:
		 * Repairs normals on a processed geometry. 
		 * @return the created object, of type spNormalRepairer
		 */
		virtual spNormalRepairer CreateNormalRepairer() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IDisplacementCaster
		 * Documentation from IDisplacementCaster:
		 * DisplacementCaster is used to store the delta-values between the original and 
		 * processed geometries. The values are divided by a scaling value, and clamped 
		 * into the -1 -> 1 range before being stored into an image. 
		 * @return the created object, of type spDisplacementCaster
		 */
		virtual spDisplacementCaster CreateDisplacementCaster() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IDisplacementCasterSettings
		 * Documentation from IDisplacementCasterSettings:
		 * DisplacementCasterSettings is used to store the settings for a displacement 
		 * caster 
		 * @return the created object, of type spDisplacementCasterSettings
		 */
		virtual spDisplacementCasterSettings CreateDisplacementCasterSettings() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ITangentCalculator
		 * Documentation from ITangentCalculator:
		 * TangentCalculator calculates tangent vectors for geometry data objects. One 
		 * corner field of texture coordinates must exist, as well as normals. The tangents 
		 * are placed into two corner fields called "Tangents" and "Bitangents". If any 
		 * of these fields already exists, it is replaced by the new field. 
		 * @return the created object, of type spTangentCalculator
		 */
		virtual spTangentCalculator CreateTangentCalculator() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IReductionSettings
		 * Documentation from IReductionSettings:
		 * Settings for the ReductionProcessor class. Handles all the settings for Simplygons 
		 * simplification algorithms. The user can tell the reduction processor which 
		 * features are important by using the 'FeatureFlags' parameter, and also the 
		 * relative importance of these features using the Set{feature}Importance methods. 
		 * Also settings for things like symmetry are set here. 
		 * @return the created object, of type spReductionSettings
		 */
		virtual spReductionSettings CreateReductionSettings() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IReductionProcessor
		 * Documentation from IReductionProcessor:
		 * ReductionProcessor welds, removes t-junctions, removes double-triangles and 
		 * reduces the triangle count of the Geometry. It also calculates new normals 
		 * for the reduced and optimized Geometry. 
		 * @return the created object, of type spReductionProcessor
		 */
		virtual spReductionProcessor CreateReductionProcessor() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IRemeshingLegacyProcessor
		 * Documentation from IRemeshingLegacyProcessor:
		 * RemeshingLegacyProcessor creates a new geometry that is based on the input 
		 * geometry, but that is topologically based on the size of the input geometry 
		 * rendered at a specific screen size, and allowed pixel error. The remesher will 
		 * on demand also add texture coordinates and a mapping texture to the output 
		 * remeshed geometry. The geometry that is to be remeshed can be defined either 
		 * using an in-memory geometry data object, or using a geometry file placed on 
		 * disk, the latter being the preferred method, if the source geometry is very 
		 * large as it can be swapped in/out of memory as needed. 
		 * @return the created object, of type spRemeshingLegacyProcessor
		 */
		virtual spRemeshingLegacyProcessor CreateRemeshingLegacyProcessor() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IRemeshingProcessor
		 * Documentation from IRemeshingProcessor:
		 * The RemeshingProcessor takes an input scene and replaces it with a lightweight 
		 * proxy geometry that resembles the original, but does not share vertex data 
		 * or parts of the original mesh data. The remeshed object is created and optimized 
		 * for a certain on-screen pixel size - which means that holes and parts that 
		 * are close to each other will have their gaps filled if the distance is below 
		 * a pixel. At default settings, the proxy mesh is assumed to be viewed from the 
		 * outside. Any interior mesh that cannot be seen is removed. The result is a 
		 * very light-weight mesh that is highly optimized for real-time viewing, or to 
		 * speed up off-line rendering of small objects. Simplygon is capable of remeshing 
		 * arbitrary geometry, including non-manifold surfaces. 
		 * @return the created object, of type spRemeshingProcessor
		 */
		virtual spRemeshingProcessor CreateRemeshingProcessor() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IScene
		 * Documentation from IScene:
		 * Scene is the main keeper of a scene and scene graph in simplygon. The scene 
		 * is self-contained, with materials, textures, etc. to describe a full scene. 
		 * @return the created object, of type spScene
		 */
		virtual spScene CreateScene() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ISceneNode
		 * Documentation from ISceneNode:
		 * SceneNode is the base class for all scene graph nodes in simplygon. It has 
		 * relative transformation to its parent, and functions to add children to the 
		 * node. 
		 * @return the created object, of type spSceneNode
		 */
		virtual spSceneNode CreateSceneNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ISceneNodeCollection
		 * Documentation from ISceneNodeCollection:
		 * SceneNodeCollection holds a number of SceneNode objects. The objects can be 
		 * looked up by their names (if they have been named through SetName()). 
		 * @return the created object, of type spSceneNodeCollection
		 */
		virtual spSceneNodeCollection CreateSceneNodeCollection() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ISceneMesh
		 * Documentation from ISceneMesh:
		 * SceneMesh is the mesh node in the simplygon scene graph 
		 * @return the created object, of type spSceneMesh
		 */
		virtual spSceneMesh CreateSceneMesh() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ISceneLodGroup
		 * Documentation from ISceneLodGroup:
		 * SceneLodGroup is a LOD grouping for the scene graph 
		 * @return the created object, of type spSceneLodGroup
		 */
		virtual spSceneLodGroup CreateSceneLodGroup() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ISceneBone
		 * Documentation from ISceneBone:
		 * SceneBone is the bone node in the simplygon scene graph 
		 * @return the created object, of type spSceneBone
		 */
		virtual spSceneBone CreateSceneBone() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ISceneBoneTable
		 * Documentation from ISceneBoneTable:
		 * SceneBoneTable keeps information on bones used while rendering. 
		 * @return the created object, of type spSceneBoneTable
		 */
		virtual spSceneBoneTable CreateSceneBoneTable() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IScenePlane
		 * Documentation from IScenePlane:
		 * ScenePlane is the plane node in the simplygon scene graph that can be used 
		 * in various processes, for example as a cutting plane in the RemeshingProcessor. 
		 * @return the created object, of type spScenePlane
		 */
		virtual spScenePlane CreateScenePlane() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ISceneCamera
		 * Documentation from ISceneCamera:
		 * SceneCamera is the camera node in the Simplygon scene graph. SceneCamera contains 
		 * settings that specify how the camera works and it contains a number of views 
		 * for that type of camera. A view is a combination of a CameraPosition and a 
		 * TargetPosition. The SceneCamera can contain any number of views but every element 
		 * in TargetPositions has to correspond to a tuple element in CameraPosition. 
		 * TargetPositions is not needed if the camera is set to being omni directional. 
		 * @return the created object, of type spSceneCamera
		 */
		virtual spSceneCamera CreateSceneCamera() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ISceneExporter
		 * Documentation from ISceneExporter:
		 * Class for saving scene data to different file formats depending on the extension 
		 * of the set file name. 
		 * @return the created object, of type spSceneExporter
		 */
		virtual spSceneExporter CreateSceneExporter() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ISceneImporter
		 * Documentation from ISceneImporter:
		 * Class for loading scene data from different file formats. 
		 * @return the created object, of type spSceneImporter
		 */
		virtual spSceneImporter CreateSceneImporter() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ISelectionSet
		 * Documentation from ISelectionSet:
		 * SelectionSet is a set of scene node GUIDs referencing scene nodes in a scene. 
		 * @return the created object, of type spSelectionSet
		 */
		virtual spSelectionSet CreateSelectionSet() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ISelectionSetTable
		 * Documentation from ISelectionSetTable:
		 * SelectionSetTable keeps a table of SelectionSet. 
		 * @return the created object, of type spSelectionSetTable
		 */
		virtual spSelectionSetTable CreateSelectionSetTable() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ITexture
		 * Documentation from ITexture:
		 * Texture describes a texture object, containing either image data or a path 
		 * that is referenced by texture nodes in materials. 
		 * @return the created object, of type spTexture
		 */
		virtual spTexture CreateTexture() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ITextureTable
		 * Documentation from ITextureTable:
		 * TextureTable keeps information on textures used while rendering. 
		 * @return the created object, of type spTextureTable
		 */
		virtual spTextureTable CreateTextureTable() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IImageDataImporter
		 * Documentation from IImageDataImporter:
		 * Class for loading image data from different file formats. 
		 * @return the created object, of type spImageDataImporter
		 */
		virtual spImageDataImporter CreateImageDataImporter() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingTextureNode
		 * Documentation from IShadingTextureNode:
		 * TextureNode describes a texture source node in a shading network. 
		 * @return the created object, of type spShadingTextureNode
		 */
		virtual spShadingTextureNode CreateShadingTextureNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingSwizzlingNode
		 * Documentation from IShadingSwizzlingNode:
		 * SwizzlingNode describes a node that can remap the input to the specified output. 
		 * @return the created object, of type spShadingSwizzlingNode
		 */
		virtual spShadingSwizzlingNode CreateShadingSwizzlingNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingColorNode
		 * Documentation from IShadingColorNode:
		 * ColorNode describes a single color source node in a shading network 
		 * @return the created object, of type spShadingColorNode
		 */
		virtual spShadingColorNode CreateShadingColorNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingAddNode
		 * Documentation from IShadingAddNode:
		 * AddNode describes a single addition shading node in a shading network. Input 
		 * 1 and 2 are added per-component to produce the output. 
		 * @return the created object, of type spShadingAddNode
		 */
		virtual spShadingAddNode CreateShadingAddNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingSubtractNode
		 * Documentation from IShadingSubtractNode:
		 * SubtractNode describes a single subtracting shading node in a shading network. 
		 * Input 2 is subtracted from input 1 per-component. 
		 * @return the created object, of type spShadingSubtractNode
		 */
		virtual spShadingSubtractNode CreateShadingSubtractNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingMultiplyNode
		 * Documentation from IShadingMultiplyNode:
		 * MultiplyNode describes a single multiplying shading node in a shading network. 
		 * Input 1 and Input 2 is multiplied per-component. 
		 * @return the created object, of type spShadingMultiplyNode
		 */
		virtual spShadingMultiplyNode CreateShadingMultiplyNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingPowNode
		 * Documentation from IShadingPowNode:
		 * This node describes an exponentiation. The output will be Input 1 to the power 
		 * of Input 2, and it is calculated per-component. 
		 * @return the created object, of type spShadingPowNode
		 */
		virtual spShadingPowNode CreateShadingPowNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingDivideNode
		 * Documentation from IShadingDivideNode:
		 * DivideNode describes a single division shading node node in a shading network. 
		 * Input 1 is divided by Input 2 per-component to produce the output. 
		 * @return the created object, of type spShadingDivideNode
		 */
		virtual spShadingDivideNode CreateShadingDivideNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingClampNode
		 * Documentation from IShadingClampNode:
		 * ClampNode describes a single clamp shading node in a shading network. Input 
		 * 1 is clamped per-component between Input 2 and 3. 
		 * @return the created object, of type spShadingClampNode
		 */
		virtual spShadingClampNode CreateShadingClampNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingMaxNode
		 * Documentation from IShadingMaxNode:
		 * MaxNode describes a single max shading node in a shading network. The output 
		 * has the per-channel max values of the two inputs. 
		 * @return the created object, of type spShadingMaxNode
		 */
		virtual spShadingMaxNode CreateShadingMaxNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingMinNode
		 * Documentation from IShadingMinNode:
		 * MinNode describes a single min shading node in a shading network. The output 
		 * has the per-channel min values of the two inputs. 
		 * @return the created object, of type spShadingMinNode
		 */
		virtual spShadingMinNode CreateShadingMinNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingStepNode
		 * Documentation from IShadingStepNode:
		 * StepNode describes a single step shading node, where the per-component output 
		 * is either 1 or 0 depending on if input0 is larger or smaller than input1. Basically, 
		 * (Input0 >= Input1) ? 1 : 0 
		 * @return the created object, of type spShadingStepNode
		 */
		virtual spShadingStepNode CreateShadingStepNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingEqualNode
		 * Documentation from IShadingEqualNode:
		 * ShadingEqualNode describes an "is equal to" operator, where the per-component 
		 * output is either 1 or 0 depending on if input0 is equal to input1. Basically, 
		 * (Input0 == Input1) ? 1 : 0 
		 * @return the created object, of type spShadingEqualNode
		 */
		virtual spShadingEqualNode CreateShadingEqualNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingNotEqualNode
		 * Documentation from IShadingNotEqualNode:
		 * NotEqualNode describes the "is not equal" operator, where the per-component 
		 * output is either 1 or 0 depending on if input0 is equal to input1. Basically, 
		 * (Input0 != Input1) ? 1 : 0 
		 * @return the created object, of type spShadingNotEqualNode
		 */
		virtual spShadingNotEqualNode CreateShadingNotEqualNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingVertexColorNode
		 * Documentation from IShadingVertexColorNode:
		 * VertexColorNode describes a vertex color source node in a shading network. 
		 * @return the created object, of type spShadingVertexColorNode
		 */
		virtual spShadingVertexColorNode CreateShadingVertexColorNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingInterpolateNode
		 * Documentation from IShadingInterpolateNode:
		 * InterpolateNode describes a single interpolating shading node node in a shading 
		 * network. Input 1 and Input 2 is interpolated per-component using Input 3. Blend 
		 * values below 0 and over 1 will be clamped. 
		 * @return the created object, of type spShadingInterpolateNode
		 */
		virtual spShadingInterpolateNode CreateShadingInterpolateNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingCustomNode
		 * Documentation from IShadingCustomNode:
		 * CustomNode describes a custom shading node in a shading network. The output 
		 * is produced based on customizable user specified operations. The custom node 
		 * has a user specified amount of input parameters. Use SetInputCount() to specify 
		 * the number of inputs. The user has to assign and implement event handlers (called 
		 * observers) for the custom node to be able to evaluate to colors. See CustomNodeExample 
		 * and API documentation for further explanations and code samples. 
		 * @return the created object, of type spShadingCustomNode
		 */
		virtual spShadingCustomNode CreateShadingCustomNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingLayeredBlendNode
		 * Documentation from IShadingLayeredBlendNode:
		 * LayeredBlendNode is a node with an arbitrary number of inputs that can be blended 
		 * differently. 
		 * @return the created object, of type spShadingLayeredBlendNode
		 */
		virtual spShadingLayeredBlendNode CreateShadingLayeredBlendNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingNormalize3Node
		 * Documentation from IShadingNormalize3Node:
		 * This node describes an normalization of the x,y,z components of the input. 
		 * @return the created object, of type spShadingNormalize3Node
		 */
		virtual spShadingNormalize3Node CreateShadingNormalize3Node() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingSqrtNode
		 * Documentation from IShadingSqrtNode:
		 * This node describes a square root calculation. The output will be the per-component 
		 * square root of input 1 
		 * @return the created object, of type spShadingSqrtNode
		 */
		virtual spShadingSqrtNode CreateShadingSqrtNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingDot3Node
		 * Documentation from IShadingDot3Node:
		 * This node describes an dot of the x,y,z components of the inputs. 
		 * @return the created object, of type spShadingDot3Node
		 */
		virtual spShadingDot3Node CreateShadingDot3Node() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingCross3Node
		 * Documentation from IShadingCross3Node:
		 * This node describes the cross of the x,y,z components of the input. 
		 * @return the created object, of type spShadingCross3Node
		 */
		virtual spShadingCross3Node CreateShadingCross3Node() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingCosNode
		 * Documentation from IShadingCosNode:
		 * This node describes cosine of the x,y,z,w components of the input. 
		 * @return the created object, of type spShadingCosNode
		 */
		virtual spShadingCosNode CreateShadingCosNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingSinNode
		 * Documentation from IShadingSinNode:
		 * This node describes Sin of the x,y,z components of the input. 
		 * @return the created object, of type spShadingSinNode
		 */
		virtual spShadingSinNode CreateShadingSinNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingGreaterThanNode
		 * Documentation from IShadingGreaterThanNode:
		 * GreaterThanNode describes the "is greater than" operator, where the per-component 
		 * output is either 1 or 0 depending on if input0 is greater than input1. Basically, 
		 * (Input0 > Input1) ? 1 : 0 
		 * @return the created object, of type spShadingGreaterThanNode
		 */
		virtual spShadingGreaterThanNode CreateShadingGreaterThanNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingLessThanNode
		 * Documentation from IShadingLessThanNode:
		 * LessThanNode describes the "is less than" operator, where the per-component 
		 * output is either 1 or 0 depending on if input0 is LessThan to input1. Basically, 
		 * (Input0 < Input1) ? 1 : 0 
		 * @return the created object, of type spShadingLessThanNode
		 */
		virtual spShadingLessThanNode CreateShadingLessThanNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingGeometryFieldNode
		 * Documentation from IShadingGeometryFieldNode:
		 * Geometry field node describes a source node for geometry field data in a shading 
		 * network, such as normals and tangents. 
		 * @return the created object, of type spShadingGeometryFieldNode
		 */
		virtual spShadingGeometryFieldNode CreateShadingGeometryFieldNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShaderGenerator
		 * Documentation from IShaderGenerator:
		 * Given a material, the shader data class keeps the relevant shader data and 
		 * is able to generate a GLSL/HLSL shader. 
		 * @return the created object, of type spShaderGenerator
		 */
		virtual spShaderGenerator CreateShaderGenerator() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IAggregationProcessor
		 * Documentation from IAggregationProcessor:
		 * AggregationProcessor combines all specified geometries in the scene into one 
		 * geometry. All materials are combined and receive a new shared texture atlas. 
		 * @return the created object, of type spAggregationProcessor
		 */
		virtual spAggregationProcessor CreateAggregationProcessor() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IAggregationSettings
		 * Documentation from IAggregationSettings:
		 * Settings for the AggregationSettings class. The AggregationProcessor converts 
		 * entire scenes containing multiple draw calls into a single new object with 
		 * a single texture per material channel. The user can set whether or not the 
		 * AggregationProcessor should create new UVs based on the old UVs or create a 
		 * completely new UV parameterization. 
		 * @return the created object, of type spAggregationSettings
		 */
		virtual spAggregationSettings CreateAggregationSettings() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IChartAggregator
		 * Documentation from IChartAggregator:
		 * Computes new texture coordinates for a geometry with overlapping UV charts. 
		 * @return the created object, of type spChartAggregator
		 */
		virtual spChartAggregator CreateChartAggregator() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IVertexColorCasterSettings
		 * Documentation from IVertexColorCasterSettings:
		 * VertexColorCasterSettings is the interface for basic vertex color caster settings. 
		 * @return the created object, of type spVertexColorCasterSettings
		 */
		virtual spVertexColorCasterSettings CreateVertexColorCasterSettings() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IVertexColorCaster
		 * Documentation from IVertexColorCaster:
		 * VertexColorCaster. 
		 * @return the created object, of type spVertexColorCaster
		 */
		virtual spVertexColorCaster CreateVertexColorCaster() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IImageDataExporter
		 * Documentation from IImageDataExporter:
		 * Class for saving image data to different file formats. 
		 * @return the created object, of type spImageDataExporter
		 */
		virtual spImageDataExporter CreateImageDataExporter() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IAmbientOcclusionCaster
		 * Documentation from IAmbientOcclusionCaster:
		 * AmbientOcclusionCaster generates an ambient occlusion map based on the original 
		 * geometry, and casts it. 
		 * @return the created object, of type spAmbientOcclusionCaster
		 */
		virtual spAmbientOcclusionCaster CreateAmbientOcclusionCaster() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IAmbientOcclusionCasterSettings
		 * Documentation from IAmbientOcclusionCasterSettings:
		 * AmbientOcclusionCasterSettings manages settings for an ambient occlusion caster. 
		 * @return the created object, of type spAmbientOcclusionCasterSettings
		 */
		virtual spAmbientOcclusionCasterSettings CreateAmbientOcclusionCasterSettings() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IImpostorProcessor
		 * Documentation from IImpostorProcessor:
		 * The ImpostorProcessor generates an impostor of one of these impostor types: 
		 * BillboardCloud, Flipbook or ImpostorFromSingleView. 
		 * @return the created object, of type spImpostorProcessor
		 */
		virtual spImpostorProcessor CreateImpostorProcessor() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IImpostorSettings
		 * Documentation from IImpostorSettings:
		 * Settings for the ImpostorProccessor 
		 * @return the created object, of type spImpostorSettings
		 */
		virtual spImpostorSettings CreateImpostorSettings() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ISurfaceMapper
		 * Documentation from ISurfaceMapper:
		 * ISurfaceMapper creates a mapping image between two user-defined geometries. 
		 * The mapper basically looks for the source geometry in the inverse normal direction 
		 * from the outwardly offset destination geometry, and maps pixels accordingly. 
		 * This means that you can modify the normals of the destination geometry to adjust 
		 * the search direction to your liking. The geometries can either be set as IGeometryDatas 
		 * or as the root nodes of scenes. If both are set, the scene is used. If only 
		 * a single source or a destination is set, or if the source and destination are 
		 * the same scene or geometry, the surface mapper will map the mesh onto itself. 
		 * @return the created object, of type spSurfaceMapper
		 */
		virtual spSurfaceMapper CreateSurfaceMapper() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IOcclusionMeshProcessor
		 * Documentation from IOcclusionMeshProcessor:
		 * The occlusion mesh processor creates a reconstruction of the input mesh from 
		 * its silhouette. This means concavities and internal geometry disappear. WARNING: 
		 * Experimental. Generates nice meshes, but currently very slow at high settings. 
		 * Recommended onscreens size ~100 
		 * @return the created object, of type spOcclusionMeshProcessor
		 */
		virtual spOcclusionMeshProcessor CreateOcclusionMeshProcessor() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IImageComparer
		 * Documentation from IImageComparer:
		 * Compares images. 
		 * @return the created object, of type spImageComparer
		 */
		virtual spImageComparer CreateImageComparer() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IRecommendedTextureSizeCalculator
		 * Documentation from IRecommendedTextureSizeCalculator:
		 * Estimates a coarse recommended UV size (width and height) for a geometry based 
		 * on only its surface area and either the distance it is allowed to deviate or 
		 * its intended on screen size. The UVs are assumed to be unique i.e. not tiled/repeated. 
		 * RecommendedWidth and RecommendedHeight will only differ from each other if 
		 * ForcePower2Texture is enabled. 
		 * @return the created object, of type spRecommendedTextureSizeCalculator
		 */
		virtual spRecommendedTextureSizeCalculator CreateRecommendedTextureSizeCalculator() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IPartRemover
		 * Documentation from IPartRemover:
		 * The PartRemover tool can identify unconnected sub-meshes, and remove meshes 
		 * that fall below a set size threshold. This size threshold can be set globally 
		 * for the entire geometry, or per-material to be able to remove things like decals 
		 * effectively. 
		 * @return the created object, of type spPartRemover
		 */
		virtual spPartRemover CreatePartRemover() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IWelder
		 * Documentation from IWelder:
		 * Welds vertices within the geometry or scene together. 
		 * @return the created object, of type spWelder
		 */
		virtual spWelder CreateWelder() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ITJunctionEliminator
		 * Documentation from ITJunctionEliminator:
		 * Removes t-junctions by subdividing triangles and welding vertices 
		 * @return the created object, of type spTJunctionEliminator
		 */
		virtual spTJunctionEliminator CreateTJunctionEliminator() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IPipelineBatch
		 * Documentation from IPipelineBatch:
		 * Control object to launch pipelines in batches, both locally and distributed 
		 * @return the created object, of type spPipelineBatch
		 */
		virtual spPipelineBatch CreatePipelineBatch() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IPipelineSerializer
		 * @return the created object, of type spPipelineSerializer
		 */
		virtual spPipelineSerializer CreatePipelineSerializer() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IReductionPipeline
		 * Documentation from IReductionPipeline:
		 * ReductionPipeline provides a pipeline for a single reduction processor to be 
		 * applied on the input scene. 
		 * @return the created object, of type spReductionPipeline
		 */
		virtual spReductionPipeline CreateReductionPipeline() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IRemeshingLegacyPipeline
		 * Documentation from IRemeshingLegacyPipeline:
		 * RemeshingLegacyPipeline provides a pipeline for a single remeshing legacy processor 
		 * to be applied on the input scene. 
		 * @return the created object, of type spRemeshingLegacyPipeline
		 */
		virtual spRemeshingLegacyPipeline CreateRemeshingLegacyPipeline() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IAggregationPipeline
		 * Documentation from IAggregationPipeline:
		 * AggregationPipeline provides a pipeline for a single aggregation processor 
		 * to be applied on the input scene. 
		 * @return the created object, of type spAggregationPipeline
		 */
		virtual spAggregationPipeline CreateAggregationPipeline() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IPipelineSettings
		 * Documentation from IPipelineSettings:
		 * PipelineSettings is the interface used to manage settings for a pipeline 
		 * @return the created object, of type spPipelineSettings
		 */
		virtual spPipelineSettings CreatePipelineSettings() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IRemeshingPipeline
		 * Documentation from IRemeshingPipeline:
		 * RemeshingPipeline provides a pipeline for a single remeshing processor to be 
		 * applied on the input scene. 
		 * @return the created object, of type spRemeshingPipeline
		 */
		virtual spRemeshingPipeline CreateRemeshingPipeline() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IPassthroughPipeline
		 * Documentation from IPassthroughPipeline:
		 * PassthroughPipeline provides an empty pipeline for creating a cascading pipeline 
		 * using a single dummy root node. It does not process the input scene in any 
		 * way. 
		 * @return the created object, of type spPassthroughPipeline
		 */
		virtual spPassthroughPipeline CreatePassthroughPipeline() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IGeometryDataCaster
		 * Documentation from IGeometryDataCaster:
		 * GeometryDataCaster is used to cast original GeometryData information to an 
		 * image using mapping image 
		 * @return the created object, of type spGeometryDataCaster
		 */
		virtual spGeometryDataCaster CreateGeometryDataCaster() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IGeometryDataCasterSettings
		 * Documentation from IGeometryDataCasterSettings:
		 * GeometryDataCasterSettings is the interface used to manage settings for GeometryDataCaster 
		 * @return the created object, of type spGeometryDataCasterSettings
		 */
		virtual spGeometryDataCasterSettings CreateGeometryDataCasterSettings() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IGenerateLightmapTexCoordSettings
		 * Documentation from IGenerateLightmapTexCoordSettings:
		 * GenerateLightmapTexCoordSettings is the interface used to manage light map 
		 * uv generation. 
		 * @return the created object, of type spGenerateLightmapTexCoordSettings
		 */
		virtual spGenerateLightmapTexCoordSettings CreateGenerateLightmapTexCoordSettings() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IBillboardCloudSettings
		 * Documentation from IBillboardCloudSettings:
		 * Settings for the ImpostorType: BillboardCloud 
		 * @return the created object, of type spBillboardCloudSettings
		 */
		virtual spBillboardCloudSettings CreateBillboardCloudSettings() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IFlipbookSettings
		 * Documentation from IFlipbookSettings:
		 * Settings for the ImpostorType: FlipBook 
		 * @return the created object, of type spFlipbookSettings
		 */
		virtual spFlipbookSettings CreateFlipbookSettings() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IImpostorFromSingleViewSettings
		 * Documentation from IImpostorFromSingleViewSettings:
		 * Settings for the ImpostorType: ImpostorFromSingleView. 
		 * @return the created object, of type spImpostorFromSingleViewSettings
		 */
		virtual spImpostorFromSingleViewSettings CreateImpostorFromSingleViewSettings() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IImpostorFromSingleViewPipeline
		 * Documentation from IImpostorFromSingleViewPipeline:
		 * ImpostorFromSingleViewPipeline provides a pipeline for a impostor from single 
		 * view impostor processor to be applied on the input scene. 
		 * @return the created object, of type spImpostorFromSingleViewPipeline
		 */
		virtual spImpostorFromSingleViewPipeline CreateImpostorFromSingleViewPipeline() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IBillboardCloudPipeline
		 * Documentation from IBillboardCloudPipeline:
		 * BillboardCloudPipeline provides a pipeline for a billboard cloud impostor processor 
		 * to be applied on the input scene. 
		 * @return the created object, of type spBillboardCloudPipeline
		 */
		virtual spBillboardCloudPipeline CreateBillboardCloudPipeline() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IBillboardCloudVegetationPipeline
		 * Documentation from IBillboardCloudVegetationPipeline:
		 * BillboardCloudPipeline provides a pipeline for a billboard cloud vegetation 
		 * impostor processor to be applied on the input scene. 
		 * @return the created object, of type spBillboardCloudVegetationPipeline
		 */
		virtual spBillboardCloudVegetationPipeline CreateBillboardCloudVegetationPipeline() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IFlipbookPipeline
		 * Documentation from IFlipbookPipeline:
		 * FlipbookPipeline provides a pipeline for a flipbook impostor processor to be 
		 * applied on the input scene. 
		 * @return the created object, of type spFlipbookPipeline
		 */
		virtual spFlipbookPipeline CreateFlipbookPipeline() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IStringArray
		 * Documentation from IStringArray:
		 * StringArray is the string implementation of ValueArray. See ValueArray for 
		 * a description. 
		 * @return the created object, of type spStringArray
		 */
		virtual spStringArray CreateStringArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IOcclusionMeshPipeline
		 * Documentation from IOcclusionMeshPipeline:
		 * OcclusionMeshPipeline provides a pipeline for a single occlusion mesh processor 
		 * to be applied on the input scene. 
		 * @return the created object, of type spOcclusionMeshPipeline
		 */
		virtual spOcclusionMeshPipeline CreateOcclusionMeshPipeline() = 0;

		/**
		 * Sets the callback used to report errors
		 * @param handler is the new error handler object
		 * @return the previously registered handler object
		 */
		virtual ErrorHandler *SetErrorHandler( ErrorHandler *handler ) = 0;
		/**
		 * Returns the version of the Simplygon library as a string
		 * @return the library version
		 */
		virtual spString GetVersion() const = 0;
		/**
		 * Send telemetry to Simplygon
		 * @param eventCategory is the event category for the telemetry event
		 * @param integrationName is the integration name for the telemetry event
		 * @param integrationVersion is the integration version for the telemetry event
		 * @param contentJson is the telemetry content as a json string
		 */
		virtual void SendTelemetry(const char* eventCategory, const char* integrationName, const char* integrationVersion, const char* contentJson) const = 0;

		/**
		 * Sets a named global library boolean setting
		 * @param setting_name is the name of the global setting we want to set.
		 * @param value is the value we want to set the chosen global setting to.
		 */
		virtual void SetGlobalBoolSetting( const char *setting_name , bool value ) const = 0;

		/**
		 * Sets a named global library integer setting
		 * @param setting_name is the name of the global setting we want to set.
		 * @param value is the value we want to set the chosen global setting to.
		 */
		virtual void SetGlobalIntSetting( const char *setting_name , int value ) const = 0;

		/**
		 * Sets a named global library floating point setting
		 * @param setting_name is the name of the global setting we want to set.
		 * @param value is the value we want to set the chosen global setting to.
		 */
		virtual void SetGlobalFloatSetting( const char *setting_name , double value ) const = 0;

		/**
		 * Sets a named global library string setting
		 * @param setting_name is the name of the global setting we want to set.
		 * @param value is the value we want to set the chosen global setting to.
		 */
		virtual void SetGlobalStringSetting( const char *setting_name , const char *value ) const = 0;

		/**
		 * Sets global DefaultTangentCalculatorType setting
		 * @param value is the value we want to set the global DefaultTangentCalculatorType setting to.
		 */
		virtual void SetGlobalDefaultTangentCalculatorTypeSetting( ETangentSpaceMethod value ) const = 0;

		/**
		 * Sets global AllowDirectX setting
		 * @param value is the value we want to set the global AllowDirectX setting to.
		 */
		virtual void SetGlobalAllowDirectXSetting( bool value ) const = 0;

		/**
		 * Sets global AllowGPUAcceleration setting
		 * @param value is the value we want to set the global AllowGPUAcceleration setting to.
		 */
		virtual void SetGlobalAllowGPUAccelerationSetting( bool value ) const = 0;

		/**
		 * Sets global AllowTextureSamplingInterpolation setting
		 * @param value is the value we want to set the global AllowTextureSamplingInterpolation setting to.
		 */
		virtual void SetGlobalAllowTextureSamplingInterpolationSetting( bool value ) const = 0;

		/**
		 * Sets global AllowShadingNetworkCaching setting
		 * @param value is the value we want to set the global AllowShadingNetworkCaching setting to.
		 */
		virtual void SetGlobalAllowShadingNetworkCachingSetting( bool value ) const = 0;

		/**
		 * Sets global AllowDistributionLocalFallback setting
		 * @param value is the value we want to set the global AllowDistributionLocalFallback setting to.
		 */
		virtual void SetGlobalAllowDistributionLocalFallbackSetting( bool value ) const = 0;

		/**
		 * Sets global AutomaticGuidGeneration setting
		 * @param value is the value we want to set the global AutomaticGuidGeneration setting to.
		 */
		virtual void SetGlobalAutomaticGuidGenerationSetting( bool value ) const = 0;

		/**
		 * Sets global CacheToDisk setting
		 * @param value is the value we want to set the global CacheToDisk setting to.
		 */
		virtual void SetGlobalCacheToDiskSetting( bool value ) const = 0;

		/**
		 * Sets global PreventDirectXThreadingOptimizations setting
		 * @param value is the value we want to set the global PreventDirectXThreadingOptimizations setting to.
		 */
		virtual void SetGlobalPreventDirectXThreadingOptimizationsSetting( bool value ) const = 0;

		/**
		 * Sets global LogicalCoreLimit setting
		 * @param value is the value we want to set the global LogicalCoreLimit setting to.
		 */
		virtual void SetGlobalLogicalCoreLimitSetting( unsigned int value ) const = 0;

		/**
		 * Sets global MaskFPExceptions setting
		 * @param value is the value we want to set the global MaskFPExceptions setting to.
		 */
		virtual void SetGlobalMaskFPExceptionsSetting( bool value ) const = 0;

		/**
		 * Sets global ValidRealThreshold setting
		 * @param value is the value we want to set the global ValidRealThreshold setting to.
		 */
		virtual void SetGlobalValidRealThresholdSetting( float value ) const = 0;

		/**
		 * Sets global ValidateProcessing setting
		 * @param value is the value we want to set the global ValidateProcessing setting to.
		 */
		virtual void SetGlobalValidateProcessingSetting( bool value ) const = 0;

		/**
		 * Sets global ValidateProcessingAssertOnError setting
		 * @param value is the value we want to set the global ValidateProcessingAssertOnError setting to.
		 */
		virtual void SetGlobalValidateProcessingAssertOnErrorSetting( bool value ) const = 0;

		/**
		 * Sets global ValidateProcessingDebugLevel setting
		 * @param value is the value we want to set the global ValidateProcessingDebugLevel setting to.
		 */
		virtual void SetGlobalValidateProcessingDebugLevelSetting( unsigned int value ) const = 0;

		/**
		 * Sets global ValidateProcessingOutputDirectory setting
		 * @param value is the value we want to set the global ValidateProcessingOutputDirectory setting to.
		 */
		virtual void SetGlobalValidateProcessingOutputDirectorySetting( const char* value ) const = 0;

		/**
		 * Sets global EnableLog setting
		 * @param value is the value we want to set the global EnableLog setting to.
		 */
		virtual void SetGlobalEnableLogSetting( bool value ) const = 0;

		/**
		 * Sets global LogToFile setting
		 * @param value is the value we want to set the global LogToFile setting to.
		 */
		virtual void SetGlobalLogToFileSetting( bool value ) const = 0;

		/**
		 * Sets global FlushLogPerRow setting
		 * @param value is the value we want to set the global FlushLogPerRow setting to.
		 */
		virtual void SetGlobalFlushLogPerRowSetting( bool value ) const = 0;

		/**
		 * Sets global LogOutputToTraceWindow setting
		 * @param value is the value we want to set the global LogOutputToTraceWindow setting to.
		 */
		virtual void SetGlobalLogOutputToTraceWindowSetting( bool value ) const = 0;

        /**
		 * Gets a named global library boolean setting
		 * @param setting_name is the name of the global setting we want to get.
		 * @return the value of the chosen setting.
		 */
		virtual bool GetGlobalBoolSetting( const char *setting_name ) const = 0;

		/**
		 * Gets a named global library integer setting
		 * @param setting_name is the name of the global setting we want to get.
		 * @return the value of the chosen setting.
		 */
		virtual int GetGlobalIntSetting( const char *setting_name ) const = 0;

		/**
		 * Gets a named global library floating point setting
		 * @param setting_name is the name of the global setting we want to get.
		 * @return the value of the chosen setting.
		 */
		virtual double GetGlobalFloatSetting( const char *setting_name ) const = 0;

		/**
		 * Gets a named global library string setting
		 * @param setting_name is the name of the global setting we want to get.
		 * @return the value of the chosen setting.
		 */
		virtual spString GetGlobalStringSetting( const char *setting_name ) const = 0;

		/**
		 * Gets global DefaultTangentCalculatorType setting
		 * @return the value of the DefaultTangentCalculatorType setting.
		 */
		virtual ETangentSpaceMethod GetGlobalDefaultTangentCalculatorTypeSetting( ) const = 0;

		/**
		 * Gets global AllowDirectX setting
		 * @return the value of the AllowDirectX setting.
		 */
		virtual bool GetGlobalAllowDirectXSetting( ) const = 0;

		/**
		 * Gets global AllowGPUAcceleration setting
		 * @return the value of the AllowGPUAcceleration setting.
		 */
		virtual bool GetGlobalAllowGPUAccelerationSetting( ) const = 0;

		/**
		 * Gets global AllowTextureSamplingInterpolation setting
		 * @return the value of the AllowTextureSamplingInterpolation setting.
		 */
		virtual bool GetGlobalAllowTextureSamplingInterpolationSetting( ) const = 0;

		/**
		 * Gets global AllowShadingNetworkCaching setting
		 * @return the value of the AllowShadingNetworkCaching setting.
		 */
		virtual bool GetGlobalAllowShadingNetworkCachingSetting( ) const = 0;

		/**
		 * Gets global AllowDistributionLocalFallback setting
		 * @return the value of the AllowDistributionLocalFallback setting.
		 */
		virtual bool GetGlobalAllowDistributionLocalFallbackSetting( ) const = 0;

		/**
		 * Gets global AutomaticGuidGeneration setting
		 * @return the value of the AutomaticGuidGeneration setting.
		 */
		virtual bool GetGlobalAutomaticGuidGenerationSetting( ) const = 0;

		/**
		 * Gets global CacheToDisk setting
		 * @return the value of the CacheToDisk setting.
		 */
		virtual bool GetGlobalCacheToDiskSetting( ) const = 0;

		/**
		 * Gets global CreateDirectXDeviceFlagPreventInternalThreadingOptimizations setting
		 * @return the value of the CreateDirectXDeviceFlagPreventInternalThreadingOptimizations setting.
		 */
		virtual bool GetGlobalPreventDirectXThreadingOptimizationsSetting( ) const = 0;

		/**
		 * Gets global LogicalCoreLimit setting
		 * @return the value of the LogicalCoreLimit setting.
		 */
		virtual unsigned int GetGlobalLogicalCoreLimitSetting( ) const = 0;

		/**
		 * Gets global MaskFPExceptions setting
		 * @return the value of the MaskFPExceptions setting.
		 */
		virtual bool GetGlobalMaskFPExceptionsSetting( ) const = 0;

		/**
		 * Gets global ValidRealThreshold setting
		 * @return the value of the ValidRealThreshold setting.
		 */
		virtual float GetGlobalValidRealThresholdSetting( ) const = 0;

		/**
		 * Gets global ValidateProcessing setting
		 * @return the value of the ValidateProcessing setting.
		 */
		virtual bool GetGlobalValidateProcessingSetting( ) const = 0;

		/**
		 * Gets global ValidateProcessingAssertOnError setting
		 * @return the value of the ValidateProcessingAssertOnError setting.
		 */
		virtual bool GetGlobalValidateProcessingAssertOnErrorSetting( ) const = 0;

		/**
		 * Gets global ValidateProcessingDebugLevel setting
		 * @return the value of the ValidateProcessingDebugLevel setting.
		 */
		virtual unsigned int GetGlobalValidateProcessingDebugLevelSetting( ) const = 0;

		/**
		 * Gets global ValidateProcessingOutputDirectory setting
		 * @return the value of the ValidateProcessingOutputDirectory setting.
		 */
		virtual spString GetGlobalValidateProcessingOutputDirectorySetting( ) const = 0;

		/**
		 * Gets global EnableLog setting
		 * @return the value of the EnableLog setting.
		 */
		virtual bool GetGlobalEnableLogSetting( ) const = 0;

		/**
		 * Gets global LogToFile setting
		 * @return the value of the LogToFile setting.
		 */
		virtual bool GetGlobalLogToFileSetting( ) const = 0;

		/**
		 * Gets global FlushLogPerRow setting
		 * @return the value of the FlushLogPerRow setting.
		 */
		virtual bool GetGlobalFlushLogPerRowSetting( ) const = 0;

		/**
		 * Gets global LogOutputToTraceWindow setting
		 * @return the value of the LogOutputToTraceWindow setting.
		 */
		virtual bool GetGlobalLogOutputToTraceWindowSetting( ) const = 0;

		/**
		 * Sets thread local LogFileName setting
		 * @param value is the value we want to set the thread local LogFileName setting to.
		 */

		virtual void SetThreadLocalLogFileNameSetting( const char* value ) const = 0;

		/**
		 * Gets thread local LogFileName setting
		 * @return the value of the LogFileName setting.
		 */
		virtual spString GetThreadLocalLogFileNameSetting( ) const = 0;
	};


	/// Implementations of spObject methods
	inline spObject::spObject( IObject *p ) : ptr(p) { this->addref_ptr(); }
	inline spObject::spObject( const spObject &p ) : ptr(p.ptr) { this->addref_ptr(); }
	inline spObject::~spObject() { this->release_ptr(); }
	inline spObject& spObject::operator=( const spObject &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spObject spObject::SafeCast( spObject other ) { return spObject( IObject::SafeCast( other.GetInterface() ) ); }
	inline IObject* spObject::operator->() const { return static_cast<IObject*>(this->ptr); }
	inline bool spObject::IsNull() const { return (this->ptr == nullptr); }
	inline bool spObject::NonNull() const { return (this->ptr != nullptr); }
	inline IObject* spObject::GetInterface() const { return this->ptr; }
	inline bool spObject::IsSameObjectAs( const spObject &p ) { return ( this->ptr == p.ptr ) ? true : false; }
	inline bool spObject::operator==( const spObject &p ) { return this->IsSameObjectAs(p); } 
	inline spObject::operator void *() const { return this->ptr; }
	inline void spObject::addref_ptr() { if( this->ptr!=nullptr ) { this->ptr->AddRef(); } }
	inline void spObject::release_ptr() { if( this->ptr!=nullptr ) { this->ptr->Release(); this->ptr = nullptr; } }
	inline void spObject::replace_ptr( IObject *p )	{ if( this->ptr != p ) { release_ptr(); this->ptr = p; addref_ptr(); } }
	/// Implementations of spArray methods
	inline spArray::spArray( IArray *p ) : spObject(p) {}
	inline spArray::spArray( const spArray &p ) : spObject(p) {}
	inline spArray& spArray::operator=( const spArray &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spArray spArray::SafeCast( spObject other ) { return spArray( IArray::SafeCast( other.GetInterface() ) ); }
	inline IArray* spArray::operator->() const { return static_cast<IArray*>(this->ptr); }

	/// Implementations of spValueArray methods
	inline spValueArray::spValueArray( IValueArray *p ) : spArray(p) {}
	inline spValueArray::spValueArray( const spValueArray &p ) : spArray(p) {}
	inline spValueArray& spValueArray::operator=( const spValueArray &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spValueArray spValueArray::SafeCast( spObject other ) { return spValueArray( IValueArray::SafeCast( other.GetInterface() ) ); }
	inline IValueArray* spValueArray::operator->() const { return static_cast<IValueArray*>(this->ptr); }

	/// Implementations of spBoolArray methods
	inline spBoolArray::spBoolArray( IBoolArray *p ) : spValueArray(p) {}
	inline spBoolArray::spBoolArray( const spBoolArray &p ) : spValueArray(p) {}
	inline spBoolArray& spBoolArray::operator=( const spBoolArray &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spBoolArray spBoolArray::SafeCast( spObject other ) { return spBoolArray( IBoolArray::SafeCast( other.GetInterface() ) ); }
	inline IBoolArray* spBoolArray::operator->() const { return static_cast<IBoolArray*>(this->ptr); }

	/// Implementations of spCharArray methods
	inline spCharArray::spCharArray( ICharArray *p ) : spValueArray(p) {}
	inline spCharArray::spCharArray( const spCharArray &p ) : spValueArray(p) {}
	inline spCharArray& spCharArray::operator=( const spCharArray &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spCharArray spCharArray::SafeCast( spObject other ) { return spCharArray( ICharArray::SafeCast( other.GetInterface() ) ); }
	inline ICharArray* spCharArray::operator->() const { return static_cast<ICharArray*>(this->ptr); }

	/// Implementations of spDoubleArray methods
	inline spDoubleArray::spDoubleArray( IDoubleArray *p ) : spValueArray(p) {}
	inline spDoubleArray::spDoubleArray( const spDoubleArray &p ) : spValueArray(p) {}
	inline spDoubleArray& spDoubleArray::operator=( const spDoubleArray &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spDoubleArray spDoubleArray::SafeCast( spObject other ) { return spDoubleArray( IDoubleArray::SafeCast( other.GetInterface() ) ); }
	inline IDoubleArray* spDoubleArray::operator->() const { return static_cast<IDoubleArray*>(this->ptr); }

	/// Implementations of spFloatArray methods
	inline spFloatArray::spFloatArray( IFloatArray *p ) : spValueArray(p) {}
	inline spFloatArray::spFloatArray( const spFloatArray &p ) : spValueArray(p) {}
	inline spFloatArray& spFloatArray::operator=( const spFloatArray &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spFloatArray spFloatArray::SafeCast( spObject other ) { return spFloatArray( IFloatArray::SafeCast( other.GetInterface() ) ); }
	inline IFloatArray* spFloatArray::operator->() const { return static_cast<IFloatArray*>(this->ptr); }

	/// Implementations of spIntArray methods
	inline spIntArray::spIntArray( IIntArray *p ) : spValueArray(p) {}
	inline spIntArray::spIntArray( const spIntArray &p ) : spValueArray(p) {}
	inline spIntArray& spIntArray::operator=( const spIntArray &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spIntArray spIntArray::SafeCast( spObject other ) { return spIntArray( IIntArray::SafeCast( other.GetInterface() ) ); }
	inline IIntArray* spIntArray::operator->() const { return static_cast<IIntArray*>(this->ptr); }

	/// Implementations of spLongArray methods
	inline spLongArray::spLongArray( ILongArray *p ) : spValueArray(p) {}
	inline spLongArray::spLongArray( const spLongArray &p ) : spValueArray(p) {}
	inline spLongArray& spLongArray::operator=( const spLongArray &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spLongArray spLongArray::SafeCast( spObject other ) { return spLongArray( ILongArray::SafeCast( other.GetInterface() ) ); }
	inline ILongArray* spLongArray::operator->() const { return static_cast<ILongArray*>(this->ptr); }

	/// Implementations of spRealArray methods
	inline spRealArray::spRealArray( IRealArray *p ) : spValueArray(p) {}
	inline spRealArray::spRealArray( const spRealArray &p ) : spValueArray(p) {}
	inline spRealArray& spRealArray::operator=( const spRealArray &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spRealArray spRealArray::SafeCast( spObject other ) { return spRealArray( IRealArray::SafeCast( other.GetInterface() ) ); }
	inline IRealArray* spRealArray::operator->() const { return static_cast<IRealArray*>(this->ptr); }

	/// Implementations of spRidArray methods
	inline spRidArray::spRidArray( IRidArray *p ) : spValueArray(p) {}
	inline spRidArray::spRidArray( const spRidArray &p ) : spValueArray(p) {}
	inline spRidArray& spRidArray::operator=( const spRidArray &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spRidArray spRidArray::SafeCast( spObject other ) { return spRidArray( IRidArray::SafeCast( other.GetInterface() ) ); }
	inline IRidArray* spRidArray::operator->() const { return static_cast<IRidArray*>(this->ptr); }

	/// Implementations of spShortArray methods
	inline spShortArray::spShortArray( IShortArray *p ) : spValueArray(p) {}
	inline spShortArray::spShortArray( const spShortArray &p ) : spValueArray(p) {}
	inline spShortArray& spShortArray::operator=( const spShortArray &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShortArray spShortArray::SafeCast( spObject other ) { return spShortArray( IShortArray::SafeCast( other.GetInterface() ) ); }
	inline IShortArray* spShortArray::operator->() const { return static_cast<IShortArray*>(this->ptr); }

	/// Implementations of spUnsignedCharArray methods
	inline spUnsignedCharArray::spUnsignedCharArray( IUnsignedCharArray *p ) : spValueArray(p) {}
	inline spUnsignedCharArray::spUnsignedCharArray( const spUnsignedCharArray &p ) : spValueArray(p) {}
	inline spUnsignedCharArray& spUnsignedCharArray::operator=( const spUnsignedCharArray &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spUnsignedCharArray spUnsignedCharArray::SafeCast( spObject other ) { return spUnsignedCharArray( IUnsignedCharArray::SafeCast( other.GetInterface() ) ); }
	inline IUnsignedCharArray* spUnsignedCharArray::operator->() const { return static_cast<IUnsignedCharArray*>(this->ptr); }

	/// Implementations of spUnsignedIntArray methods
	inline spUnsignedIntArray::spUnsignedIntArray( IUnsignedIntArray *p ) : spValueArray(p) {}
	inline spUnsignedIntArray::spUnsignedIntArray( const spUnsignedIntArray &p ) : spValueArray(p) {}
	inline spUnsignedIntArray& spUnsignedIntArray::operator=( const spUnsignedIntArray &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spUnsignedIntArray spUnsignedIntArray::SafeCast( spObject other ) { return spUnsignedIntArray( IUnsignedIntArray::SafeCast( other.GetInterface() ) ); }
	inline IUnsignedIntArray* spUnsignedIntArray::operator->() const { return static_cast<IUnsignedIntArray*>(this->ptr); }

	/// Implementations of spUnsignedLongArray methods
	inline spUnsignedLongArray::spUnsignedLongArray( IUnsignedLongArray *p ) : spValueArray(p) {}
	inline spUnsignedLongArray::spUnsignedLongArray( const spUnsignedLongArray &p ) : spValueArray(p) {}
	inline spUnsignedLongArray& spUnsignedLongArray::operator=( const spUnsignedLongArray &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spUnsignedLongArray spUnsignedLongArray::SafeCast( spObject other ) { return spUnsignedLongArray( IUnsignedLongArray::SafeCast( other.GetInterface() ) ); }
	inline IUnsignedLongArray* spUnsignedLongArray::operator->() const { return static_cast<IUnsignedLongArray*>(this->ptr); }

	/// Implementations of spUnsignedShortArray methods
	inline spUnsignedShortArray::spUnsignedShortArray( IUnsignedShortArray *p ) : spValueArray(p) {}
	inline spUnsignedShortArray::spUnsignedShortArray( const spUnsignedShortArray &p ) : spValueArray(p) {}
	inline spUnsignedShortArray& spUnsignedShortArray::operator=( const spUnsignedShortArray &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spUnsignedShortArray spUnsignedShortArray::SafeCast( spObject other ) { return spUnsignedShortArray( IUnsignedShortArray::SafeCast( other.GetInterface() ) ); }
	inline IUnsignedShortArray* spUnsignedShortArray::operator->() const { return static_cast<IUnsignedShortArray*>(this->ptr); }

	/// Implementations of spChunkedImageData methods
	inline spChunkedImageData::spChunkedImageData( IChunkedImageData *p ) : spObject(p) {}
	inline spChunkedImageData::spChunkedImageData( const spChunkedImageData &p ) : spObject(p) {}
	inline spChunkedImageData& spChunkedImageData::operator=( const spChunkedImageData &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spChunkedImageData spChunkedImageData::SafeCast( spObject other ) { return spChunkedImageData( IChunkedImageData::SafeCast( other.GetInterface() ) ); }
	inline IChunkedImageData* spChunkedImageData::operator->() const { return static_cast<IChunkedImageData*>(this->ptr); }

	/// Implementations of spDirectXRenderer methods
	inline spDirectXRenderer::spDirectXRenderer( IDirectXRenderer *p ) : spObject(p) {}
	inline spDirectXRenderer::spDirectXRenderer( const spDirectXRenderer &p ) : spObject(p) {}
	inline spDirectXRenderer& spDirectXRenderer::operator=( const spDirectXRenderer &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spDirectXRenderer spDirectXRenderer::SafeCast( spObject other ) { return spDirectXRenderer( IDirectXRenderer::SafeCast( other.GetInterface() ) ); }
	inline IDirectXRenderer* spDirectXRenderer::operator->() const { return static_cast<IDirectXRenderer*>(this->ptr); }

	/// Implementations of spFieldData methods
	inline spFieldData::spFieldData( IFieldData *p ) : spObject(p) {}
	inline spFieldData::spFieldData( const spFieldData &p ) : spObject(p) {}
	inline spFieldData& spFieldData::operator=( const spFieldData &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spFieldData spFieldData::SafeCast( spObject other ) { return spFieldData( IFieldData::SafeCast( other.GetInterface() ) ); }
	inline IFieldData* spFieldData::operator->() const { return static_cast<IFieldData*>(this->ptr); }

	/// Implementations of spGeometryData methods
	inline spGeometryData::spGeometryData( IGeometryData *p ) : spObject(p) {}
	inline spGeometryData::spGeometryData( const spGeometryData &p ) : spObject(p) {}
	inline spGeometryData& spGeometryData::operator=( const spGeometryData &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spGeometryData spGeometryData::SafeCast( spObject other ) { return spGeometryData( IGeometryData::SafeCast( other.GetInterface() ) ); }
	inline IGeometryData* spGeometryData::operator->() const { return static_cast<IGeometryData*>(this->ptr); }

	/// Implementations of spPackedGeometryData methods
	inline spPackedGeometryData::spPackedGeometryData( IPackedGeometryData *p ) : spObject(p) {}
	inline spPackedGeometryData::spPackedGeometryData( const spPackedGeometryData &p ) : spObject(p) {}
	inline spPackedGeometryData& spPackedGeometryData::operator=( const spPackedGeometryData &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spPackedGeometryData spPackedGeometryData::SafeCast( spObject other ) { return spPackedGeometryData( IPackedGeometryData::SafeCast( other.GetInterface() ) ); }
	inline IPackedGeometryData* spPackedGeometryData::operator->() const { return static_cast<IPackedGeometryData*>(this->ptr); }

	/// Implementations of spImageData methods
	inline spImageData::spImageData( IImageData *p ) : spObject(p) {}
	inline spImageData::spImageData( const spImageData &p ) : spObject(p) {}
	inline spImageData& spImageData::operator=( const spImageData &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spImageData spImageData::SafeCast( spObject other ) { return spImageData( IImageData::SafeCast( other.GetInterface() ) ); }
	inline IImageData* spImageData::operator->() const { return static_cast<IImageData*>(this->ptr); }

	/// Implementations of spTable methods
	inline spTable::spTable( ITable *p ) : spObject(p) {}
	inline spTable::spTable( const spTable &p ) : spObject(p) {}
	inline spTable& spTable::operator=( const spTable &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spTable spTable::SafeCast( spObject other ) { return spTable( ITable::SafeCast( other.GetInterface() ) ); }
	inline ITable* spTable::operator->() const { return static_cast<ITable*>(this->ptr); }

	/// Implementations of spMaterial methods
	inline spMaterial::spMaterial( IMaterial *p ) : spObject(p) {}
	inline spMaterial::spMaterial( const spMaterial &p ) : spObject(p) {}
	inline spMaterial& spMaterial::operator=( const spMaterial &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spMaterial spMaterial::SafeCast( spObject other ) { return spMaterial( IMaterial::SafeCast( other.GetInterface() ) ); }
	inline IMaterial* spMaterial::operator->() const { return static_cast<IMaterial*>(this->ptr); }

	/// Implementations of spMaterialTable methods
	inline spMaterialTable::spMaterialTable( IMaterialTable *p ) : spTable(p) {}
	inline spMaterialTable::spMaterialTable( const spMaterialTable &p ) : spTable(p) {}
	inline spMaterialTable& spMaterialTable::operator=( const spMaterialTable &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spMaterialTable spMaterialTable::SafeCast( spObject other ) { return spMaterialTable( IMaterialTable::SafeCast( other.GetInterface() ) ); }
	inline IMaterialTable* spMaterialTable::operator->() const { return static_cast<IMaterialTable*>(this->ptr); }

	/// Implementations of spMatrix4x4 methods
	inline spMatrix4x4::spMatrix4x4( IMatrix4x4 *p ) : spObject(p) {}
	inline spMatrix4x4::spMatrix4x4( const spMatrix4x4 &p ) : spObject(p) {}
	inline spMatrix4x4& spMatrix4x4::operator=( const spMatrix4x4 &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spMatrix4x4 spMatrix4x4::SafeCast( spObject other ) { return spMatrix4x4( IMatrix4x4::SafeCast( other.GetInterface() ) ); }
	inline IMatrix4x4* spMatrix4x4::operator->() const { return static_cast<IMatrix4x4*>(this->ptr); }

	/// Implementations of spTransform3 methods
	inline spTransform3::spTransform3( ITransform3 *p ) : spObject(p) {}
	inline spTransform3::spTransform3( const spTransform3 &p ) : spObject(p) {}
	inline spTransform3& spTransform3::operator=( const spTransform3 &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spTransform3 spTransform3::SafeCast( spObject other ) { return spTransform3( ITransform3::SafeCast( other.GetInterface() ) ); }
	inline ITransform3* spTransform3::operator->() const { return static_cast<ITransform3*>(this->ptr); }

	/// Implementations of spMappingImage methods
	inline spMappingImage::spMappingImage( IMappingImage *p ) : spObject(p) {}
	inline spMappingImage::spMappingImage( const spMappingImage &p ) : spObject(p) {}
	inline spMappingImage& spMappingImage::operator=( const spMappingImage &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spMappingImage spMappingImage::SafeCast( spObject other ) { return spMappingImage( IMappingImage::SafeCast( other.GetInterface() ) ); }
	inline IMappingImage* spMappingImage::operator->() const { return static_cast<IMappingImage*>(this->ptr); }

	/// Implementations of spProcessingObject methods
	inline spProcessingObject::spProcessingObject( IProcessingObject *p ) : spObject(p) {}
	inline spProcessingObject::spProcessingObject( const spProcessingObject &p ) : spObject(p) {}
	inline spProcessingObject& spProcessingObject::operator=( const spProcessingObject &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spProcessingObject spProcessingObject::SafeCast( spObject other ) { return spProcessingObject( IProcessingObject::SafeCast( other.GetInterface() ) ); }
	inline IProcessingObject* spProcessingObject::operator->() const { return static_cast<IProcessingObject*>(this->ptr); }

	/// Implementations of spParameterizer methods
	inline spParameterizer::spParameterizer( IParameterizer *p ) : spObject(p) {}
	inline spParameterizer::spParameterizer( const spParameterizer &p ) : spObject(p) {}
	inline spParameterizer& spParameterizer::operator=( const spParameterizer &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spParameterizer spParameterizer::SafeCast( spObject other ) { return spParameterizer( IParameterizer::SafeCast( other.GetInterface() ) ); }
	inline IParameterizer* spParameterizer::operator->() const { return static_cast<IParameterizer*>(this->ptr); }

	/// Implementations of spObjectCollection methods
	inline spObjectCollection::spObjectCollection( IObjectCollection *p ) : spObject(p) {}
	inline spObjectCollection::spObjectCollection( const spObjectCollection &p ) : spObject(p) {}
	inline spObjectCollection& spObjectCollection::operator=( const spObjectCollection &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spObjectCollection spObjectCollection::SafeCast( spObject other ) { return spObjectCollection( IObjectCollection::SafeCast( other.GetInterface() ) ); }
	inline IObjectCollection* spObjectCollection::operator->() const { return static_cast<IObjectCollection*>(this->ptr); }

	/// Implementations of spGeometryDataCollection methods
	inline spGeometryDataCollection::spGeometryDataCollection( IGeometryDataCollection *p ) : spObjectCollection(p) {}
	inline spGeometryDataCollection::spGeometryDataCollection( const spGeometryDataCollection &p ) : spObjectCollection(p) {}
	inline spGeometryDataCollection& spGeometryDataCollection::operator=( const spGeometryDataCollection &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spGeometryDataCollection spGeometryDataCollection::SafeCast( spObject other ) { return spGeometryDataCollection( IGeometryDataCollection::SafeCast( other.GetInterface() ) ); }
	inline IGeometryDataCollection* spGeometryDataCollection::operator->() const { return static_cast<IGeometryDataCollection*>(this->ptr); }

	/// Implementations of spGraphicsImporter methods
	inline spGraphicsImporter::spGraphicsImporter( IGraphicsImporter *p ) : spObject(p) {}
	inline spGraphicsImporter::spGraphicsImporter( const spGraphicsImporter &p ) : spObject(p) {}
	inline spGraphicsImporter& spGraphicsImporter::operator=( const spGraphicsImporter &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spGraphicsImporter spGraphicsImporter::SafeCast( spObject other ) { return spGraphicsImporter( IGraphicsImporter::SafeCast( other.GetInterface() ) ); }
	inline IGraphicsImporter* spGraphicsImporter::operator->() const { return static_cast<IGraphicsImporter*>(this->ptr); }

	/// Implementations of spWavefrontImporter methods
	inline spWavefrontImporter::spWavefrontImporter( IWavefrontImporter *p ) : spGraphicsImporter(p) {}
	inline spWavefrontImporter::spWavefrontImporter( const spWavefrontImporter &p ) : spGraphicsImporter(p) {}
	inline spWavefrontImporter& spWavefrontImporter::operator=( const spWavefrontImporter &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spWavefrontImporter spWavefrontImporter::SafeCast( spObject other ) { return spWavefrontImporter( IWavefrontImporter::SafeCast( other.GetInterface() ) ); }
	inline IWavefrontImporter* spWavefrontImporter::operator->() const { return static_cast<IWavefrontImporter*>(this->ptr); }

	/// Implementations of spGLTFImporter methods
	inline spGLTFImporter::spGLTFImporter( IGLTFImporter *p ) : spGraphicsImporter(p) {}
	inline spGLTFImporter::spGLTFImporter( const spGLTFImporter &p ) : spGraphicsImporter(p) {}
	inline spGLTFImporter& spGLTFImporter::operator=( const spGLTFImporter &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spGLTFImporter spGLTFImporter::SafeCast( spObject other ) { return spGLTFImporter( IGLTFImporter::SafeCast( other.GetInterface() ) ); }
	inline IGLTFImporter* spGLTFImporter::operator->() const { return static_cast<IGLTFImporter*>(this->ptr); }

	/// Implementations of spFBXImporter methods
	inline spFBXImporter::spFBXImporter( IFBXImporter *p ) : spGraphicsImporter(p) {}
	inline spFBXImporter::spFBXImporter( const spFBXImporter &p ) : spGraphicsImporter(p) {}
	inline spFBXImporter& spFBXImporter::operator=( const spFBXImporter &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spFBXImporter spFBXImporter::SafeCast( spObject other ) { return spFBXImporter( IFBXImporter::SafeCast( other.GetInterface() ) ); }
	inline IFBXImporter* spFBXImporter::operator->() const { return static_cast<IFBXImporter*>(this->ptr); }

	/// Implementations of spGraphicsExporter methods
	inline spGraphicsExporter::spGraphicsExporter( IGraphicsExporter *p ) : spObject(p) {}
	inline spGraphicsExporter::spGraphicsExporter( const spGraphicsExporter &p ) : spObject(p) {}
	inline spGraphicsExporter& spGraphicsExporter::operator=( const spGraphicsExporter &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spGraphicsExporter spGraphicsExporter::SafeCast( spObject other ) { return spGraphicsExporter( IGraphicsExporter::SafeCast( other.GetInterface() ) ); }
	inline IGraphicsExporter* spGraphicsExporter::operator->() const { return static_cast<IGraphicsExporter*>(this->ptr); }

	/// Implementations of spWavefrontExporter methods
	inline spWavefrontExporter::spWavefrontExporter( IWavefrontExporter *p ) : spGraphicsExporter(p) {}
	inline spWavefrontExporter::spWavefrontExporter( const spWavefrontExporter &p ) : spGraphicsExporter(p) {}
	inline spWavefrontExporter& spWavefrontExporter::operator=( const spWavefrontExporter &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spWavefrontExporter spWavefrontExporter::SafeCast( spObject other ) { return spWavefrontExporter( IWavefrontExporter::SafeCast( other.GetInterface() ) ); }
	inline IWavefrontExporter* spWavefrontExporter::operator->() const { return static_cast<IWavefrontExporter*>(this->ptr); }

	/// Implementations of spFBXExporter methods
	inline spFBXExporter::spFBXExporter( IFBXExporter *p ) : spGraphicsExporter(p) {}
	inline spFBXExporter::spFBXExporter( const spFBXExporter &p ) : spGraphicsExporter(p) {}
	inline spFBXExporter& spFBXExporter::operator=( const spFBXExporter &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spFBXExporter spFBXExporter::SafeCast( spObject other ) { return spFBXExporter( IFBXExporter::SafeCast( other.GetInterface() ) ); }
	inline IFBXExporter* spFBXExporter::operator->() const { return static_cast<IFBXExporter*>(this->ptr); }

	/// Implementations of spGLTFExporter methods
	inline spGLTFExporter::spGLTFExporter( IGLTFExporter *p ) : spGraphicsExporter(p) {}
	inline spGLTFExporter::spGLTFExporter( const spGLTFExporter &p ) : spGraphicsExporter(p) {}
	inline spGLTFExporter& spGLTFExporter::operator=( const spGLTFExporter &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spGLTFExporter spGLTFExporter::SafeCast( spObject other ) { return spGLTFExporter( IGLTFExporter::SafeCast( other.GetInterface() ) ); }
	inline IGLTFExporter* spGLTFExporter::operator->() const { return static_cast<IGLTFExporter*>(this->ptr); }

	/// Implementations of spBinaryImporter methods
	inline spBinaryImporter::spBinaryImporter( IBinaryImporter *p ) : spGraphicsImporter(p) {}
	inline spBinaryImporter::spBinaryImporter( const spBinaryImporter &p ) : spGraphicsImporter(p) {}
	inline spBinaryImporter& spBinaryImporter::operator=( const spBinaryImporter &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spBinaryImporter spBinaryImporter::SafeCast( spObject other ) { return spBinaryImporter( IBinaryImporter::SafeCast( other.GetInterface() ) ); }
	inline IBinaryImporter* spBinaryImporter::operator->() const { return static_cast<IBinaryImporter*>(this->ptr); }

	/// Implementations of spBinaryExporter methods
	inline spBinaryExporter::spBinaryExporter( IBinaryExporter *p ) : spGraphicsExporter(p) {}
	inline spBinaryExporter::spBinaryExporter( const spBinaryExporter &p ) : spGraphicsExporter(p) {}
	inline spBinaryExporter& spBinaryExporter::operator=( const spBinaryExporter &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spBinaryExporter spBinaryExporter::SafeCast( spObject other ) { return spBinaryExporter( IBinaryExporter::SafeCast( other.GetInterface() ) ); }
	inline IBinaryExporter* spBinaryExporter::operator->() const { return static_cast<IBinaryExporter*>(this->ptr); }

	/// Implementations of spGeometryValidator methods
	inline spGeometryValidator::spGeometryValidator( IGeometryValidator *p ) : spObject(p) {}
	inline spGeometryValidator::spGeometryValidator( const spGeometryValidator &p ) : spObject(p) {}
	inline spGeometryValidator& spGeometryValidator::operator=( const spGeometryValidator &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spGeometryValidator spGeometryValidator::SafeCast( spObject other ) { return spGeometryValidator( IGeometryValidator::SafeCast( other.GetInterface() ) ); }
	inline IGeometryValidator* spGeometryValidator::operator->() const { return static_cast<IGeometryValidator*>(this->ptr); }

	/// Implementations of spSettingsObject methods
	inline spSettingsObject::spSettingsObject( ISettingsObject *p ) : spObject(p) {}
	inline spSettingsObject::spSettingsObject( const spSettingsObject &p ) : spObject(p) {}
	inline spSettingsObject& spSettingsObject::operator=( const spSettingsObject &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spSettingsObject spSettingsObject::SafeCast( spObject other ) { return spSettingsObject( ISettingsObject::SafeCast( other.GetInterface() ) ); }
	inline ISettingsObject* spSettingsObject::operator->() const { return static_cast<ISettingsObject*>(this->ptr); }

	/// Implementations of spMaterialCaster methods
	inline spMaterialCaster::spMaterialCaster( IMaterialCaster *p ) : spProcessingObject(p) {}
	inline spMaterialCaster::spMaterialCaster( const spMaterialCaster &p ) : spProcessingObject(p) {}
	inline spMaterialCaster& spMaterialCaster::operator=( const spMaterialCaster &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spMaterialCaster spMaterialCaster::SafeCast( spObject other ) { return spMaterialCaster( IMaterialCaster::SafeCast( other.GetInterface() ) ); }
	inline IMaterialCaster* spMaterialCaster::operator->() const { return static_cast<IMaterialCaster*>(this->ptr); }

	/// Implementations of spMaterialCasterSettings methods
	inline spMaterialCasterSettings::spMaterialCasterSettings( IMaterialCasterSettings *p ) : spSettingsObject(p) {}
	inline spMaterialCasterSettings::spMaterialCasterSettings( const spMaterialCasterSettings &p ) : spSettingsObject(p) {}
	inline spMaterialCasterSettings& spMaterialCasterSettings::operator=( const spMaterialCasterSettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spMaterialCasterSettings spMaterialCasterSettings::SafeCast( spObject other ) { return spMaterialCasterSettings( IMaterialCasterSettings::SafeCast( other.GetInterface() ) ); }
	inline IMaterialCasterSettings* spMaterialCasterSettings::operator->() const { return static_cast<IMaterialCasterSettings*>(this->ptr); }

	/// Implementations of spColorCaster methods
	inline spColorCaster::spColorCaster( IColorCaster *p ) : spMaterialCaster(p) {}
	inline spColorCaster::spColorCaster( const spColorCaster &p ) : spMaterialCaster(p) {}
	inline spColorCaster& spColorCaster::operator=( const spColorCaster &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spColorCaster spColorCaster::SafeCast( spObject other ) { return spColorCaster( IColorCaster::SafeCast( other.GetInterface() ) ); }
	inline IColorCaster* spColorCaster::operator->() const { return static_cast<IColorCaster*>(this->ptr); }

	/// Implementations of spColorCasterSettings methods
	inline spColorCasterSettings::spColorCasterSettings( IColorCasterSettings *p ) : spMaterialCasterSettings(p) {}
	inline spColorCasterSettings::spColorCasterSettings( const spColorCasterSettings &p ) : spMaterialCasterSettings(p) {}
	inline spColorCasterSettings& spColorCasterSettings::operator=( const spColorCasterSettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spColorCasterSettings spColorCasterSettings::SafeCast( spObject other ) { return spColorCasterSettings( IColorCasterSettings::SafeCast( other.GetInterface() ) ); }
	inline IColorCasterSettings* spColorCasterSettings::operator->() const { return static_cast<IColorCasterSettings*>(this->ptr); }

	/// Implementations of spOpacityCaster methods
	inline spOpacityCaster::spOpacityCaster( IOpacityCaster *p ) : spMaterialCaster(p) {}
	inline spOpacityCaster::spOpacityCaster( const spOpacityCaster &p ) : spMaterialCaster(p) {}
	inline spOpacityCaster& spOpacityCaster::operator=( const spOpacityCaster &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spOpacityCaster spOpacityCaster::SafeCast( spObject other ) { return spOpacityCaster( IOpacityCaster::SafeCast( other.GetInterface() ) ); }
	inline IOpacityCaster* spOpacityCaster::operator->() const { return static_cast<IOpacityCaster*>(this->ptr); }

	/// Implementations of spOpacityCasterSettings methods
	inline spOpacityCasterSettings::spOpacityCasterSettings( IOpacityCasterSettings *p ) : spMaterialCasterSettings(p) {}
	inline spOpacityCasterSettings::spOpacityCasterSettings( const spOpacityCasterSettings &p ) : spMaterialCasterSettings(p) {}
	inline spOpacityCasterSettings& spOpacityCasterSettings::operator=( const spOpacityCasterSettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spOpacityCasterSettings spOpacityCasterSettings::SafeCast( spObject other ) { return spOpacityCasterSettings( IOpacityCasterSettings::SafeCast( other.GetInterface() ) ); }
	inline IOpacityCasterSettings* spOpacityCasterSettings::operator->() const { return static_cast<IOpacityCasterSettings*>(this->ptr); }

	/// Implementations of spNormalCaster methods
	inline spNormalCaster::spNormalCaster( INormalCaster *p ) : spMaterialCaster(p) {}
	inline spNormalCaster::spNormalCaster( const spNormalCaster &p ) : spMaterialCaster(p) {}
	inline spNormalCaster& spNormalCaster::operator=( const spNormalCaster &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spNormalCaster spNormalCaster::SafeCast( spObject other ) { return spNormalCaster( INormalCaster::SafeCast( other.GetInterface() ) ); }
	inline INormalCaster* spNormalCaster::operator->() const { return static_cast<INormalCaster*>(this->ptr); }

	/// Implementations of spNormalCasterSettings methods
	inline spNormalCasterSettings::spNormalCasterSettings( INormalCasterSettings *p ) : spMaterialCasterSettings(p) {}
	inline spNormalCasterSettings::spNormalCasterSettings( const spNormalCasterSettings &p ) : spMaterialCasterSettings(p) {}
	inline spNormalCasterSettings& spNormalCasterSettings::operator=( const spNormalCasterSettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spNormalCasterSettings spNormalCasterSettings::SafeCast( spObject other ) { return spNormalCasterSettings( INormalCasterSettings::SafeCast( other.GetInterface() ) ); }
	inline INormalCasterSettings* spNormalCasterSettings::operator->() const { return static_cast<INormalCasterSettings*>(this->ptr); }

	/// Implementations of spNormalRepairer methods
	inline spNormalRepairer::spNormalRepairer( INormalRepairer *p ) : spProcessingObject(p) {}
	inline spNormalRepairer::spNormalRepairer( const spNormalRepairer &p ) : spProcessingObject(p) {}
	inline spNormalRepairer& spNormalRepairer::operator=( const spNormalRepairer &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spNormalRepairer spNormalRepairer::SafeCast( spObject other ) { return spNormalRepairer( INormalRepairer::SafeCast( other.GetInterface() ) ); }
	inline INormalRepairer* spNormalRepairer::operator->() const { return static_cast<INormalRepairer*>(this->ptr); }

	/// Implementations of spDisplacementCaster methods
	inline spDisplacementCaster::spDisplacementCaster( IDisplacementCaster *p ) : spMaterialCaster(p) {}
	inline spDisplacementCaster::spDisplacementCaster( const spDisplacementCaster &p ) : spMaterialCaster(p) {}
	inline spDisplacementCaster& spDisplacementCaster::operator=( const spDisplacementCaster &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spDisplacementCaster spDisplacementCaster::SafeCast( spObject other ) { return spDisplacementCaster( IDisplacementCaster::SafeCast( other.GetInterface() ) ); }
	inline IDisplacementCaster* spDisplacementCaster::operator->() const { return static_cast<IDisplacementCaster*>(this->ptr); }

	/// Implementations of spDisplacementCasterSettings methods
	inline spDisplacementCasterSettings::spDisplacementCasterSettings( IDisplacementCasterSettings *p ) : spMaterialCasterSettings(p) {}
	inline spDisplacementCasterSettings::spDisplacementCasterSettings( const spDisplacementCasterSettings &p ) : spMaterialCasterSettings(p) {}
	inline spDisplacementCasterSettings& spDisplacementCasterSettings::operator=( const spDisplacementCasterSettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spDisplacementCasterSettings spDisplacementCasterSettings::SafeCast( spObject other ) { return spDisplacementCasterSettings( IDisplacementCasterSettings::SafeCast( other.GetInterface() ) ); }
	inline IDisplacementCasterSettings* spDisplacementCasterSettings::operator->() const { return static_cast<IDisplacementCasterSettings*>(this->ptr); }

	/// Implementations of spTangentCalculator methods
	inline spTangentCalculator::spTangentCalculator( ITangentCalculator *p ) : spObject(p) {}
	inline spTangentCalculator::spTangentCalculator( const spTangentCalculator &p ) : spObject(p) {}
	inline spTangentCalculator& spTangentCalculator::operator=( const spTangentCalculator &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spTangentCalculator spTangentCalculator::SafeCast( spObject other ) { return spTangentCalculator( ITangentCalculator::SafeCast( other.GetInterface() ) ); }
	inline ITangentCalculator* spTangentCalculator::operator->() const { return static_cast<ITangentCalculator*>(this->ptr); }

	/// Implementations of spRepairSettings methods
	inline spRepairSettings::spRepairSettings( IRepairSettings *p ) : spSettingsObject(p) {}
	inline spRepairSettings::spRepairSettings( const spRepairSettings &p ) : spSettingsObject(p) {}
	inline spRepairSettings& spRepairSettings::operator=( const spRepairSettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spRepairSettings spRepairSettings::SafeCast( spObject other ) { return spRepairSettings( IRepairSettings::SafeCast( other.GetInterface() ) ); }
	inline IRepairSettings* spRepairSettings::operator->() const { return static_cast<IRepairSettings*>(this->ptr); }

	/// Implementations of spBoneSettings methods
	inline spBoneSettings::spBoneSettings( IBoneSettings *p ) : spSettingsObject(p) {}
	inline spBoneSettings::spBoneSettings( const spBoneSettings &p ) : spSettingsObject(p) {}
	inline spBoneSettings& spBoneSettings::operator=( const spBoneSettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spBoneSettings spBoneSettings::SafeCast( spObject other ) { return spBoneSettings( IBoneSettings::SafeCast( other.GetInterface() ) ); }
	inline IBoneSettings* spBoneSettings::operator->() const { return static_cast<IBoneSettings*>(this->ptr); }

	/// Implementations of spReductionSettings methods
	inline spReductionSettings::spReductionSettings( IReductionSettings *p ) : spSettingsObject(p) {}
	inline spReductionSettings::spReductionSettings( const spReductionSettings &p ) : spSettingsObject(p) {}
	inline spReductionSettings& spReductionSettings::operator=( const spReductionSettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spReductionSettings spReductionSettings::SafeCast( spObject other ) { return spReductionSettings( IReductionSettings::SafeCast( other.GetInterface() ) ); }
	inline IReductionSettings* spReductionSettings::operator->() const { return static_cast<IReductionSettings*>(this->ptr); }

	/// Implementations of spNormalCalculationSettings methods
	inline spNormalCalculationSettings::spNormalCalculationSettings( INormalCalculationSettings *p ) : spSettingsObject(p) {}
	inline spNormalCalculationSettings::spNormalCalculationSettings( const spNormalCalculationSettings &p ) : spSettingsObject(p) {}
	inline spNormalCalculationSettings& spNormalCalculationSettings::operator=( const spNormalCalculationSettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spNormalCalculationSettings spNormalCalculationSettings::SafeCast( spObject other ) { return spNormalCalculationSettings( INormalCalculationSettings::SafeCast( other.GetInterface() ) ); }
	inline INormalCalculationSettings* spNormalCalculationSettings::operator->() const { return static_cast<INormalCalculationSettings*>(this->ptr); }

	/// Implementations of spMappingImageSettings methods
	inline spMappingImageSettings::spMappingImageSettings( IMappingImageSettings *p ) : spSettingsObject(p) {}
	inline spMappingImageSettings::spMappingImageSettings( const spMappingImageSettings &p ) : spSettingsObject(p) {}
	inline spMappingImageSettings& spMappingImageSettings::operator=( const spMappingImageSettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spMappingImageSettings spMappingImageSettings::SafeCast( spObject other ) { return spMappingImageSettings( IMappingImageSettings::SafeCast( other.GetInterface() ) ); }
	inline IMappingImageSettings* spMappingImageSettings::operator->() const { return static_cast<IMappingImageSettings*>(this->ptr); }

	/// Implementations of spMappingImageInputMaterialSettings methods
	inline spMappingImageInputMaterialSettings::spMappingImageInputMaterialSettings( IMappingImageInputMaterialSettings *p ) : spSettingsObject(p) {}
	inline spMappingImageInputMaterialSettings::spMappingImageInputMaterialSettings( const spMappingImageInputMaterialSettings &p ) : spSettingsObject(p) {}
	inline spMappingImageInputMaterialSettings& spMappingImageInputMaterialSettings::operator=( const spMappingImageInputMaterialSettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spMappingImageInputMaterialSettings spMappingImageInputMaterialSettings::SafeCast( spObject other ) { return spMappingImageInputMaterialSettings( IMappingImageInputMaterialSettings::SafeCast( other.GetInterface() ) ); }
	inline IMappingImageInputMaterialSettings* spMappingImageInputMaterialSettings::operator->() const { return static_cast<IMappingImageInputMaterialSettings*>(this->ptr); }

	/// Implementations of spMappingImageOutputMaterialSettings methods
	inline spMappingImageOutputMaterialSettings::spMappingImageOutputMaterialSettings( IMappingImageOutputMaterialSettings *p ) : spSettingsObject(p) {}
	inline spMappingImageOutputMaterialSettings::spMappingImageOutputMaterialSettings( const spMappingImageOutputMaterialSettings &p ) : spSettingsObject(p) {}
	inline spMappingImageOutputMaterialSettings& spMappingImageOutputMaterialSettings::operator=( const spMappingImageOutputMaterialSettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spMappingImageOutputMaterialSettings spMappingImageOutputMaterialSettings::SafeCast( spObject other ) { return spMappingImageOutputMaterialSettings( IMappingImageOutputMaterialSettings::SafeCast( other.GetInterface() ) ); }
	inline IMappingImageOutputMaterialSettings* spMappingImageOutputMaterialSettings::operator->() const { return static_cast<IMappingImageOutputMaterialSettings*>(this->ptr); }

	/// Implementations of spVisibilitySettings methods
	inline spVisibilitySettings::spVisibilitySettings( IVisibilitySettings *p ) : spSettingsObject(p) {}
	inline spVisibilitySettings::spVisibilitySettings( const spVisibilitySettings &p ) : spSettingsObject(p) {}
	inline spVisibilitySettings& spVisibilitySettings::operator=( const spVisibilitySettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spVisibilitySettings spVisibilitySettings::SafeCast( spObject other ) { return spVisibilitySettings( IVisibilitySettings::SafeCast( other.GetInterface() ) ); }
	inline IVisibilitySettings* spVisibilitySettings::operator->() const { return static_cast<IVisibilitySettings*>(this->ptr); }

	/// Implementations of spReductionProcessor methods
	inline spReductionProcessor::spReductionProcessor( IReductionProcessor *p ) : spProcessingObject(p) {}
	inline spReductionProcessor::spReductionProcessor( const spReductionProcessor &p ) : spProcessingObject(p) {}
	inline spReductionProcessor& spReductionProcessor::operator=( const spReductionProcessor &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spReductionProcessor spReductionProcessor::SafeCast( spObject other ) { return spReductionProcessor( IReductionProcessor::SafeCast( other.GetInterface() ) ); }
	inline IReductionProcessor* spReductionProcessor::operator->() const { return static_cast<IReductionProcessor*>(this->ptr); }

	/// Implementations of spRemeshingLegacySettings methods
	inline spRemeshingLegacySettings::spRemeshingLegacySettings( IRemeshingLegacySettings *p ) : spSettingsObject(p) {}
	inline spRemeshingLegacySettings::spRemeshingLegacySettings( const spRemeshingLegacySettings &p ) : spSettingsObject(p) {}
	inline spRemeshingLegacySettings& spRemeshingLegacySettings::operator=( const spRemeshingLegacySettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spRemeshingLegacySettings spRemeshingLegacySettings::SafeCast( spObject other ) { return spRemeshingLegacySettings( IRemeshingLegacySettings::SafeCast( other.GetInterface() ) ); }
	inline IRemeshingLegacySettings* spRemeshingLegacySettings::operator->() const { return static_cast<IRemeshingLegacySettings*>(this->ptr); }

	/// Implementations of spRemeshingSettings methods
	inline spRemeshingSettings::spRemeshingSettings( IRemeshingSettings *p ) : spSettingsObject(p) {}
	inline spRemeshingSettings::spRemeshingSettings( const spRemeshingSettings &p ) : spSettingsObject(p) {}
	inline spRemeshingSettings& spRemeshingSettings::operator=( const spRemeshingSettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spRemeshingSettings spRemeshingSettings::SafeCast( spObject other ) { return spRemeshingSettings( IRemeshingSettings::SafeCast( other.GetInterface() ) ); }
	inline IRemeshingSettings* spRemeshingSettings::operator->() const { return static_cast<IRemeshingSettings*>(this->ptr); }

	/// Implementations of spRemeshingLegacyProcessor methods
	inline spRemeshingLegacyProcessor::spRemeshingLegacyProcessor( IRemeshingLegacyProcessor *p ) : spProcessingObject(p) {}
	inline spRemeshingLegacyProcessor::spRemeshingLegacyProcessor( const spRemeshingLegacyProcessor &p ) : spProcessingObject(p) {}
	inline spRemeshingLegacyProcessor& spRemeshingLegacyProcessor::operator=( const spRemeshingLegacyProcessor &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spRemeshingLegacyProcessor spRemeshingLegacyProcessor::SafeCast( spObject other ) { return spRemeshingLegacyProcessor( IRemeshingLegacyProcessor::SafeCast( other.GetInterface() ) ); }
	inline IRemeshingLegacyProcessor* spRemeshingLegacyProcessor::operator->() const { return static_cast<IRemeshingLegacyProcessor*>(this->ptr); }

	/// Implementations of spRemeshingProcessor methods
	inline spRemeshingProcessor::spRemeshingProcessor( IRemeshingProcessor *p ) : spProcessingObject(p) {}
	inline spRemeshingProcessor::spRemeshingProcessor( const spRemeshingProcessor &p ) : spProcessingObject(p) {}
	inline spRemeshingProcessor& spRemeshingProcessor::operator=( const spRemeshingProcessor &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spRemeshingProcessor spRemeshingProcessor::SafeCast( spObject other ) { return spRemeshingProcessor( IRemeshingProcessor::SafeCast( other.GetInterface() ) ); }
	inline IRemeshingProcessor* spRemeshingProcessor::operator->() const { return static_cast<IRemeshingProcessor*>(this->ptr); }

	/// Implementations of spScene methods
	inline spScene::spScene( IScene *p ) : spObject(p) {}
	inline spScene::spScene( const spScene &p ) : spObject(p) {}
	inline spScene& spScene::operator=( const spScene &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spScene spScene::SafeCast( spObject other ) { return spScene( IScene::SafeCast( other.GetInterface() ) ); }
	inline IScene* spScene::operator->() const { return static_cast<IScene*>(this->ptr); }

	/// Implementations of spSceneNode methods
	inline spSceneNode::spSceneNode( ISceneNode *p ) : spObject(p) {}
	inline spSceneNode::spSceneNode( const spSceneNode &p ) : spObject(p) {}
	inline spSceneNode& spSceneNode::operator=( const spSceneNode &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spSceneNode spSceneNode::SafeCast( spObject other ) { return spSceneNode( ISceneNode::SafeCast( other.GetInterface() ) ); }
	inline ISceneNode* spSceneNode::operator->() const { return static_cast<ISceneNode*>(this->ptr); }

	/// Implementations of spSceneNodeCollection methods
	inline spSceneNodeCollection::spSceneNodeCollection( ISceneNodeCollection *p ) : spObjectCollection(p) {}
	inline spSceneNodeCollection::spSceneNodeCollection( const spSceneNodeCollection &p ) : spObjectCollection(p) {}
	inline spSceneNodeCollection& spSceneNodeCollection::operator=( const spSceneNodeCollection &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spSceneNodeCollection spSceneNodeCollection::SafeCast( spObject other ) { return spSceneNodeCollection( ISceneNodeCollection::SafeCast( other.GetInterface() ) ); }
	inline ISceneNodeCollection* spSceneNodeCollection::operator->() const { return static_cast<ISceneNodeCollection*>(this->ptr); }

	/// Implementations of spSceneMesh methods
	inline spSceneMesh::spSceneMesh( ISceneMesh *p ) : spSceneNode(p) {}
	inline spSceneMesh::spSceneMesh( const spSceneMesh &p ) : spSceneNode(p) {}
	inline spSceneMesh& spSceneMesh::operator=( const spSceneMesh &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spSceneMesh spSceneMesh::SafeCast( spObject other ) { return spSceneMesh( ISceneMesh::SafeCast( other.GetInterface() ) ); }
	inline ISceneMesh* spSceneMesh::operator->() const { return static_cast<ISceneMesh*>(this->ptr); }

	/// Implementations of spSceneLodGroup methods
	inline spSceneLodGroup::spSceneLodGroup( ISceneLodGroup *p ) : spSceneNode(p) {}
	inline spSceneLodGroup::spSceneLodGroup( const spSceneLodGroup &p ) : spSceneNode(p) {}
	inline spSceneLodGroup& spSceneLodGroup::operator=( const spSceneLodGroup &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spSceneLodGroup spSceneLodGroup::SafeCast( spObject other ) { return spSceneLodGroup( ISceneLodGroup::SafeCast( other.GetInterface() ) ); }
	inline ISceneLodGroup* spSceneLodGroup::operator->() const { return static_cast<ISceneLodGroup*>(this->ptr); }

	/// Implementations of spSceneBone methods
	inline spSceneBone::spSceneBone( ISceneBone *p ) : spSceneNode(p) {}
	inline spSceneBone::spSceneBone( const spSceneBone &p ) : spSceneNode(p) {}
	inline spSceneBone& spSceneBone::operator=( const spSceneBone &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spSceneBone spSceneBone::SafeCast( spObject other ) { return spSceneBone( ISceneBone::SafeCast( other.GetInterface() ) ); }
	inline ISceneBone* spSceneBone::operator->() const { return static_cast<ISceneBone*>(this->ptr); }

	/// Implementations of spSceneBoneTable methods
	inline spSceneBoneTable::spSceneBoneTable( ISceneBoneTable *p ) : spTable(p) {}
	inline spSceneBoneTable::spSceneBoneTable( const spSceneBoneTable &p ) : spTable(p) {}
	inline spSceneBoneTable& spSceneBoneTable::operator=( const spSceneBoneTable &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spSceneBoneTable spSceneBoneTable::SafeCast( spObject other ) { return spSceneBoneTable( ISceneBoneTable::SafeCast( other.GetInterface() ) ); }
	inline ISceneBoneTable* spSceneBoneTable::operator->() const { return static_cast<ISceneBoneTable*>(this->ptr); }

	/// Implementations of spScenePlane methods
	inline spScenePlane::spScenePlane( IScenePlane *p ) : spSceneNode(p) {}
	inline spScenePlane::spScenePlane( const spScenePlane &p ) : spSceneNode(p) {}
	inline spScenePlane& spScenePlane::operator=( const spScenePlane &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spScenePlane spScenePlane::SafeCast( spObject other ) { return spScenePlane( IScenePlane::SafeCast( other.GetInterface() ) ); }
	inline IScenePlane* spScenePlane::operator->() const { return static_cast<IScenePlane*>(this->ptr); }

	/// Implementations of spSceneCamera methods
	inline spSceneCamera::spSceneCamera( ISceneCamera *p ) : spSceneNode(p) {}
	inline spSceneCamera::spSceneCamera( const spSceneCamera &p ) : spSceneNode(p) {}
	inline spSceneCamera& spSceneCamera::operator=( const spSceneCamera &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spSceneCamera spSceneCamera::SafeCast( spObject other ) { return spSceneCamera( ISceneCamera::SafeCast( other.GetInterface() ) ); }
	inline ISceneCamera* spSceneCamera::operator->() const { return static_cast<ISceneCamera*>(this->ptr); }

	/// Implementations of spSceneExporter methods
	inline spSceneExporter::spSceneExporter( ISceneExporter *p ) : spObject(p) {}
	inline spSceneExporter::spSceneExporter( const spSceneExporter &p ) : spObject(p) {}
	inline spSceneExporter& spSceneExporter::operator=( const spSceneExporter &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spSceneExporter spSceneExporter::SafeCast( spObject other ) { return spSceneExporter( ISceneExporter::SafeCast( other.GetInterface() ) ); }
	inline ISceneExporter* spSceneExporter::operator->() const { return static_cast<ISceneExporter*>(this->ptr); }

	/// Implementations of spSceneImporter methods
	inline spSceneImporter::spSceneImporter( ISceneImporter *p ) : spObject(p) {}
	inline spSceneImporter::spSceneImporter( const spSceneImporter &p ) : spObject(p) {}
	inline spSceneImporter& spSceneImporter::operator=( const spSceneImporter &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spSceneImporter spSceneImporter::SafeCast( spObject other ) { return spSceneImporter( ISceneImporter::SafeCast( other.GetInterface() ) ); }
	inline ISceneImporter* spSceneImporter::operator->() const { return static_cast<ISceneImporter*>(this->ptr); }

	/// Implementations of spSelectionSet methods
	inline spSelectionSet::spSelectionSet( ISelectionSet *p ) : spObject(p) {}
	inline spSelectionSet::spSelectionSet( const spSelectionSet &p ) : spObject(p) {}
	inline spSelectionSet& spSelectionSet::operator=( const spSelectionSet &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spSelectionSet spSelectionSet::SafeCast( spObject other ) { return spSelectionSet( ISelectionSet::SafeCast( other.GetInterface() ) ); }
	inline ISelectionSet* spSelectionSet::operator->() const { return static_cast<ISelectionSet*>(this->ptr); }

	/// Implementations of spSelectionSetTable methods
	inline spSelectionSetTable::spSelectionSetTable( ISelectionSetTable *p ) : spTable(p) {}
	inline spSelectionSetTable::spSelectionSetTable( const spSelectionSetTable &p ) : spTable(p) {}
	inline spSelectionSetTable& spSelectionSetTable::operator=( const spSelectionSetTable &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spSelectionSetTable spSelectionSetTable::SafeCast( spObject other ) { return spSelectionSetTable( ISelectionSetTable::SafeCast( other.GetInterface() ) ); }
	inline ISelectionSetTable* spSelectionSetTable::operator->() const { return static_cast<ISelectionSetTable*>(this->ptr); }

	/// Implementations of spTexture methods
	inline spTexture::spTexture( ITexture *p ) : spObject(p) {}
	inline spTexture::spTexture( const spTexture &p ) : spObject(p) {}
	inline spTexture& spTexture::operator=( const spTexture &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spTexture spTexture::SafeCast( spObject other ) { return spTexture( ITexture::SafeCast( other.GetInterface() ) ); }
	inline ITexture* spTexture::operator->() const { return static_cast<ITexture*>(this->ptr); }

	/// Implementations of spTextureTable methods
	inline spTextureTable::spTextureTable( ITextureTable *p ) : spTable(p) {}
	inline spTextureTable::spTextureTable( const spTextureTable &p ) : spTable(p) {}
	inline spTextureTable& spTextureTable::operator=( const spTextureTable &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spTextureTable spTextureTable::SafeCast( spObject other ) { return spTextureTable( ITextureTable::SafeCast( other.GetInterface() ) ); }
	inline ITextureTable* spTextureTable::operator->() const { return static_cast<ITextureTable*>(this->ptr); }

	/// Implementations of spGeometryCullingSettings methods
	inline spGeometryCullingSettings::spGeometryCullingSettings( IGeometryCullingSettings *p ) : spSettingsObject(p) {}
	inline spGeometryCullingSettings::spGeometryCullingSettings( const spGeometryCullingSettings &p ) : spSettingsObject(p) {}
	inline spGeometryCullingSettings& spGeometryCullingSettings::operator=( const spGeometryCullingSettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spGeometryCullingSettings spGeometryCullingSettings::SafeCast( spObject other ) { return spGeometryCullingSettings( IGeometryCullingSettings::SafeCast( other.GetInterface() ) ); }
	inline IGeometryCullingSettings* spGeometryCullingSettings::operator->() const { return static_cast<IGeometryCullingSettings*>(this->ptr); }

	/// Implementations of spImageDataImporter methods
	inline spImageDataImporter::spImageDataImporter( IImageDataImporter *p ) : spObject(p) {}
	inline spImageDataImporter::spImageDataImporter( const spImageDataImporter &p ) : spObject(p) {}
	inline spImageDataImporter& spImageDataImporter::operator=( const spImageDataImporter &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spImageDataImporter spImageDataImporter::SafeCast( spObject other ) { return spImageDataImporter( IImageDataImporter::SafeCast( other.GetInterface() ) ); }
	inline IImageDataImporter* spImageDataImporter::operator->() const { return static_cast<IImageDataImporter*>(this->ptr); }

	/// Implementations of spMappingImageMeshData methods
	inline spMappingImageMeshData::spMappingImageMeshData( IMappingImageMeshData *p ) : spObject(p) {}
	inline spMappingImageMeshData::spMappingImageMeshData( const spMappingImageMeshData &p ) : spObject(p) {}
	inline spMappingImageMeshData& spMappingImageMeshData::operator=( const spMappingImageMeshData &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spMappingImageMeshData spMappingImageMeshData::SafeCast( spObject other ) { return spMappingImageMeshData( IMappingImageMeshData::SafeCast( other.GetInterface() ) ); }
	inline IMappingImageMeshData* spMappingImageMeshData::operator->() const { return static_cast<IMappingImageMeshData*>(this->ptr); }

	/// Implementations of spShadingNode methods
	inline spShadingNode::spShadingNode( IShadingNode *p ) : spObject(p) {}
	inline spShadingNode::spShadingNode( const spShadingNode &p ) : spObject(p) {}
	inline spShadingNode& spShadingNode::operator=( const spShadingNode &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShadingNode spShadingNode::SafeCast( spObject other ) { return spShadingNode( IShadingNode::SafeCast( other.GetInterface() ) ); }
	inline IShadingNode* spShadingNode::operator->() const { return static_cast<IShadingNode*>(this->ptr); }

	/// Implementations of spShadingFilterNode methods
	inline spShadingFilterNode::spShadingFilterNode( IShadingFilterNode *p ) : spShadingNode(p) {}
	inline spShadingFilterNode::spShadingFilterNode( const spShadingFilterNode &p ) : spShadingNode(p) {}
	inline spShadingFilterNode& spShadingFilterNode::operator=( const spShadingFilterNode &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShadingFilterNode spShadingFilterNode::SafeCast( spObject other ) { return spShadingFilterNode( IShadingFilterNode::SafeCast( other.GetInterface() ) ); }
	inline IShadingFilterNode* spShadingFilterNode::operator->() const { return static_cast<IShadingFilterNode*>(this->ptr); }

	/// Implementations of spShadingTextureNode methods
	inline spShadingTextureNode::spShadingTextureNode( IShadingTextureNode *p ) : spShadingNode(p) {}
	inline spShadingTextureNode::spShadingTextureNode( const spShadingTextureNode &p ) : spShadingNode(p) {}
	inline spShadingTextureNode& spShadingTextureNode::operator=( const spShadingTextureNode &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShadingTextureNode spShadingTextureNode::SafeCast( spObject other ) { return spShadingTextureNode( IShadingTextureNode::SafeCast( other.GetInterface() ) ); }
	inline IShadingTextureNode* spShadingTextureNode::operator->() const { return static_cast<IShadingTextureNode*>(this->ptr); }

	/// Implementations of spShadingSwizzlingNode methods
	inline spShadingSwizzlingNode::spShadingSwizzlingNode( IShadingSwizzlingNode *p ) : spShadingFilterNode(p) {}
	inline spShadingSwizzlingNode::spShadingSwizzlingNode( const spShadingSwizzlingNode &p ) : spShadingFilterNode(p) {}
	inline spShadingSwizzlingNode& spShadingSwizzlingNode::operator=( const spShadingSwizzlingNode &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShadingSwizzlingNode spShadingSwizzlingNode::SafeCast( spObject other ) { return spShadingSwizzlingNode( IShadingSwizzlingNode::SafeCast( other.GetInterface() ) ); }
	inline IShadingSwizzlingNode* spShadingSwizzlingNode::operator->() const { return static_cast<IShadingSwizzlingNode*>(this->ptr); }

	/// Implementations of spShadingColorNode methods
	inline spShadingColorNode::spShadingColorNode( IShadingColorNode *p ) : spShadingNode(p) {}
	inline spShadingColorNode::spShadingColorNode( const spShadingColorNode &p ) : spShadingNode(p) {}
	inline spShadingColorNode& spShadingColorNode::operator=( const spShadingColorNode &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShadingColorNode spShadingColorNode::SafeCast( spObject other ) { return spShadingColorNode( IShadingColorNode::SafeCast( other.GetInterface() ) ); }
	inline IShadingColorNode* spShadingColorNode::operator->() const { return static_cast<IShadingColorNode*>(this->ptr); }

	/// Implementations of spShadingAddNode methods
	inline spShadingAddNode::spShadingAddNode( IShadingAddNode *p ) : spShadingFilterNode(p) {}
	inline spShadingAddNode::spShadingAddNode( const spShadingAddNode &p ) : spShadingFilterNode(p) {}
	inline spShadingAddNode& spShadingAddNode::operator=( const spShadingAddNode &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShadingAddNode spShadingAddNode::SafeCast( spObject other ) { return spShadingAddNode( IShadingAddNode::SafeCast( other.GetInterface() ) ); }
	inline IShadingAddNode* spShadingAddNode::operator->() const { return static_cast<IShadingAddNode*>(this->ptr); }

	/// Implementations of spShadingSubtractNode methods
	inline spShadingSubtractNode::spShadingSubtractNode( IShadingSubtractNode *p ) : spShadingFilterNode(p) {}
	inline spShadingSubtractNode::spShadingSubtractNode( const spShadingSubtractNode &p ) : spShadingFilterNode(p) {}
	inline spShadingSubtractNode& spShadingSubtractNode::operator=( const spShadingSubtractNode &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShadingSubtractNode spShadingSubtractNode::SafeCast( spObject other ) { return spShadingSubtractNode( IShadingSubtractNode::SafeCast( other.GetInterface() ) ); }
	inline IShadingSubtractNode* spShadingSubtractNode::operator->() const { return static_cast<IShadingSubtractNode*>(this->ptr); }

	/// Implementations of spShadingMultiplyNode methods
	inline spShadingMultiplyNode::spShadingMultiplyNode( IShadingMultiplyNode *p ) : spShadingFilterNode(p) {}
	inline spShadingMultiplyNode::spShadingMultiplyNode( const spShadingMultiplyNode &p ) : spShadingFilterNode(p) {}
	inline spShadingMultiplyNode& spShadingMultiplyNode::operator=( const spShadingMultiplyNode &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShadingMultiplyNode spShadingMultiplyNode::SafeCast( spObject other ) { return spShadingMultiplyNode( IShadingMultiplyNode::SafeCast( other.GetInterface() ) ); }
	inline IShadingMultiplyNode* spShadingMultiplyNode::operator->() const { return static_cast<IShadingMultiplyNode*>(this->ptr); }

	/// Implementations of spShadingPowNode methods
	inline spShadingPowNode::spShadingPowNode( IShadingPowNode *p ) : spShadingFilterNode(p) {}
	inline spShadingPowNode::spShadingPowNode( const spShadingPowNode &p ) : spShadingFilterNode(p) {}
	inline spShadingPowNode& spShadingPowNode::operator=( const spShadingPowNode &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShadingPowNode spShadingPowNode::SafeCast( spObject other ) { return spShadingPowNode( IShadingPowNode::SafeCast( other.GetInterface() ) ); }
	inline IShadingPowNode* spShadingPowNode::operator->() const { return static_cast<IShadingPowNode*>(this->ptr); }

	/// Implementations of spShadingDivideNode methods
	inline spShadingDivideNode::spShadingDivideNode( IShadingDivideNode *p ) : spShadingFilterNode(p) {}
	inline spShadingDivideNode::spShadingDivideNode( const spShadingDivideNode &p ) : spShadingFilterNode(p) {}
	inline spShadingDivideNode& spShadingDivideNode::operator=( const spShadingDivideNode &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShadingDivideNode spShadingDivideNode::SafeCast( spObject other ) { return spShadingDivideNode( IShadingDivideNode::SafeCast( other.GetInterface() ) ); }
	inline IShadingDivideNode* spShadingDivideNode::operator->() const { return static_cast<IShadingDivideNode*>(this->ptr); }

	/// Implementations of spShadingClampNode methods
	inline spShadingClampNode::spShadingClampNode( IShadingClampNode *p ) : spShadingFilterNode(p) {}
	inline spShadingClampNode::spShadingClampNode( const spShadingClampNode &p ) : spShadingFilterNode(p) {}
	inline spShadingClampNode& spShadingClampNode::operator=( const spShadingClampNode &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShadingClampNode spShadingClampNode::SafeCast( spObject other ) { return spShadingClampNode( IShadingClampNode::SafeCast( other.GetInterface() ) ); }
	inline IShadingClampNode* spShadingClampNode::operator->() const { return static_cast<IShadingClampNode*>(this->ptr); }

	/// Implementations of spShadingMaxNode methods
	inline spShadingMaxNode::spShadingMaxNode( IShadingMaxNode *p ) : spShadingFilterNode(p) {}
	inline spShadingMaxNode::spShadingMaxNode( const spShadingMaxNode &p ) : spShadingFilterNode(p) {}
	inline spShadingMaxNode& spShadingMaxNode::operator=( const spShadingMaxNode &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShadingMaxNode spShadingMaxNode::SafeCast( spObject other ) { return spShadingMaxNode( IShadingMaxNode::SafeCast( other.GetInterface() ) ); }
	inline IShadingMaxNode* spShadingMaxNode::operator->() const { return static_cast<IShadingMaxNode*>(this->ptr); }

	/// Implementations of spShadingMinNode methods
	inline spShadingMinNode::spShadingMinNode( IShadingMinNode *p ) : spShadingFilterNode(p) {}
	inline spShadingMinNode::spShadingMinNode( const spShadingMinNode &p ) : spShadingFilterNode(p) {}
	inline spShadingMinNode& spShadingMinNode::operator=( const spShadingMinNode &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShadingMinNode spShadingMinNode::SafeCast( spObject other ) { return spShadingMinNode( IShadingMinNode::SafeCast( other.GetInterface() ) ); }
	inline IShadingMinNode* spShadingMinNode::operator->() const { return static_cast<IShadingMinNode*>(this->ptr); }

	/// Implementations of spShadingStepNode methods
	inline spShadingStepNode::spShadingStepNode( IShadingStepNode *p ) : spShadingFilterNode(p) {}
	inline spShadingStepNode::spShadingStepNode( const spShadingStepNode &p ) : spShadingFilterNode(p) {}
	inline spShadingStepNode& spShadingStepNode::operator=( const spShadingStepNode &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShadingStepNode spShadingStepNode::SafeCast( spObject other ) { return spShadingStepNode( IShadingStepNode::SafeCast( other.GetInterface() ) ); }
	inline IShadingStepNode* spShadingStepNode::operator->() const { return static_cast<IShadingStepNode*>(this->ptr); }

	/// Implementations of spShadingEqualNode methods
	inline spShadingEqualNode::spShadingEqualNode( IShadingEqualNode *p ) : spShadingFilterNode(p) {}
	inline spShadingEqualNode::spShadingEqualNode( const spShadingEqualNode &p ) : spShadingFilterNode(p) {}
	inline spShadingEqualNode& spShadingEqualNode::operator=( const spShadingEqualNode &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShadingEqualNode spShadingEqualNode::SafeCast( spObject other ) { return spShadingEqualNode( IShadingEqualNode::SafeCast( other.GetInterface() ) ); }
	inline IShadingEqualNode* spShadingEqualNode::operator->() const { return static_cast<IShadingEqualNode*>(this->ptr); }

	/// Implementations of spShadingNotEqualNode methods
	inline spShadingNotEqualNode::spShadingNotEqualNode( IShadingNotEqualNode *p ) : spShadingFilterNode(p) {}
	inline spShadingNotEqualNode::spShadingNotEqualNode( const spShadingNotEqualNode &p ) : spShadingFilterNode(p) {}
	inline spShadingNotEqualNode& spShadingNotEqualNode::operator=( const spShadingNotEqualNode &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShadingNotEqualNode spShadingNotEqualNode::SafeCast( spObject other ) { return spShadingNotEqualNode( IShadingNotEqualNode::SafeCast( other.GetInterface() ) ); }
	inline IShadingNotEqualNode* spShadingNotEqualNode::operator->() const { return static_cast<IShadingNotEqualNode*>(this->ptr); }

	/// Implementations of spShadingVertexColorNode methods
	inline spShadingVertexColorNode::spShadingVertexColorNode( IShadingVertexColorNode *p ) : spShadingNode(p) {}
	inline spShadingVertexColorNode::spShadingVertexColorNode( const spShadingVertexColorNode &p ) : spShadingNode(p) {}
	inline spShadingVertexColorNode& spShadingVertexColorNode::operator=( const spShadingVertexColorNode &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShadingVertexColorNode spShadingVertexColorNode::SafeCast( spObject other ) { return spShadingVertexColorNode( IShadingVertexColorNode::SafeCast( other.GetInterface() ) ); }
	inline IShadingVertexColorNode* spShadingVertexColorNode::operator->() const { return static_cast<IShadingVertexColorNode*>(this->ptr); }

	/// Implementations of spShadingInterpolateNode methods
	inline spShadingInterpolateNode::spShadingInterpolateNode( IShadingInterpolateNode *p ) : spShadingFilterNode(p) {}
	inline spShadingInterpolateNode::spShadingInterpolateNode( const spShadingInterpolateNode &p ) : spShadingFilterNode(p) {}
	inline spShadingInterpolateNode& spShadingInterpolateNode::operator=( const spShadingInterpolateNode &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShadingInterpolateNode spShadingInterpolateNode::SafeCast( spObject other ) { return spShadingInterpolateNode( IShadingInterpolateNode::SafeCast( other.GetInterface() ) ); }
	inline IShadingInterpolateNode* spShadingInterpolateNode::operator->() const { return static_cast<IShadingInterpolateNode*>(this->ptr); }

	/// Implementations of spShadingCustomNode methods
	inline spShadingCustomNode::spShadingCustomNode( IShadingCustomNode *p ) : spShadingFilterNode(p) {}
	inline spShadingCustomNode::spShadingCustomNode( const spShadingCustomNode &p ) : spShadingFilterNode(p) {}
	inline spShadingCustomNode& spShadingCustomNode::operator=( const spShadingCustomNode &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShadingCustomNode spShadingCustomNode::SafeCast( spObject other ) { return spShadingCustomNode( IShadingCustomNode::SafeCast( other.GetInterface() ) ); }
	inline IShadingCustomNode* spShadingCustomNode::operator->() const { return static_cast<IShadingCustomNode*>(this->ptr); }

	/// Implementations of spShadingLayeredBlendNode methods
	inline spShadingLayeredBlendNode::spShadingLayeredBlendNode( IShadingLayeredBlendNode *p ) : spShadingFilterNode(p) {}
	inline spShadingLayeredBlendNode::spShadingLayeredBlendNode( const spShadingLayeredBlendNode &p ) : spShadingFilterNode(p) {}
	inline spShadingLayeredBlendNode& spShadingLayeredBlendNode::operator=( const spShadingLayeredBlendNode &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShadingLayeredBlendNode spShadingLayeredBlendNode::SafeCast( spObject other ) { return spShadingLayeredBlendNode( IShadingLayeredBlendNode::SafeCast( other.GetInterface() ) ); }
	inline IShadingLayeredBlendNode* spShadingLayeredBlendNode::operator->() const { return static_cast<IShadingLayeredBlendNode*>(this->ptr); }

	/// Implementations of spShadingNormalize3Node methods
	inline spShadingNormalize3Node::spShadingNormalize3Node( IShadingNormalize3Node *p ) : spShadingFilterNode(p) {}
	inline spShadingNormalize3Node::spShadingNormalize3Node( const spShadingNormalize3Node &p ) : spShadingFilterNode(p) {}
	inline spShadingNormalize3Node& spShadingNormalize3Node::operator=( const spShadingNormalize3Node &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShadingNormalize3Node spShadingNormalize3Node::SafeCast( spObject other ) { return spShadingNormalize3Node( IShadingNormalize3Node::SafeCast( other.GetInterface() ) ); }
	inline IShadingNormalize3Node* spShadingNormalize3Node::operator->() const { return static_cast<IShadingNormalize3Node*>(this->ptr); }

	/// Implementations of spShadingSqrtNode methods
	inline spShadingSqrtNode::spShadingSqrtNode( IShadingSqrtNode *p ) : spShadingFilterNode(p) {}
	inline spShadingSqrtNode::spShadingSqrtNode( const spShadingSqrtNode &p ) : spShadingFilterNode(p) {}
	inline spShadingSqrtNode& spShadingSqrtNode::operator=( const spShadingSqrtNode &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShadingSqrtNode spShadingSqrtNode::SafeCast( spObject other ) { return spShadingSqrtNode( IShadingSqrtNode::SafeCast( other.GetInterface() ) ); }
	inline IShadingSqrtNode* spShadingSqrtNode::operator->() const { return static_cast<IShadingSqrtNode*>(this->ptr); }

	/// Implementations of spShadingDot3Node methods
	inline spShadingDot3Node::spShadingDot3Node( IShadingDot3Node *p ) : spShadingFilterNode(p) {}
	inline spShadingDot3Node::spShadingDot3Node( const spShadingDot3Node &p ) : spShadingFilterNode(p) {}
	inline spShadingDot3Node& spShadingDot3Node::operator=( const spShadingDot3Node &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShadingDot3Node spShadingDot3Node::SafeCast( spObject other ) { return spShadingDot3Node( IShadingDot3Node::SafeCast( other.GetInterface() ) ); }
	inline IShadingDot3Node* spShadingDot3Node::operator->() const { return static_cast<IShadingDot3Node*>(this->ptr); }

	/// Implementations of spShadingCross3Node methods
	inline spShadingCross3Node::spShadingCross3Node( IShadingCross3Node *p ) : spShadingFilterNode(p) {}
	inline spShadingCross3Node::spShadingCross3Node( const spShadingCross3Node &p ) : spShadingFilterNode(p) {}
	inline spShadingCross3Node& spShadingCross3Node::operator=( const spShadingCross3Node &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShadingCross3Node spShadingCross3Node::SafeCast( spObject other ) { return spShadingCross3Node( IShadingCross3Node::SafeCast( other.GetInterface() ) ); }
	inline IShadingCross3Node* spShadingCross3Node::operator->() const { return static_cast<IShadingCross3Node*>(this->ptr); }

	/// Implementations of spShadingCosNode methods
	inline spShadingCosNode::spShadingCosNode( IShadingCosNode *p ) : spShadingFilterNode(p) {}
	inline spShadingCosNode::spShadingCosNode( const spShadingCosNode &p ) : spShadingFilterNode(p) {}
	inline spShadingCosNode& spShadingCosNode::operator=( const spShadingCosNode &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShadingCosNode spShadingCosNode::SafeCast( spObject other ) { return spShadingCosNode( IShadingCosNode::SafeCast( other.GetInterface() ) ); }
	inline IShadingCosNode* spShadingCosNode::operator->() const { return static_cast<IShadingCosNode*>(this->ptr); }

	/// Implementations of spShadingSinNode methods
	inline spShadingSinNode::spShadingSinNode( IShadingSinNode *p ) : spShadingFilterNode(p) {}
	inline spShadingSinNode::spShadingSinNode( const spShadingSinNode &p ) : spShadingFilterNode(p) {}
	inline spShadingSinNode& spShadingSinNode::operator=( const spShadingSinNode &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShadingSinNode spShadingSinNode::SafeCast( spObject other ) { return spShadingSinNode( IShadingSinNode::SafeCast( other.GetInterface() ) ); }
	inline IShadingSinNode* spShadingSinNode::operator->() const { return static_cast<IShadingSinNode*>(this->ptr); }

	/// Implementations of spShadingGreaterThanNode methods
	inline spShadingGreaterThanNode::spShadingGreaterThanNode( IShadingGreaterThanNode *p ) : spShadingFilterNode(p) {}
	inline spShadingGreaterThanNode::spShadingGreaterThanNode( const spShadingGreaterThanNode &p ) : spShadingFilterNode(p) {}
	inline spShadingGreaterThanNode& spShadingGreaterThanNode::operator=( const spShadingGreaterThanNode &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShadingGreaterThanNode spShadingGreaterThanNode::SafeCast( spObject other ) { return spShadingGreaterThanNode( IShadingGreaterThanNode::SafeCast( other.GetInterface() ) ); }
	inline IShadingGreaterThanNode* spShadingGreaterThanNode::operator->() const { return static_cast<IShadingGreaterThanNode*>(this->ptr); }

	/// Implementations of spShadingLessThanNode methods
	inline spShadingLessThanNode::spShadingLessThanNode( IShadingLessThanNode *p ) : spShadingFilterNode(p) {}
	inline spShadingLessThanNode::spShadingLessThanNode( const spShadingLessThanNode &p ) : spShadingFilterNode(p) {}
	inline spShadingLessThanNode& spShadingLessThanNode::operator=( const spShadingLessThanNode &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShadingLessThanNode spShadingLessThanNode::SafeCast( spObject other ) { return spShadingLessThanNode( IShadingLessThanNode::SafeCast( other.GetInterface() ) ); }
	inline IShadingLessThanNode* spShadingLessThanNode::operator->() const { return static_cast<IShadingLessThanNode*>(this->ptr); }

	/// Implementations of spShadingGeometryFieldNode methods
	inline spShadingGeometryFieldNode::spShadingGeometryFieldNode( IShadingGeometryFieldNode *p ) : spShadingNode(p) {}
	inline spShadingGeometryFieldNode::spShadingGeometryFieldNode( const spShadingGeometryFieldNode &p ) : spShadingNode(p) {}
	inline spShadingGeometryFieldNode& spShadingGeometryFieldNode::operator=( const spShadingGeometryFieldNode &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShadingGeometryFieldNode spShadingGeometryFieldNode::SafeCast( spObject other ) { return spShadingGeometryFieldNode( IShadingGeometryFieldNode::SafeCast( other.GetInterface() ) ); }
	inline IShadingGeometryFieldNode* spShadingGeometryFieldNode::operator->() const { return static_cast<IShadingGeometryFieldNode*>(this->ptr); }

	/// Implementations of spShaderGenerator methods
	inline spShaderGenerator::spShaderGenerator( IShaderGenerator *p ) : spObject(p) {}
	inline spShaderGenerator::spShaderGenerator( const spShaderGenerator &p ) : spObject(p) {}
	inline spShaderGenerator& spShaderGenerator::operator=( const spShaderGenerator &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spShaderGenerator spShaderGenerator::SafeCast( spObject other ) { return spShaderGenerator( IShaderGenerator::SafeCast( other.GetInterface() ) ); }
	inline IShaderGenerator* spShaderGenerator::operator->() const { return static_cast<IShaderGenerator*>(this->ptr); }

	/// Implementations of spAggregationProcessor methods
	inline spAggregationProcessor::spAggregationProcessor( IAggregationProcessor *p ) : spProcessingObject(p) {}
	inline spAggregationProcessor::spAggregationProcessor( const spAggregationProcessor &p ) : spProcessingObject(p) {}
	inline spAggregationProcessor& spAggregationProcessor::operator=( const spAggregationProcessor &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spAggregationProcessor spAggregationProcessor::SafeCast( spObject other ) { return spAggregationProcessor( IAggregationProcessor::SafeCast( other.GetInterface() ) ); }
	inline IAggregationProcessor* spAggregationProcessor::operator->() const { return static_cast<IAggregationProcessor*>(this->ptr); }

	/// Implementations of spAggregationSettings methods
	inline spAggregationSettings::spAggregationSettings( IAggregationSettings *p ) : spSettingsObject(p) {}
	inline spAggregationSettings::spAggregationSettings( const spAggregationSettings &p ) : spSettingsObject(p) {}
	inline spAggregationSettings& spAggregationSettings::operator=( const spAggregationSettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spAggregationSettings spAggregationSettings::SafeCast( spObject other ) { return spAggregationSettings( IAggregationSettings::SafeCast( other.GetInterface() ) ); }
	inline IAggregationSettings* spAggregationSettings::operator->() const { return static_cast<IAggregationSettings*>(this->ptr); }

	/// Implementations of spChartAggregator methods
	inline spChartAggregator::spChartAggregator( IChartAggregator *p ) : spObject(p) {}
	inline spChartAggregator::spChartAggregator( const spChartAggregator &p ) : spObject(p) {}
	inline spChartAggregator& spChartAggregator::operator=( const spChartAggregator &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spChartAggregator spChartAggregator::SafeCast( spObject other ) { return spChartAggregator( IChartAggregator::SafeCast( other.GetInterface() ) ); }
	inline IChartAggregator* spChartAggregator::operator->() const { return static_cast<IChartAggregator*>(this->ptr); }

	/// Implementations of spVertexColorCasterSettings methods
	inline spVertexColorCasterSettings::spVertexColorCasterSettings( IVertexColorCasterSettings *p ) : spMaterialCasterSettings(p) {}
	inline spVertexColorCasterSettings::spVertexColorCasterSettings( const spVertexColorCasterSettings &p ) : spMaterialCasterSettings(p) {}
	inline spVertexColorCasterSettings& spVertexColorCasterSettings::operator=( const spVertexColorCasterSettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spVertexColorCasterSettings spVertexColorCasterSettings::SafeCast( spObject other ) { return spVertexColorCasterSettings( IVertexColorCasterSettings::SafeCast( other.GetInterface() ) ); }
	inline IVertexColorCasterSettings* spVertexColorCasterSettings::operator->() const { return static_cast<IVertexColorCasterSettings*>(this->ptr); }

	/// Implementations of spVertexColorCaster methods
	inline spVertexColorCaster::spVertexColorCaster( IVertexColorCaster *p ) : spMaterialCaster(p) {}
	inline spVertexColorCaster::spVertexColorCaster( const spVertexColorCaster &p ) : spMaterialCaster(p) {}
	inline spVertexColorCaster& spVertexColorCaster::operator=( const spVertexColorCaster &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spVertexColorCaster spVertexColorCaster::SafeCast( spObject other ) { return spVertexColorCaster( IVertexColorCaster::SafeCast( other.GetInterface() ) ); }
	inline IVertexColorCaster* spVertexColorCaster::operator->() const { return static_cast<IVertexColorCaster*>(this->ptr); }

	/// Implementations of spImageDataExporter methods
	inline spImageDataExporter::spImageDataExporter( IImageDataExporter *p ) : spObject(p) {}
	inline spImageDataExporter::spImageDataExporter( const spImageDataExporter &p ) : spObject(p) {}
	inline spImageDataExporter& spImageDataExporter::operator=( const spImageDataExporter &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spImageDataExporter spImageDataExporter::SafeCast( spObject other ) { return spImageDataExporter( IImageDataExporter::SafeCast( other.GetInterface() ) ); }
	inline IImageDataExporter* spImageDataExporter::operator->() const { return static_cast<IImageDataExporter*>(this->ptr); }

	/// Implementations of spAmbientOcclusionCaster methods
	inline spAmbientOcclusionCaster::spAmbientOcclusionCaster( IAmbientOcclusionCaster *p ) : spMaterialCaster(p) {}
	inline spAmbientOcclusionCaster::spAmbientOcclusionCaster( const spAmbientOcclusionCaster &p ) : spMaterialCaster(p) {}
	inline spAmbientOcclusionCaster& spAmbientOcclusionCaster::operator=( const spAmbientOcclusionCaster &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spAmbientOcclusionCaster spAmbientOcclusionCaster::SafeCast( spObject other ) { return spAmbientOcclusionCaster( IAmbientOcclusionCaster::SafeCast( other.GetInterface() ) ); }
	inline IAmbientOcclusionCaster* spAmbientOcclusionCaster::operator->() const { return static_cast<IAmbientOcclusionCaster*>(this->ptr); }

	/// Implementations of spAmbientOcclusionCasterSettings methods
	inline spAmbientOcclusionCasterSettings::spAmbientOcclusionCasterSettings( IAmbientOcclusionCasterSettings *p ) : spMaterialCasterSettings(p) {}
	inline spAmbientOcclusionCasterSettings::spAmbientOcclusionCasterSettings( const spAmbientOcclusionCasterSettings &p ) : spMaterialCasterSettings(p) {}
	inline spAmbientOcclusionCasterSettings& spAmbientOcclusionCasterSettings::operator=( const spAmbientOcclusionCasterSettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spAmbientOcclusionCasterSettings spAmbientOcclusionCasterSettings::SafeCast( spObject other ) { return spAmbientOcclusionCasterSettings( IAmbientOcclusionCasterSettings::SafeCast( other.GetInterface() ) ); }
	inline IAmbientOcclusionCasterSettings* spAmbientOcclusionCasterSettings::operator->() const { return static_cast<IAmbientOcclusionCasterSettings*>(this->ptr); }

	/// Implementations of spImpostorProcessor methods
	inline spImpostorProcessor::spImpostorProcessor( IImpostorProcessor *p ) : spProcessingObject(p) {}
	inline spImpostorProcessor::spImpostorProcessor( const spImpostorProcessor &p ) : spProcessingObject(p) {}
	inline spImpostorProcessor& spImpostorProcessor::operator=( const spImpostorProcessor &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spImpostorProcessor spImpostorProcessor::SafeCast( spObject other ) { return spImpostorProcessor( IImpostorProcessor::SafeCast( other.GetInterface() ) ); }
	inline IImpostorProcessor* spImpostorProcessor::operator->() const { return static_cast<IImpostorProcessor*>(this->ptr); }

	/// Implementations of spImpostorSettings methods
	inline spImpostorSettings::spImpostorSettings( IImpostorSettings *p ) : spSettingsObject(p) {}
	inline spImpostorSettings::spImpostorSettings( const spImpostorSettings &p ) : spSettingsObject(p) {}
	inline spImpostorSettings& spImpostorSettings::operator=( const spImpostorSettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spImpostorSettings spImpostorSettings::SafeCast( spObject other ) { return spImpostorSettings( IImpostorSettings::SafeCast( other.GetInterface() ) ); }
	inline IImpostorSettings* spImpostorSettings::operator->() const { return static_cast<IImpostorSettings*>(this->ptr); }

	/// Implementations of spSurfaceMapper methods
	inline spSurfaceMapper::spSurfaceMapper( ISurfaceMapper *p ) : spObject(p) {}
	inline spSurfaceMapper::spSurfaceMapper( const spSurfaceMapper &p ) : spObject(p) {}
	inline spSurfaceMapper& spSurfaceMapper::operator=( const spSurfaceMapper &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spSurfaceMapper spSurfaceMapper::SafeCast( spObject other ) { return spSurfaceMapper( ISurfaceMapper::SafeCast( other.GetInterface() ) ); }
	inline ISurfaceMapper* spSurfaceMapper::operator->() const { return static_cast<ISurfaceMapper*>(this->ptr); }

	/// Implementations of spOcclusionMeshProcessor methods
	inline spOcclusionMeshProcessor::spOcclusionMeshProcessor( IOcclusionMeshProcessor *p ) : spProcessingObject(p) {}
	inline spOcclusionMeshProcessor::spOcclusionMeshProcessor( const spOcclusionMeshProcessor &p ) : spProcessingObject(p) {}
	inline spOcclusionMeshProcessor& spOcclusionMeshProcessor::operator=( const spOcclusionMeshProcessor &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spOcclusionMeshProcessor spOcclusionMeshProcessor::SafeCast( spObject other ) { return spOcclusionMeshProcessor( IOcclusionMeshProcessor::SafeCast( other.GetInterface() ) ); }
	inline IOcclusionMeshProcessor* spOcclusionMeshProcessor::operator->() const { return static_cast<IOcclusionMeshProcessor*>(this->ptr); }

	/// Implementations of spOcclusionMeshSettings methods
	inline spOcclusionMeshSettings::spOcclusionMeshSettings( IOcclusionMeshSettings *p ) : spSettingsObject(p) {}
	inline spOcclusionMeshSettings::spOcclusionMeshSettings( const spOcclusionMeshSettings &p ) : spSettingsObject(p) {}
	inline spOcclusionMeshSettings& spOcclusionMeshSettings::operator=( const spOcclusionMeshSettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spOcclusionMeshSettings spOcclusionMeshSettings::SafeCast( spObject other ) { return spOcclusionMeshSettings( IOcclusionMeshSettings::SafeCast( other.GetInterface() ) ); }
	inline IOcclusionMeshSettings* spOcclusionMeshSettings::operator->() const { return static_cast<IOcclusionMeshSettings*>(this->ptr); }

	/// Implementations of spImageComparer methods
	inline spImageComparer::spImageComparer( IImageComparer *p ) : spObject(p) {}
	inline spImageComparer::spImageComparer( const spImageComparer &p ) : spObject(p) {}
	inline spImageComparer& spImageComparer::operator=( const spImageComparer &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spImageComparer spImageComparer::SafeCast( spObject other ) { return spImageComparer( IImageComparer::SafeCast( other.GetInterface() ) ); }
	inline IImageComparer* spImageComparer::operator->() const { return static_cast<IImageComparer*>(this->ptr); }

	/// Implementations of spRecommendedTextureSizeCalculator methods
	inline spRecommendedTextureSizeCalculator::spRecommendedTextureSizeCalculator( IRecommendedTextureSizeCalculator *p ) : spObject(p) {}
	inline spRecommendedTextureSizeCalculator::spRecommendedTextureSizeCalculator( const spRecommendedTextureSizeCalculator &p ) : spObject(p) {}
	inline spRecommendedTextureSizeCalculator& spRecommendedTextureSizeCalculator::operator=( const spRecommendedTextureSizeCalculator &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spRecommendedTextureSizeCalculator spRecommendedTextureSizeCalculator::SafeCast( spObject other ) { return spRecommendedTextureSizeCalculator( IRecommendedTextureSizeCalculator::SafeCast( other.GetInterface() ) ); }
	inline IRecommendedTextureSizeCalculator* spRecommendedTextureSizeCalculator::operator->() const { return static_cast<IRecommendedTextureSizeCalculator*>(this->ptr); }

	/// Implementations of spPartRemover methods
	inline spPartRemover::spPartRemover( IPartRemover *p ) : spObject(p) {}
	inline spPartRemover::spPartRemover( const spPartRemover &p ) : spObject(p) {}
	inline spPartRemover& spPartRemover::operator=( const spPartRemover &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spPartRemover spPartRemover::SafeCast( spObject other ) { return spPartRemover( IPartRemover::SafeCast( other.GetInterface() ) ); }
	inline IPartRemover* spPartRemover::operator->() const { return static_cast<IPartRemover*>(this->ptr); }

	/// Implementations of spWelder methods
	inline spWelder::spWelder( IWelder *p ) : spProcessingObject(p) {}
	inline spWelder::spWelder( const spWelder &p ) : spProcessingObject(p) {}
	inline spWelder& spWelder::operator=( const spWelder &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spWelder spWelder::SafeCast( spObject other ) { return spWelder( IWelder::SafeCast( other.GetInterface() ) ); }
	inline IWelder* spWelder::operator->() const { return static_cast<IWelder*>(this->ptr); }

	/// Implementations of spTJunctionEliminator methods
	inline spTJunctionEliminator::spTJunctionEliminator( ITJunctionEliminator *p ) : spObject(p) {}
	inline spTJunctionEliminator::spTJunctionEliminator( const spTJunctionEliminator &p ) : spObject(p) {}
	inline spTJunctionEliminator& spTJunctionEliminator::operator=( const spTJunctionEliminator &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spTJunctionEliminator spTJunctionEliminator::SafeCast( spObject other ) { return spTJunctionEliminator( ITJunctionEliminator::SafeCast( other.GetInterface() ) ); }
	inline ITJunctionEliminator* spTJunctionEliminator::operator->() const { return static_cast<ITJunctionEliminator*>(this->ptr); }

	/// Implementations of spPipeline methods
	inline spPipeline::spPipeline( IPipeline *p ) : spObject(p) {}
	inline spPipeline::spPipeline( const spPipeline &p ) : spObject(p) {}
	inline spPipeline& spPipeline::operator=( const spPipeline &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spPipeline spPipeline::SafeCast( spObject other ) { return spPipeline( IPipeline::SafeCast( other.GetInterface() ) ); }
	inline IPipeline* spPipeline::operator->() const { return static_cast<IPipeline*>(this->ptr); }

	/// Implementations of spPipelineBatch methods
	inline spPipelineBatch::spPipelineBatch( IPipelineBatch *p ) : spObject(p) {}
	inline spPipelineBatch::spPipelineBatch( const spPipelineBatch &p ) : spObject(p) {}
	inline spPipelineBatch& spPipelineBatch::operator=( const spPipelineBatch &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spPipelineBatch spPipelineBatch::SafeCast( spObject other ) { return spPipelineBatch( IPipelineBatch::SafeCast( other.GetInterface() ) ); }
	inline IPipelineBatch* spPipelineBatch::operator->() const { return static_cast<IPipelineBatch*>(this->ptr); }

	/// Implementations of spPipelineSerializer methods
	inline spPipelineSerializer::spPipelineSerializer( IPipelineSerializer *p ) : spObject(p) {}
	inline spPipelineSerializer::spPipelineSerializer( const spPipelineSerializer &p ) : spObject(p) {}
	inline spPipelineSerializer& spPipelineSerializer::operator=( const spPipelineSerializer &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spPipelineSerializer spPipelineSerializer::SafeCast( spObject other ) { return spPipelineSerializer( IPipelineSerializer::SafeCast( other.GetInterface() ) ); }
	inline IPipelineSerializer* spPipelineSerializer::operator->() const { return static_cast<IPipelineSerializer*>(this->ptr); }

	/// Implementations of spReductionPipeline methods
	inline spReductionPipeline::spReductionPipeline( IReductionPipeline *p ) : spPipeline(p) {}
	inline spReductionPipeline::spReductionPipeline( const spReductionPipeline &p ) : spPipeline(p) {}
	inline spReductionPipeline& spReductionPipeline::operator=( const spReductionPipeline &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spReductionPipeline spReductionPipeline::SafeCast( spObject other ) { return spReductionPipeline( IReductionPipeline::SafeCast( other.GetInterface() ) ); }
	inline IReductionPipeline* spReductionPipeline::operator->() const { return static_cast<IReductionPipeline*>(this->ptr); }

	/// Implementations of spRemeshingLegacyPipeline methods
	inline spRemeshingLegacyPipeline::spRemeshingLegacyPipeline( IRemeshingLegacyPipeline *p ) : spPipeline(p) {}
	inline spRemeshingLegacyPipeline::spRemeshingLegacyPipeline( const spRemeshingLegacyPipeline &p ) : spPipeline(p) {}
	inline spRemeshingLegacyPipeline& spRemeshingLegacyPipeline::operator=( const spRemeshingLegacyPipeline &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spRemeshingLegacyPipeline spRemeshingLegacyPipeline::SafeCast( spObject other ) { return spRemeshingLegacyPipeline( IRemeshingLegacyPipeline::SafeCast( other.GetInterface() ) ); }
	inline IRemeshingLegacyPipeline* spRemeshingLegacyPipeline::operator->() const { return static_cast<IRemeshingLegacyPipeline*>(this->ptr); }

	/// Implementations of spAggregationPipeline methods
	inline spAggregationPipeline::spAggregationPipeline( IAggregationPipeline *p ) : spPipeline(p) {}
	inline spAggregationPipeline::spAggregationPipeline( const spAggregationPipeline &p ) : spPipeline(p) {}
	inline spAggregationPipeline& spAggregationPipeline::operator=( const spAggregationPipeline &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spAggregationPipeline spAggregationPipeline::SafeCast( spObject other ) { return spAggregationPipeline( IAggregationPipeline::SafeCast( other.GetInterface() ) ); }
	inline IAggregationPipeline* spAggregationPipeline::operator->() const { return static_cast<IAggregationPipeline*>(this->ptr); }

	/// Implementations of spPipelineSettings methods
	inline spPipelineSettings::spPipelineSettings( IPipelineSettings *p ) : spSettingsObject(p) {}
	inline spPipelineSettings::spPipelineSettings( const spPipelineSettings &p ) : spSettingsObject(p) {}
	inline spPipelineSettings& spPipelineSettings::operator=( const spPipelineSettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spPipelineSettings spPipelineSettings::SafeCast( spObject other ) { return spPipelineSettings( IPipelineSettings::SafeCast( other.GetInterface() ) ); }
	inline IPipelineSettings* spPipelineSettings::operator->() const { return static_cast<IPipelineSettings*>(this->ptr); }

	/// Implementations of spRemeshingPipeline methods
	inline spRemeshingPipeline::spRemeshingPipeline( IRemeshingPipeline *p ) : spPipeline(p) {}
	inline spRemeshingPipeline::spRemeshingPipeline( const spRemeshingPipeline &p ) : spPipeline(p) {}
	inline spRemeshingPipeline& spRemeshingPipeline::operator=( const spRemeshingPipeline &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spRemeshingPipeline spRemeshingPipeline::SafeCast( spObject other ) { return spRemeshingPipeline( IRemeshingPipeline::SafeCast( other.GetInterface() ) ); }
	inline IRemeshingPipeline* spRemeshingPipeline::operator->() const { return static_cast<IRemeshingPipeline*>(this->ptr); }

	/// Implementations of spPassthroughPipeline methods
	inline spPassthroughPipeline::spPassthroughPipeline( IPassthroughPipeline *p ) : spPipeline(p) {}
	inline spPassthroughPipeline::spPassthroughPipeline( const spPassthroughPipeline &p ) : spPipeline(p) {}
	inline spPassthroughPipeline& spPassthroughPipeline::operator=( const spPassthroughPipeline &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spPassthroughPipeline spPassthroughPipeline::SafeCast( spObject other ) { return spPassthroughPipeline( IPassthroughPipeline::SafeCast( other.GetInterface() ) ); }
	inline IPassthroughPipeline* spPassthroughPipeline::operator->() const { return static_cast<IPassthroughPipeline*>(this->ptr); }

	/// Implementations of spGeometryDataCaster methods
	inline spGeometryDataCaster::spGeometryDataCaster( IGeometryDataCaster *p ) : spMaterialCaster(p) {}
	inline spGeometryDataCaster::spGeometryDataCaster( const spGeometryDataCaster &p ) : spMaterialCaster(p) {}
	inline spGeometryDataCaster& spGeometryDataCaster::operator=( const spGeometryDataCaster &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spGeometryDataCaster spGeometryDataCaster::SafeCast( spObject other ) { return spGeometryDataCaster( IGeometryDataCaster::SafeCast( other.GetInterface() ) ); }
	inline IGeometryDataCaster* spGeometryDataCaster::operator->() const { return static_cast<IGeometryDataCaster*>(this->ptr); }

	/// Implementations of spGeometryDataCasterSettings methods
	inline spGeometryDataCasterSettings::spGeometryDataCasterSettings( IGeometryDataCasterSettings *p ) : spMaterialCasterSettings(p) {}
	inline spGeometryDataCasterSettings::spGeometryDataCasterSettings( const spGeometryDataCasterSettings &p ) : spMaterialCasterSettings(p) {}
	inline spGeometryDataCasterSettings& spGeometryDataCasterSettings::operator=( const spGeometryDataCasterSettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spGeometryDataCasterSettings spGeometryDataCasterSettings::SafeCast( spObject other ) { return spGeometryDataCasterSettings( IGeometryDataCasterSettings::SafeCast( other.GetInterface() ) ); }
	inline IGeometryDataCasterSettings* spGeometryDataCasterSettings::operator->() const { return static_cast<IGeometryDataCasterSettings*>(this->ptr); }

	/// Implementations of spVertexWeightSettings methods
	inline spVertexWeightSettings::spVertexWeightSettings( IVertexWeightSettings *p ) : spSettingsObject(p) {}
	inline spVertexWeightSettings::spVertexWeightSettings( const spVertexWeightSettings &p ) : spSettingsObject(p) {}
	inline spVertexWeightSettings& spVertexWeightSettings::operator=( const spVertexWeightSettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spVertexWeightSettings spVertexWeightSettings::SafeCast( spObject other ) { return spVertexWeightSettings( IVertexWeightSettings::SafeCast( other.GetInterface() ) ); }
	inline IVertexWeightSettings* spVertexWeightSettings::operator->() const { return static_cast<IVertexWeightSettings*>(this->ptr); }

	/// Implementations of spGenerateLightmapTexCoordSettings methods
	inline spGenerateLightmapTexCoordSettings::spGenerateLightmapTexCoordSettings( IGenerateLightmapTexCoordSettings *p ) : spSettingsObject(p) {}
	inline spGenerateLightmapTexCoordSettings::spGenerateLightmapTexCoordSettings( const spGenerateLightmapTexCoordSettings &p ) : spSettingsObject(p) {}
	inline spGenerateLightmapTexCoordSettings& spGenerateLightmapTexCoordSettings::operator=( const spGenerateLightmapTexCoordSettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spGenerateLightmapTexCoordSettings spGenerateLightmapTexCoordSettings::SafeCast( spObject other ) { return spGenerateLightmapTexCoordSettings( IGenerateLightmapTexCoordSettings::SafeCast( other.GetInterface() ) ); }
	inline IGenerateLightmapTexCoordSettings* spGenerateLightmapTexCoordSettings::operator->() const { return static_cast<IGenerateLightmapTexCoordSettings*>(this->ptr); }

	/// Implementations of spChartAggregatorSettings methods
	inline spChartAggregatorSettings::spChartAggregatorSettings( IChartAggregatorSettings *p ) : spSettingsObject(p) {}
	inline spChartAggregatorSettings::spChartAggregatorSettings( const spChartAggregatorSettings &p ) : spSettingsObject(p) {}
	inline spChartAggregatorSettings& spChartAggregatorSettings::operator=( const spChartAggregatorSettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spChartAggregatorSettings spChartAggregatorSettings::SafeCast( spObject other ) { return spChartAggregatorSettings( IChartAggregatorSettings::SafeCast( other.GetInterface() ) ); }
	inline IChartAggregatorSettings* spChartAggregatorSettings::operator->() const { return static_cast<IChartAggregatorSettings*>(this->ptr); }

	/// Implementations of spParameterizerSettings methods
	inline spParameterizerSettings::spParameterizerSettings( IParameterizerSettings *p ) : spSettingsObject(p) {}
	inline spParameterizerSettings::spParameterizerSettings( const spParameterizerSettings &p ) : spSettingsObject(p) {}
	inline spParameterizerSettings& spParameterizerSettings::operator=( const spParameterizerSettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spParameterizerSettings spParameterizerSettings::SafeCast( spObject other ) { return spParameterizerSettings( IParameterizerSettings::SafeCast( other.GetInterface() ) ); }
	inline IParameterizerSettings* spParameterizerSettings::operator->() const { return static_cast<IParameterizerSettings*>(this->ptr); }

	/// Implementations of spBillboardCloudSettings methods
	inline spBillboardCloudSettings::spBillboardCloudSettings( IBillboardCloudSettings *p ) : spSettingsObject(p) {}
	inline spBillboardCloudSettings::spBillboardCloudSettings( const spBillboardCloudSettings &p ) : spSettingsObject(p) {}
	inline spBillboardCloudSettings& spBillboardCloudSettings::operator=( const spBillboardCloudSettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spBillboardCloudSettings spBillboardCloudSettings::SafeCast( spObject other ) { return spBillboardCloudSettings( IBillboardCloudSettings::SafeCast( other.GetInterface() ) ); }
	inline IBillboardCloudSettings* spBillboardCloudSettings::operator->() const { return static_cast<IBillboardCloudSettings*>(this->ptr); }

	/// Implementations of spFlipbookSettings methods
	inline spFlipbookSettings::spFlipbookSettings( IFlipbookSettings *p ) : spSettingsObject(p) {}
	inline spFlipbookSettings::spFlipbookSettings( const spFlipbookSettings &p ) : spSettingsObject(p) {}
	inline spFlipbookSettings& spFlipbookSettings::operator=( const spFlipbookSettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spFlipbookSettings spFlipbookSettings::SafeCast( spObject other ) { return spFlipbookSettings( IFlipbookSettings::SafeCast( other.GetInterface() ) ); }
	inline IFlipbookSettings* spFlipbookSettings::operator->() const { return static_cast<IFlipbookSettings*>(this->ptr); }

	/// Implementations of spImpostorFromSingleViewSettings methods
	inline spImpostorFromSingleViewSettings::spImpostorFromSingleViewSettings( IImpostorFromSingleViewSettings *p ) : spSettingsObject(p) {}
	inline spImpostorFromSingleViewSettings::spImpostorFromSingleViewSettings( const spImpostorFromSingleViewSettings &p ) : spSettingsObject(p) {}
	inline spImpostorFromSingleViewSettings& spImpostorFromSingleViewSettings::operator=( const spImpostorFromSingleViewSettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spImpostorFromSingleViewSettings spImpostorFromSingleViewSettings::SafeCast( spObject other ) { return spImpostorFromSingleViewSettings( IImpostorFromSingleViewSettings::SafeCast( other.GetInterface() ) ); }
	inline IImpostorFromSingleViewSettings* spImpostorFromSingleViewSettings::operator->() const { return static_cast<IImpostorFromSingleViewSettings*>(this->ptr); }

	/// Implementations of spImpostorFromSingleViewPipeline methods
	inline spImpostorFromSingleViewPipeline::spImpostorFromSingleViewPipeline( IImpostorFromSingleViewPipeline *p ) : spPipeline(p) {}
	inline spImpostorFromSingleViewPipeline::spImpostorFromSingleViewPipeline( const spImpostorFromSingleViewPipeline &p ) : spPipeline(p) {}
	inline spImpostorFromSingleViewPipeline& spImpostorFromSingleViewPipeline::operator=( const spImpostorFromSingleViewPipeline &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spImpostorFromSingleViewPipeline spImpostorFromSingleViewPipeline::SafeCast( spObject other ) { return spImpostorFromSingleViewPipeline( IImpostorFromSingleViewPipeline::SafeCast( other.GetInterface() ) ); }
	inline IImpostorFromSingleViewPipeline* spImpostorFromSingleViewPipeline::operator->() const { return static_cast<IImpostorFromSingleViewPipeline*>(this->ptr); }

	/// Implementations of spBillboardCloudPipeline methods
	inline spBillboardCloudPipeline::spBillboardCloudPipeline( IBillboardCloudPipeline *p ) : spPipeline(p) {}
	inline spBillboardCloudPipeline::spBillboardCloudPipeline( const spBillboardCloudPipeline &p ) : spPipeline(p) {}
	inline spBillboardCloudPipeline& spBillboardCloudPipeline::operator=( const spBillboardCloudPipeline &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spBillboardCloudPipeline spBillboardCloudPipeline::SafeCast( spObject other ) { return spBillboardCloudPipeline( IBillboardCloudPipeline::SafeCast( other.GetInterface() ) ); }
	inline IBillboardCloudPipeline* spBillboardCloudPipeline::operator->() const { return static_cast<IBillboardCloudPipeline*>(this->ptr); }

	/// Implementations of spBillboardCloudVegetationPipeline methods
	inline spBillboardCloudVegetationPipeline::spBillboardCloudVegetationPipeline( IBillboardCloudVegetationPipeline *p ) : spPipeline(p) {}
	inline spBillboardCloudVegetationPipeline::spBillboardCloudVegetationPipeline( const spBillboardCloudVegetationPipeline &p ) : spPipeline(p) {}
	inline spBillboardCloudVegetationPipeline& spBillboardCloudVegetationPipeline::operator=( const spBillboardCloudVegetationPipeline &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spBillboardCloudVegetationPipeline spBillboardCloudVegetationPipeline::SafeCast( spObject other ) { return spBillboardCloudVegetationPipeline( IBillboardCloudVegetationPipeline::SafeCast( other.GetInterface() ) ); }
	inline IBillboardCloudVegetationPipeline* spBillboardCloudVegetationPipeline::operator->() const { return static_cast<IBillboardCloudVegetationPipeline*>(this->ptr); }

	/// Implementations of spFlipbookPipeline methods
	inline spFlipbookPipeline::spFlipbookPipeline( IFlipbookPipeline *p ) : spPipeline(p) {}
	inline spFlipbookPipeline::spFlipbookPipeline( const spFlipbookPipeline &p ) : spPipeline(p) {}
	inline spFlipbookPipeline& spFlipbookPipeline::operator=( const spFlipbookPipeline &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spFlipbookPipeline spFlipbookPipeline::SafeCast( spObject other ) { return spFlipbookPipeline( IFlipbookPipeline::SafeCast( other.GetInterface() ) ); }
	inline IFlipbookPipeline* spFlipbookPipeline::operator->() const { return static_cast<IFlipbookPipeline*>(this->ptr); }

	/// Implementations of spFoliageSettings methods
	inline spFoliageSettings::spFoliageSettings( IFoliageSettings *p ) : spSettingsObject(p) {}
	inline spFoliageSettings::spFoliageSettings( const spFoliageSettings &p ) : spSettingsObject(p) {}
	inline spFoliageSettings& spFoliageSettings::operator=( const spFoliageSettings &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spFoliageSettings spFoliageSettings::SafeCast( spObject other ) { return spFoliageSettings( IFoliageSettings::SafeCast( other.GetInterface() ) ); }
	inline IFoliageSettings* spFoliageSettings::operator->() const { return static_cast<IFoliageSettings*>(this->ptr); }

	/// Implementations of spStringArray methods
	inline spStringArray::spStringArray( IStringArray *p ) : spValueArray(p) {}
	inline spStringArray::spStringArray( const spStringArray &p ) : spValueArray(p) {}
	inline spStringArray& spStringArray::operator=( const spStringArray &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spStringArray spStringArray::SafeCast( spObject other ) { return spStringArray( IStringArray::SafeCast( other.GetInterface() ) ); }
	inline IStringArray* spStringArray::operator->() const { return static_cast<IStringArray*>(this->ptr); }

	/// Implementations of spOcclusionMeshPipeline methods
	inline spOcclusionMeshPipeline::spOcclusionMeshPipeline( IOcclusionMeshPipeline *p ) : spPipeline(p) {}
	inline spOcclusionMeshPipeline::spOcclusionMeshPipeline( const spOcclusionMeshPipeline &p ) : spPipeline(p) {}
	inline spOcclusionMeshPipeline& spOcclusionMeshPipeline::operator=( const spOcclusionMeshPipeline &p ) { this->replace_ptr(p.ptr); return *this; }
	inline spOcclusionMeshPipeline spOcclusionMeshPipeline::SafeCast( spObject other ) { return spOcclusionMeshPipeline( IOcclusionMeshPipeline::SafeCast( other.GetInterface() ) ); }
	inline IOcclusionMeshPipeline* spOcclusionMeshPipeline::operator->() const { return static_cast<IOcclusionMeshPipeline*>(this->ptr); }

	/**
	 * Returns the API interface version hash as a string
	 * @return the API interface version hash
	 */
	inline const char *GetInterfaceVersionHash()
	{
		return "337F682340B5B1960FB0419D2C1060DB2457A9FCEBCDF282C8C39353570F3D89";
	}

	/**
	 * Returns the SDK version number of the header file as a string. This may not match the .dll, because headers and .dll files that have the same interface will work properly.
	 * @return the API version string
	 */
	inline const char *GetHeaderVersion()
	{
		return "9.1.25200";
	}

};

#ifdef _WIN32
#pragma warning( pop )
#endif
#endif//_SIMPLYGON_H_
